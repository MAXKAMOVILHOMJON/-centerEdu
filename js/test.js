var D_ = Object.create; var ty = Object.defineProperty; var M_ = Object.getOwnPropertyDescriptor; var B_ = Object.getOwnPropertyNames; var V_ = Object.getPrototypeOf, F_ = Object.prototype.hasOwnProperty; var z_ = (e, t, r) => t in e ? ty(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r; var H_ = (e => typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(e, { get: (t, r) => (typeof require < "u" ? require : t)[r] }) : e)(function (e) { if (typeof require < "u") return require.apply(this, arguments); throw new Error('Dynamic require of "' + e + '" is not supported') }); var wr = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports); var W_ = (e, t, r, n) => { if (t && typeof t == "object" || typeof t == "function") for (let o of B_(t)) !F_.call(e, o) && o !== r && ty(e, o, { get: () => t[o], enumerable: !(n = M_(t, o)) || n.enumerable }); return e }; var I = (e, t, r) => (r = e != null ? D_(V_(e)) : {}, W_(t || !e || !e.__esModule ? ty(r, "default", { value: e, enumerable: !0 }) : r, e)); var Ir = (e, t, r) => (z_(e, typeof t != "symbol" ? t + "" : t, r), r); var NE = wr(ae => { "use strict"; var Hc = Symbol.for("react.element"), j_ = Symbol.for("react.portal"), U_ = Symbol.for("react.fragment"), G_ = Symbol.for("react.strict_mode"), $_ = Symbol.for("react.profiler"), K_ = Symbol.for("react.provider"), X_ = Symbol.for("react.context"), Y_ = Symbol.for("react.forward_ref"), q_ = Symbol.for("react.suspense"), Q_ = Symbol.for("react.memo"), Z_ = Symbol.for("react.lazy"), SE = Symbol.iterator; function J_(e) { return e === null || typeof e != "object" ? null : (e = SE && e[SE] || e["@@iterator"], typeof e == "function" ? e : null) } var EE = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, CE = Object.assign, bE = {}; function Aa(e, t, r) { this.props = e, this.context = t, this.refs = bE, this.updater = r || EE } Aa.prototype.isReactComponent = {}; Aa.prototype.setState = function (e, t) { if (typeof e != "object" && typeof e != "function" && e != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, e, t, "setState") }; Aa.prototype.forceUpdate = function (e) { this.updater.enqueueForceUpdate(this, e, "forceUpdate") }; function wE() { } wE.prototype = Aa.prototype; function ny(e, t, r) { this.props = e, this.context = t, this.refs = bE, this.updater = r || EE } var oy = ny.prototype = new wE; oy.constructor = ny; CE(oy, Aa.prototype); oy.isPureReactComponent = !0; var xE = Array.isArray, IE = Object.prototype.hasOwnProperty, iy = { current: null }, RE = { key: !0, ref: !0, __self: !0, __source: !0 }; function kE(e, t, r) { var n, o = {}, i = null, s = null; if (t != null) for (n in t.ref !== void 0 && (s = t.ref), t.key !== void 0 && (i = "" + t.key), t) IE.call(t, n) && !RE.hasOwnProperty(n) && (o[n] = t[n]); var a = arguments.length - 2; if (a === 1) o.children = r; else if (1 < a) { for (var l = Array(a), c = 0; c < a; c++)l[c] = arguments[c + 2]; o.children = l } if (e && e.defaultProps) for (n in a = e.defaultProps, a) o[n] === void 0 && (o[n] = a[n]); return { $$typeof: Hc, type: e, key: i, ref: s, props: o, _owner: iy.current } } function eD(e, t) { return { $$typeof: Hc, type: e.type, key: t, ref: e.ref, props: e.props, _owner: e._owner } } function sy(e) { return typeof e == "object" && e !== null && e.$$typeof === Hc } function tD(e) { var t = { "=": "=0", ":": "=2" }; return "$" + e.replace(/[=:]/g, function (r) { return t[r] }) } var TE = /\/+/g; function ry(e, t) { return typeof e == "object" && e !== null && e.key != null ? tD("" + e.key) : t.toString(36) } function Gd(e, t, r, n, o) { var i = typeof e; (i === "undefined" || i === "boolean") && (e = null); var s = !1; if (e === null) s = !0; else switch (i) { case "string": case "number": s = !0; break; case "object": switch (e.$$typeof) { case Hc: case j_: s = !0 } }if (s) return s = e, o = o(s), e = n === "" ? "." + ry(s, 0) : n, xE(o) ? (r = "", e != null && (r = e.replace(TE, "$&/") + "/"), Gd(o, t, r, "", function (c) { return c })) : o != null && (sy(o) && (o = eD(o, r + (!o.key || s && s.key === o.key ? "" : ("" + o.key).replace(TE, "$&/") + "/") + e)), t.push(o)), 1; if (s = 0, n = n === "" ? "." : n + ":", xE(e)) for (var a = 0; a < e.length; a++) { i = e[a]; var l = n + ry(i, a); s += Gd(i, t, r, l, o) } else if (l = J_(e), typeof l == "function") for (e = l.call(e), a = 0; !(i = e.next()).done;)i = i.value, l = n + ry(i, a++), s += Gd(i, t, r, l, o); else if (i === "object") throw t = String(e), Error("Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead."); return s } function Ud(e, t, r) { if (e == null) return e; var n = [], o = 0; return Gd(e, n, "", "", function (i) { return t.call(r, i, o++) }), n } function rD(e) { if (e._status === -1) { var t = e._result; t = t(), t.then(function (r) { (e._status === 0 || e._status === -1) && (e._status = 1, e._result = r) }, function (r) { (e._status === 0 || e._status === -1) && (e._status = 2, e._result = r) }), e._status === -1 && (e._status = 0, e._result = t) } if (e._status === 1) return e._result.default; throw e._result } var qt = { current: null }, $d = { transition: null }, nD = { ReactCurrentDispatcher: qt, ReactCurrentBatchConfig: $d, ReactCurrentOwner: iy }; function AE() { throw Error("act(...) is not supported in production builds of React.") } ae.Children = { map: Ud, forEach: function (e, t, r) { Ud(e, function () { t.apply(this, arguments) }, r) }, count: function (e) { var t = 0; return Ud(e, function () { t++ }), t }, toArray: function (e) { return Ud(e, function (t) { return t }) || [] }, only: function (e) { if (!sy(e)) throw Error("React.Children.only expected to receive a single React element child."); return e } }; ae.Component = Aa; ae.Fragment = U_; ae.Profiler = $_; ae.PureComponent = ny; ae.StrictMode = G_; ae.Suspense = q_; ae.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = nD; ae.act = AE; ae.cloneElement = function (e, t, r) { if (e == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + "."); var n = CE({}, e.props), o = e.key, i = e.ref, s = e._owner; if (t != null) { if (t.ref !== void 0 && (i = t.ref, s = iy.current), t.key !== void 0 && (o = "" + t.key), e.type && e.type.defaultProps) var a = e.type.defaultProps; for (l in t) IE.call(t, l) && !RE.hasOwnProperty(l) && (n[l] = t[l] === void 0 && a !== void 0 ? a[l] : t[l]) } var l = arguments.length - 2; if (l === 1) n.children = r; else if (1 < l) { a = Array(l); for (var c = 0; c < l; c++)a[c] = arguments[c + 2]; n.children = a } return { $$typeof: Hc, type: e.type, key: o, ref: i, props: n, _owner: s } }; ae.createContext = function (e) { return e = { $$typeof: X_, _currentValue: e, _currentValue2: e, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, e.Provider = { $$typeof: K_, _context: e }, e.Consumer = e }; ae.createElement = kE; ae.createFactory = function (e) { var t = kE.bind(null, e); return t.type = e, t }; ae.createRef = function () { return { current: null } }; ae.forwardRef = function (e) { return { $$typeof: Y_, render: e } }; ae.isValidElement = sy; ae.lazy = function (e) { return { $$typeof: Z_, _payload: { _status: -1, _result: e }, _init: rD } }; ae.memo = function (e, t) { return { $$typeof: Q_, type: e, compare: t === void 0 ? null : t } }; ae.startTransition = function (e) { var t = $d.transition; $d.transition = {}; try { e() } finally { $d.transition = t } }; ae.unstable_act = AE; ae.useCallback = function (e, t) { return qt.current.useCallback(e, t) }; ae.useContext = function (e) { return qt.current.useContext(e) }; ae.useDebugValue = function () { }; ae.useDeferredValue = function (e) { return qt.current.useDeferredValue(e) }; ae.useEffect = function (e, t) { return qt.current.useEffect(e, t) }; ae.useId = function () { return qt.current.useId() }; ae.useImperativeHandle = function (e, t, r) { return qt.current.useImperativeHandle(e, t, r) }; ae.useInsertionEffect = function (e, t) { return qt.current.useInsertionEffect(e, t) }; ae.useLayoutEffect = function (e, t) { return qt.current.useLayoutEffect(e, t) }; ae.useMemo = function (e, t) { return qt.current.useMemo(e, t) }; ae.useReducer = function (e, t, r) { return qt.current.useReducer(e, t, r) }; ae.useRef = function (e) { return qt.current.useRef(e) }; ae.useState = function (e) { return qt.current.useState(e) }; ae.useSyncExternalStore = function (e, t, r) { return qt.current.useSyncExternalStore(e, t, r) }; ae.useTransition = function () { return qt.current.useTransition() }; ae.version = "18.3.1" }); var P = wr((r4, OE) => { "use strict"; OE.exports = NE() }); var HE = wr(Pe => { "use strict"; function uy(e, t) { var r = e.length; e.push(t); e: for (; 0 < r;) { var n = r - 1 >>> 1, o = e[n]; if (0 < Kd(o, t)) e[n] = t, e[r] = o, r = n; else break e } } function bn(e) { return e.length === 0 ? null : e[0] } function Yd(e) { if (e.length === 0) return null; var t = e[0], r = e.pop(); if (r !== t) { e[0] = r; e: for (var n = 0, o = e.length, i = o >>> 1; n < i;) { var s = 2 * (n + 1) - 1, a = e[s], l = s + 1, c = e[l]; if (0 > Kd(a, r)) l < o && 0 > Kd(c, a) ? (e[n] = c, e[l] = r, n = l) : (e[n] = a, e[s] = r, n = s); else if (l < o && 0 > Kd(c, r)) e[n] = c, e[l] = r, n = l; else break e } } return t } function Kd(e, t) { var r = e.sortIndex - t.sortIndex; return r !== 0 ? r : e.id - t.id } typeof performance == "object" && typeof performance.now == "function" ? (PE = performance, Pe.unstable_now = function () { return PE.now() }) : (ay = Date, LE = ay.now(), Pe.unstable_now = function () { return ay.now() - LE }); var PE, ay, LE, Gn = [], fi = [], oD = 1, Ur = null, _t = 3, qd = !1, ws = !1, jc = !1, ME = typeof setTimeout == "function" ? setTimeout : null, BE = typeof clearTimeout == "function" ? clearTimeout : null, _E = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function dy(e) { for (var t = bn(fi); t !== null;) { if (t.callback === null) Yd(fi); else if (t.startTime <= e) Yd(fi), t.sortIndex = t.expirationTime, uy(Gn, t); else break; t = bn(fi) } } function fy(e) { if (jc = !1, dy(e), !ws) if (bn(Gn) !== null) ws = !0, my(py); else { var t = bn(fi); t !== null && hy(fy, t.startTime - e) } } function py(e, t) { ws = !1, jc && (jc = !1, BE(Uc), Uc = -1), qd = !0; var r = _t; try { for (dy(t), Ur = bn(Gn); Ur !== null && (!(Ur.expirationTime > t) || e && !zE());) { var n = Ur.callback; if (typeof n == "function") { Ur.callback = null, _t = Ur.priorityLevel; var o = n(Ur.expirationTime <= t); t = Pe.unstable_now(), typeof o == "function" ? Ur.callback = o : Ur === bn(Gn) && Yd(Gn), dy(t) } else Yd(Gn); Ur = bn(Gn) } if (Ur !== null) var i = !0; else { var s = bn(fi); s !== null && hy(fy, s.startTime - t), i = !1 } return i } finally { Ur = null, _t = r, qd = !1 } } var Qd = !1, Xd = null, Uc = -1, VE = 5, FE = -1; function zE() { return !(Pe.unstable_now() - FE < VE) } function ly() { if (Xd !== null) { var e = Pe.unstable_now(); FE = e; var t = !0; try { t = Xd(!0, e) } finally { t ? Wc() : (Qd = !1, Xd = null) } } else Qd = !1 } var Wc; typeof _E == "function" ? Wc = function () { _E(ly) } : typeof MessageChannel < "u" ? (cy = new MessageChannel, DE = cy.port2, cy.port1.onmessage = ly, Wc = function () { DE.postMessage(null) }) : Wc = function () { ME(ly, 0) }; var cy, DE; function my(e) { Xd = e, Qd || (Qd = !0, Wc()) } function hy(e, t) { Uc = ME(function () { e(Pe.unstable_now()) }, t) } Pe.unstable_IdlePriority = 5; Pe.unstable_ImmediatePriority = 1; Pe.unstable_LowPriority = 4; Pe.unstable_NormalPriority = 3; Pe.unstable_Profiling = null; Pe.unstable_UserBlockingPriority = 2; Pe.unstable_cancelCallback = function (e) { e.callback = null }; Pe.unstable_continueExecution = function () { ws || qd || (ws = !0, my(py)) }; Pe.unstable_forceFrameRate = function (e) { 0 > e || 125 < e ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : VE = 0 < e ? Math.floor(1e3 / e) : 5 }; Pe.unstable_getCurrentPriorityLevel = function () { return _t }; Pe.unstable_getFirstCallbackNode = function () { return bn(Gn) }; Pe.unstable_next = function (e) { switch (_t) { case 1: case 2: case 3: var t = 3; break; default: t = _t }var r = _t; _t = t; try { return e() } finally { _t = r } }; Pe.unstable_pauseExecution = function () { }; Pe.unstable_requestPaint = function () { }; Pe.unstable_runWithPriority = function (e, t) { switch (e) { case 1: case 2: case 3: case 4: case 5: break; default: e = 3 }var r = _t; _t = e; try { return t() } finally { _t = r } }; Pe.unstable_scheduleCallback = function (e, t, r) { var n = Pe.unstable_now(); switch (typeof r == "object" && r !== null ? (r = r.delay, r = typeof r == "number" && 0 < r ? n + r : n) : r = n, e) { case 1: var o = -1; break; case 2: o = 250; break; case 5: o = 1073741823; break; case 4: o = 1e4; break; default: o = 5e3 }return o = r + o, e = { id: oD++, callback: t, priorityLevel: e, startTime: r, expirationTime: o, sortIndex: -1 }, r > n ? (e.sortIndex = r, uy(fi, e), bn(Gn) === null && e === bn(fi) && (jc ? (BE(Uc), Uc = -1) : jc = !0, hy(fy, r - n))) : (e.sortIndex = o, uy(Gn, e), ws || qd || (ws = !0, my(py))), e }; Pe.unstable_shouldYield = zE; Pe.unstable_wrapCallback = function (e) { var t = _t; return function () { var r = _t; _t = t; try { return e.apply(this, arguments) } finally { _t = r } } } }); var jE = wr((o4, WE) => { "use strict"; WE.exports = HE() }); var K1 = wr(Pr => {
  "use strict"; var iD = P(), Nr = jE(); function _(e) { for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, r = 1; r < arguments.length; r++)t += "&args[]=" + encodeURIComponent(arguments[r]); return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var qC = new Set, fu = {}; function Vs(e, t) { qa(e, t), qa(e + "Capture", t) } function qa(e, t) { for (fu[e] = t, e = 0; e < t.length; e++)qC.add(t[e]) } var wo = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), Vy = Object.prototype.hasOwnProperty, sD = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, UE = {}, GE = {}; function aD(e) { return Vy.call(GE, e) ? !0 : Vy.call(UE, e) ? !1 : sD.test(e) ? GE[e] = !0 : (UE[e] = !0, !1) } function lD(e, t, r, n) { if (r !== null && r.type === 0) return !1; switch (typeof t) { case "function": case "symbol": return !0; case "boolean": return n ? !1 : r !== null ? !r.acceptsBooleans : (e = e.toLowerCase().slice(0, 5), e !== "data-" && e !== "aria-"); default: return !1 } } function cD(e, t, r, n) { if (t === null || typeof t > "u" || lD(e, t, r, n)) return !0; if (n) return !1; if (r !== null) switch (r.type) { case 3: return !t; case 4: return t === !1; case 5: return isNaN(t); case 6: return isNaN(t) || 1 > t }return !1 } function Jt(e, t, r, n, o, i, s) { this.acceptsBooleans = t === 2 || t === 3 || t === 4, this.attributeName = n, this.attributeNamespace = o, this.mustUseProperty = r, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = s } var It = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (e) { It[e] = new Jt(e, 0, !1, e, null, !1, !1) });[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (e) { var t = e[0]; It[t] = new Jt(t, 1, !1, e[1], null, !1, !1) });["contentEditable", "draggable", "spellCheck", "value"].forEach(function (e) { It[e] = new Jt(e, 2, !1, e.toLowerCase(), null, !1, !1) });["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (e) { It[e] = new Jt(e, 2, !1, e, null, !1, !1) }); "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (e) { It[e] = new Jt(e, 3, !1, e.toLowerCase(), null, !1, !1) });["checked", "multiple", "muted", "selected"].forEach(function (e) { It[e] = new Jt(e, 3, !0, e, null, !1, !1) });["capture", "download"].forEach(function (e) { It[e] = new Jt(e, 4, !1, e, null, !1, !1) });["cols", "rows", "size", "span"].forEach(function (e) { It[e] = new Jt(e, 6, !1, e, null, !1, !1) });["rowSpan", "start"].forEach(function (e) { It[e] = new Jt(e, 5, !1, e.toLowerCase(), null, !1, !1) }); var Nv = /[\-:]([a-z])/g; function Ov(e) { return e[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (e) { var t = e.replace(Nv, Ov); It[t] = new Jt(t, 1, !1, e, null, !1, !1) }); "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (e) { var t = e.replace(Nv, Ov); It[t] = new Jt(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1) });["xml:base", "xml:lang", "xml:space"].forEach(function (e) { var t = e.replace(Nv, Ov); It[t] = new Jt(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1) });["tabIndex", "crossOrigin"].forEach(function (e) { It[e] = new Jt(e, 1, !1, e.toLowerCase(), null, !1, !1) }); It.xlinkHref = new Jt("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);["src", "href", "action", "formAction"].forEach(function (e) { It[e] = new Jt(e, 1, !1, e.toLowerCase(), null, !0, !0) }); function Pv(e, t, r, n) { var o = It.hasOwnProperty(t) ? It[t] : null; (o !== null ? o.type !== 0 : n || !(2 < t.length) || t[0] !== "o" && t[0] !== "O" || t[1] !== "n" && t[1] !== "N") && (cD(t, r, o, n) && (r = null), n || o === null ? aD(t) && (r === null ? e.removeAttribute(t) : e.setAttribute(t, "" + r)) : o.mustUseProperty ? e[o.propertyName] = r === null ? o.type === 3 ? !1 : "" : r : (t = o.attributeName, n = o.attributeNamespace, r === null ? e.removeAttribute(t) : (o = o.type, r = o === 3 || o === 4 && r === !0 ? "" : "" + r, n ? e.setAttributeNS(n, t, r) : e.setAttribute(t, r)))) } var Ao = iD.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, Zd = Symbol.for("react.element"), Pa = Symbol.for("react.portal"), La = Symbol.for("react.fragment"), Lv = Symbol.for("react.strict_mode"), Fy = Symbol.for("react.profiler"), QC = Symbol.for("react.provider"), ZC = Symbol.for("react.context"), _v = Symbol.for("react.forward_ref"), zy = Symbol.for("react.suspense"), Hy = Symbol.for("react.suspense_list"), Dv = Symbol.for("react.memo"), mi = Symbol.for("react.lazy"); Symbol.for("react.scope"); Symbol.for("react.debug_trace_mode"); var JC = Symbol.for("react.offscreen"); Symbol.for("react.legacy_hidden"); Symbol.for("react.cache"); Symbol.for("react.tracing_marker"); var $E = Symbol.iterator; function Gc(e) { return e === null || typeof e != "object" ? null : (e = $E && e[$E] || e["@@iterator"], typeof e == "function" ? e : null) } var Ge = Object.assign, gy; function Jc(e) {
    if (gy === void 0) try { throw Error() } catch (r) { var t = r.stack.trim().match(/\n( *(at )?)/); gy = t && t[1] || "" } return `
`+ gy + e
  } var yy = !1; function vy(e, t) {
    if (!e || yy) return ""; yy = !0; var r = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (t) if (t = function () { throw Error() }, Object.defineProperty(t.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(t, []) } catch (c) { var n = c } Reflect.construct(e, [], t) } else { try { t.call() } catch (c) { n = c } e.call(t.prototype) } else { try { throw Error() } catch (c) { n = c } e() } } catch (c) {
      if (c && n && typeof c.stack == "string") {
        for (var o = c.stack.split(`
`), i = n.stack.split(`
`), s = o.length - 1, a = i.length - 1; 1 <= s && 0 <= a && o[s] !== i[a];)a--; for (; 1 <= s && 0 <= a; s--, a--)if (o[s] !== i[a]) {
          if (s !== 1 || a !== 1) do if (s--, a--, 0 > a || o[s] !== i[a]) {
            var l = `
`+ o[s].replace(" at new ", " at "); return e.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", e.displayName)), l
          } while (1 <= s && 0 <= a); break
        }
      }
    } finally { yy = !1, Error.prepareStackTrace = r } return (e = e ? e.displayName || e.name : "") ? Jc(e) : ""
  } function uD(e) { switch (e.tag) { case 5: return Jc(e.type); case 16: return Jc("Lazy"); case 13: return Jc("Suspense"); case 19: return Jc("SuspenseList"); case 0: case 2: case 15: return e = vy(e.type, !1), e; case 11: return e = vy(e.type.render, !1), e; case 1: return e = vy(e.type, !0), e; default: return "" } } function Wy(e) { if (e == null) return null; if (typeof e == "function") return e.displayName || e.name || null; if (typeof e == "string") return e; switch (e) { case La: return "Fragment"; case Pa: return "Portal"; case Fy: return "Profiler"; case Lv: return "StrictMode"; case zy: return "Suspense"; case Hy: return "SuspenseList" }if (typeof e == "object") switch (e.$$typeof) { case ZC: return (e.displayName || "Context") + ".Consumer"; case QC: return (e._context.displayName || "Context") + ".Provider"; case _v: var t = e.render; return e = e.displayName, e || (e = t.displayName || t.name || "", e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"), e; case Dv: return t = e.displayName || null, t !== null ? t : Wy(e.type) || "Memo"; case mi: t = e._payload, e = e._init; try { return Wy(e(t)) } catch { } }return null } function dD(e) { var t = e.type; switch (e.tag) { case 24: return "Cache"; case 9: return (t.displayName || "Context") + ".Consumer"; case 10: return (t._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return e = t.render, e = e.displayName || e.name || "", t.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return t; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return Wy(t); case 8: return t === Lv ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof t == "function") return t.displayName || t.name || null; if (typeof t == "string") return t }return null } function ki(e) { switch (typeof e) { case "boolean": case "number": case "string": case "undefined": return e; case "object": return e; default: return "" } } function eb(e) { var t = e.type; return (e = e.nodeName) && e.toLowerCase() === "input" && (t === "checkbox" || t === "radio") } function fD(e) { var t = eb(e) ? "checked" : "value", r = Object.getOwnPropertyDescriptor(e.constructor.prototype, t), n = "" + e[t]; if (!e.hasOwnProperty(t) && typeof r < "u" && typeof r.get == "function" && typeof r.set == "function") { var o = r.get, i = r.set; return Object.defineProperty(e, t, { configurable: !0, get: function () { return o.call(this) }, set: function (s) { n = "" + s, i.call(this, s) } }), Object.defineProperty(e, t, { enumerable: r.enumerable }), { getValue: function () { return n }, setValue: function (s) { n = "" + s }, stopTracking: function () { e._valueTracker = null, delete e[t] } } } } function Jd(e) { e._valueTracker || (e._valueTracker = fD(e)) } function tb(e) { if (!e) return !1; var t = e._valueTracker; if (!t) return !0; var r = t.getValue(), n = ""; return e && (n = eb(e) ? e.checked ? "true" : "false" : e.value), e = n, e !== r ? (t.setValue(e), !0) : !1 } function kf(e) { if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u") return null; try { return e.activeElement || e.body } catch { return e.body } } function jy(e, t) { var r = t.checked; return Ge({}, t, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: r ?? e._wrapperState.initialChecked }) } function KE(e, t) { var r = t.defaultValue == null ? "" : t.defaultValue, n = t.checked != null ? t.checked : t.defaultChecked; r = ki(t.value != null ? t.value : r), e._wrapperState = { initialChecked: n, initialValue: r, controlled: t.type === "checkbox" || t.type === "radio" ? t.checked != null : t.value != null } } function rb(e, t) { t = t.checked, t != null && Pv(e, "checked", t, !1) } function Uy(e, t) { rb(e, t); var r = ki(t.value), n = t.type; if (r != null) n === "number" ? (r === 0 && e.value === "" || e.value != r) && (e.value = "" + r) : e.value !== "" + r && (e.value = "" + r); else if (n === "submit" || n === "reset") { e.removeAttribute("value"); return } t.hasOwnProperty("value") ? Gy(e, t.type, r) : t.hasOwnProperty("defaultValue") && Gy(e, t.type, ki(t.defaultValue)), t.checked == null && t.defaultChecked != null && (e.defaultChecked = !!t.defaultChecked) } function XE(e, t, r) { if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) { var n = t.type; if (!(n !== "submit" && n !== "reset" || t.value !== void 0 && t.value !== null)) return; t = "" + e._wrapperState.initialValue, r || t === e.value || (e.value = t), e.defaultValue = t } r = e.name, r !== "" && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, r !== "" && (e.name = r) } function Gy(e, t, r) { (t !== "number" || kf(e.ownerDocument) !== e) && (r == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + r && (e.defaultValue = "" + r)) } var eu = Array.isArray; function Ua(e, t, r, n) { if (e = e.options, t) { t = {}; for (var o = 0; o < r.length; o++)t["$" + r[o]] = !0; for (r = 0; r < e.length; r++)o = t.hasOwnProperty("$" + e[r].value), e[r].selected !== o && (e[r].selected = o), o && n && (e[r].defaultSelected = !0) } else { for (r = "" + ki(r), t = null, o = 0; o < e.length; o++) { if (e[o].value === r) { e[o].selected = !0, n && (e[o].defaultSelected = !0); return } t !== null || e[o].disabled || (t = e[o]) } t !== null && (t.selected = !0) } } function $y(e, t) { if (t.dangerouslySetInnerHTML != null) throw Error(_(91)); return Ge({}, t, { value: void 0, defaultValue: void 0, children: "" + e._wrapperState.initialValue }) } function YE(e, t) { var r = t.value; if (r == null) { if (r = t.children, t = t.defaultValue, r != null) { if (t != null) throw Error(_(92)); if (eu(r)) { if (1 < r.length) throw Error(_(93)); r = r[0] } t = r } t == null && (t = ""), r = t } e._wrapperState = { initialValue: ki(r) } } function nb(e, t) { var r = ki(t.value), n = ki(t.defaultValue); r != null && (r = "" + r, r !== e.value && (e.value = r), t.defaultValue == null && e.defaultValue !== r && (e.defaultValue = r)), n != null && (e.defaultValue = "" + n) } function qE(e) { var t = e.textContent; t === e._wrapperState.initialValue && t !== "" && t !== null && (e.value = t) } function ob(e) { switch (e) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function Ky(e, t) { return e == null || e === "http://www.w3.org/1999/xhtml" ? ob(t) : e === "http://www.w3.org/2000/svg" && t === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e } var ef, ib = function (e) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (t, r, n, o) { MSApp.execUnsafeLocalFunction(function () { return e(t, r, n, o) }) } : e }(function (e, t) { if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in e) e.innerHTML = t; else { for (ef = ef || document.createElement("div"), ef.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = ef.firstChild; e.firstChild;)e.removeChild(e.firstChild); for (; t.firstChild;)e.appendChild(t.firstChild) } }); function pu(e, t) { if (t) { var r = e.firstChild; if (r && r === e.lastChild && r.nodeType === 3) { r.nodeValue = t; return } } e.textContent = t } var nu = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, pD = ["Webkit", "ms", "Moz", "O"]; Object.keys(nu).forEach(function (e) { pD.forEach(function (t) { t = t + e.charAt(0).toUpperCase() + e.substring(1), nu[t] = nu[e] }) }); function sb(e, t, r) { return t == null || typeof t == "boolean" || t === "" ? "" : r || typeof t != "number" || t === 0 || nu.hasOwnProperty(e) && nu[e] ? ("" + t).trim() : t + "px" } function ab(e, t) { e = e.style; for (var r in t) if (t.hasOwnProperty(r)) { var n = r.indexOf("--") === 0, o = sb(r, t[r], n); r === "float" && (r = "cssFloat"), n ? e.setProperty(r, o) : e[r] = o } } var mD = Ge({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function Xy(e, t) { if (t) { if (mD[e] && (t.children != null || t.dangerouslySetInnerHTML != null)) throw Error(_(137, e)); if (t.dangerouslySetInnerHTML != null) { if (t.children != null) throw Error(_(60)); if (typeof t.dangerouslySetInnerHTML != "object" || !("__html" in t.dangerouslySetInnerHTML)) throw Error(_(61)) } if (t.style != null && typeof t.style != "object") throw Error(_(62)) } } function Yy(e, t) { if (e.indexOf("-") === -1) return typeof t.is == "string"; switch (e) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var qy = null; function Mv(e) { return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e } var Qy = null, Ga = null, $a = null; function QE(e) { if (e = Ou(e)) { if (typeof Qy != "function") throw Error(_(280)); var t = e.stateNode; t && (t = rp(t), Qy(e.stateNode, e.type, t)) } } function lb(e) { Ga ? $a ? $a.push(e) : $a = [e] : Ga = e } function cb() { if (Ga) { var e = Ga, t = $a; if ($a = Ga = null, QE(e), t) for (e = 0; e < t.length; e++)QE(t[e]) } } function ub(e, t) { return e(t) } function db() { } var Sy = !1; function fb(e, t, r) { if (Sy) return e(t, r); Sy = !0; try { return ub(e, t, r) } finally { Sy = !1, (Ga !== null || $a !== null) && (db(), cb()) } } function mu(e, t) { var r = e.stateNode; if (r === null) return null; var n = rp(r); if (n === null) return null; r = n[t]; e: switch (t) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (n = !n.disabled) || (e = e.type, n = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !n; break e; default: e = !1 }if (e) return null; if (r && typeof r != "function") throw Error(_(231, t, typeof r)); return r } var Zy = !1; if (wo) try { Na = {}, Object.defineProperty(Na, "passive", { get: function () { Zy = !0 } }), window.addEventListener("test", Na, Na), window.removeEventListener("test", Na, Na) } catch { Zy = !1 } var Na; function hD(e, t, r, n, o, i, s, a, l) { var c = Array.prototype.slice.call(arguments, 3); try { t.apply(r, c) } catch (u) { this.onError(u) } } var ou = !1, Af = null, Nf = !1, Jy = null, gD = { onError: function (e) { ou = !0, Af = e } }; function yD(e, t, r, n, o, i, s, a, l) { ou = !1, Af = null, hD.apply(gD, arguments) } function vD(e, t, r, n, o, i, s, a, l) { if (yD.apply(this, arguments), ou) { if (ou) { var c = Af; ou = !1, Af = null } else throw Error(_(198)); Nf || (Nf = !0, Jy = c) } } function Fs(e) { var t = e, r = e; if (e.alternate) for (; t.return;)t = t.return; else { e = t; do t = e, t.flags & 4098 && (r = t.return), e = t.return; while (e) } return t.tag === 3 ? r : null } function pb(e) { if (e.tag === 13) { var t = e.memoizedState; if (t === null && (e = e.alternate, e !== null && (t = e.memoizedState)), t !== null) return t.dehydrated } return null } function ZE(e) { if (Fs(e) !== e) throw Error(_(188)) } function SD(e) { var t = e.alternate; if (!t) { if (t = Fs(e), t === null) throw Error(_(188)); return t !== e ? null : e } for (var r = e, n = t; ;) { var o = r.return; if (o === null) break; var i = o.alternate; if (i === null) { if (n = o.return, n !== null) { r = n; continue } break } if (o.child === i.child) { for (i = o.child; i;) { if (i === r) return ZE(o), e; if (i === n) return ZE(o), t; i = i.sibling } throw Error(_(188)) } if (r.return !== n.return) r = o, n = i; else { for (var s = !1, a = o.child; a;) { if (a === r) { s = !0, r = o, n = i; break } if (a === n) { s = !0, n = o, r = i; break } a = a.sibling } if (!s) { for (a = i.child; a;) { if (a === r) { s = !0, r = i, n = o; break } if (a === n) { s = !0, n = i, r = o; break } a = a.sibling } if (!s) throw Error(_(189)) } } if (r.alternate !== n) throw Error(_(190)) } if (r.tag !== 3) throw Error(_(188)); return r.stateNode.current === r ? e : t } function mb(e) { return e = SD(e), e !== null ? hb(e) : null } function hb(e) { if (e.tag === 5 || e.tag === 6) return e; for (e = e.child; e !== null;) { var t = hb(e); if (t !== null) return t; e = e.sibling } return null } var gb = Nr.unstable_scheduleCallback, JE = Nr.unstable_cancelCallback, xD = Nr.unstable_shouldYield, TD = Nr.unstable_requestPaint, Ze = Nr.unstable_now, ED = Nr.unstable_getCurrentPriorityLevel, Bv = Nr.unstable_ImmediatePriority, yb = Nr.unstable_UserBlockingPriority, Of = Nr.unstable_NormalPriority, CD = Nr.unstable_LowPriority, vb = Nr.unstable_IdlePriority, Zf = null, Yn = null; function bD(e) { if (Yn && typeof Yn.onCommitFiberRoot == "function") try { Yn.onCommitFiberRoot(Zf, e, void 0, (e.current.flags & 128) === 128) } catch { } } var An = Math.clz32 ? Math.clz32 : RD, wD = Math.log, ID = Math.LN2; function RD(e) { return e >>>= 0, e === 0 ? 32 : 31 - (wD(e) / ID | 0) | 0 } var tf = 64, rf = 4194304; function tu(e) { switch (e & -e) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return e & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return e & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return e } } function Pf(e, t) { var r = e.pendingLanes; if (r === 0) return 0; var n = 0, o = e.suspendedLanes, i = e.pingedLanes, s = r & 268435455; if (s !== 0) { var a = s & ~o; a !== 0 ? n = tu(a) : (i &= s, i !== 0 && (n = tu(i))) } else s = r & ~o, s !== 0 ? n = tu(s) : i !== 0 && (n = tu(i)); if (n === 0) return 0; if (t !== 0 && t !== n && !(t & o) && (o = n & -n, i = t & -t, o >= i || o === 16 && (i & 4194240) !== 0)) return t; if (n & 4 && (n |= r & 16), t = e.entangledLanes, t !== 0) for (e = e.entanglements, t &= n; 0 < t;)r = 31 - An(t), o = 1 << r, n |= e[r], t &= ~o; return n } function kD(e, t) { switch (e) { case 1: case 2: case 4: return t + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function AD(e, t) { for (var r = e.suspendedLanes, n = e.pingedLanes, o = e.expirationTimes, i = e.pendingLanes; 0 < i;) { var s = 31 - An(i), a = 1 << s, l = o[s]; l === -1 ? (!(a & r) || a & n) && (o[s] = kD(a, t)) : l <= t && (e.expiredLanes |= a), i &= ~a } } function ev(e) { return e = e.pendingLanes & -1073741825, e !== 0 ? e : e & 1073741824 ? 1073741824 : 0 } function Sb() { var e = tf; return tf <<= 1, !(tf & 4194240) && (tf = 64), e } function xy(e) { for (var t = [], r = 0; 31 > r; r++)t.push(e); return t } function Au(e, t, r) { e.pendingLanes |= t, t !== 536870912 && (e.suspendedLanes = 0, e.pingedLanes = 0), e = e.eventTimes, t = 31 - An(t), e[t] = r } function ND(e, t) { var r = e.pendingLanes & ~t; e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements; var n = e.eventTimes; for (e = e.expirationTimes; 0 < r;) { var o = 31 - An(r), i = 1 << o; t[o] = 0, n[o] = -1, e[o] = -1, r &= ~i } } function Vv(e, t) { var r = e.entangledLanes |= t; for (e = e.entanglements; r;) { var n = 31 - An(r), o = 1 << n; o & t | e[n] & t && (e[n] |= t), r &= ~o } } var be = 0; function xb(e) { return e &= -e, 1 < e ? 4 < e ? e & 268435455 ? 16 : 536870912 : 4 : 1 } var Tb, Fv, Eb, Cb, bb, tv = !1, nf = [], xi = null, Ti = null, Ei = null, hu = new Map, gu = new Map, gi = [], OD = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function eC(e, t) { switch (e) { case "focusin": case "focusout": xi = null; break; case "dragenter": case "dragleave": Ti = null; break; case "mouseover": case "mouseout": Ei = null; break; case "pointerover": case "pointerout": hu.delete(t.pointerId); break; case "gotpointercapture": case "lostpointercapture": gu.delete(t.pointerId) } } function $c(e, t, r, n, o, i) { return e === null || e.nativeEvent !== i ? (e = { blockedOn: t, domEventName: r, eventSystemFlags: n, nativeEvent: i, targetContainers: [o] }, t !== null && (t = Ou(t), t !== null && Fv(t)), e) : (e.eventSystemFlags |= n, t = e.targetContainers, o !== null && t.indexOf(o) === -1 && t.push(o), e) } function PD(e, t, r, n, o) { switch (t) { case "focusin": return xi = $c(xi, e, t, r, n, o), !0; case "dragenter": return Ti = $c(Ti, e, t, r, n, o), !0; case "mouseover": return Ei = $c(Ei, e, t, r, n, o), !0; case "pointerover": var i = o.pointerId; return hu.set(i, $c(hu.get(i) || null, e, t, r, n, o)), !0; case "gotpointercapture": return i = o.pointerId, gu.set(i, $c(gu.get(i) || null, e, t, r, n, o)), !0 }return !1 } function wb(e) { var t = ks(e.target); if (t !== null) { var r = Fs(t); if (r !== null) { if (t = r.tag, t === 13) { if (t = pb(r), t !== null) { e.blockedOn = t, bb(e.priority, function () { Eb(r) }); return } } else if (t === 3 && r.stateNode.current.memoizedState.isDehydrated) { e.blockedOn = r.tag === 3 ? r.stateNode.containerInfo : null; return } } } e.blockedOn = null } function vf(e) { if (e.blockedOn !== null) return !1; for (var t = e.targetContainers; 0 < t.length;) { var r = rv(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent); if (r === null) { r = e.nativeEvent; var n = new r.constructor(r.type, r); qy = n, r.target.dispatchEvent(n), qy = null } else return t = Ou(r), t !== null && Fv(t), e.blockedOn = r, !1; t.shift() } return !0 } function tC(e, t, r) { vf(e) && r.delete(t) } function LD() { tv = !1, xi !== null && vf(xi) && (xi = null), Ti !== null && vf(Ti) && (Ti = null), Ei !== null && vf(Ei) && (Ei = null), hu.forEach(tC), gu.forEach(tC) } function Kc(e, t) { e.blockedOn === t && (e.blockedOn = null, tv || (tv = !0, Nr.unstable_scheduleCallback(Nr.unstable_NormalPriority, LD))) } function yu(e) { function t(o) { return Kc(o, e) } if (0 < nf.length) { Kc(nf[0], e); for (var r = 1; r < nf.length; r++) { var n = nf[r]; n.blockedOn === e && (n.blockedOn = null) } } for (xi !== null && Kc(xi, e), Ti !== null && Kc(Ti, e), Ei !== null && Kc(Ei, e), hu.forEach(t), gu.forEach(t), r = 0; r < gi.length; r++)n = gi[r], n.blockedOn === e && (n.blockedOn = null); for (; 0 < gi.length && (r = gi[0], r.blockedOn === null);)wb(r), r.blockedOn === null && gi.shift() } var Ka = Ao.ReactCurrentBatchConfig, Lf = !0; function _D(e, t, r, n) { var o = be, i = Ka.transition; Ka.transition = null; try { be = 1, zv(e, t, r, n) } finally { be = o, Ka.transition = i } } function DD(e, t, r, n) { var o = be, i = Ka.transition; Ka.transition = null; try { be = 4, zv(e, t, r, n) } finally { be = o, Ka.transition = i } } function zv(e, t, r, n) { if (Lf) { var o = rv(e, t, r, n); if (o === null) Ry(e, t, n, _f, r), eC(e, n); else if (PD(o, e, t, r, n)) n.stopPropagation(); else if (eC(e, n), t & 4 && -1 < OD.indexOf(e)) { for (; o !== null;) { var i = Ou(o); if (i !== null && Tb(i), i = rv(e, t, r, n), i === null && Ry(e, t, n, _f, r), i === o) break; o = i } o !== null && n.stopPropagation() } else Ry(e, t, n, null, r) } } var _f = null; function rv(e, t, r, n) { if (_f = null, e = Mv(n), e = ks(e), e !== null) if (t = Fs(e), t === null) e = null; else if (r = t.tag, r === 13) { if (e = pb(t), e !== null) return e; e = null } else if (r === 3) { if (t.stateNode.current.memoizedState.isDehydrated) return t.tag === 3 ? t.stateNode.containerInfo : null; e = null } else t !== e && (e = null); return _f = e, null } function Ib(e) { switch (e) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (ED()) { case Bv: return 1; case yb: return 4; case Of: case CD: return 16; case vb: return 536870912; default: return 16 }default: return 16 } } var vi = null, Hv = null, Sf = null; function Rb() { if (Sf) return Sf; var e, t = Hv, r = t.length, n, o = "value" in vi ? vi.value : vi.textContent, i = o.length; for (e = 0; e < r && t[e] === o[e]; e++); var s = r - e; for (n = 1; n <= s && t[r - n] === o[i - n]; n++); return Sf = o.slice(e, 1 < n ? 1 - n : void 0) } function xf(e) { var t = e.keyCode; return "charCode" in e ? (e = e.charCode, e === 0 && t === 13 && (e = 13)) : e = t, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0 } function of() { return !0 } function rC() { return !1 } function Or(e) { function t(r, n, o, i, s) { this._reactName = r, this._targetInst = o, this.type = n, this.nativeEvent = i, this.target = s, this.currentTarget = null; for (var a in e) e.hasOwnProperty(a) && (r = e[a], this[a] = r ? r(i) : i[a]); return this.isDefaultPrevented = (i.defaultPrevented != null ? i.defaultPrevented : i.returnValue === !1) ? of : rC, this.isPropagationStopped = rC, this } return Ge(t.prototype, { preventDefault: function () { this.defaultPrevented = !0; var r = this.nativeEvent; r && (r.preventDefault ? r.preventDefault() : typeof r.returnValue != "unknown" && (r.returnValue = !1), this.isDefaultPrevented = of) }, stopPropagation: function () { var r = this.nativeEvent; r && (r.stopPropagation ? r.stopPropagation() : typeof r.cancelBubble != "unknown" && (r.cancelBubble = !0), this.isPropagationStopped = of) }, persist: function () { }, isPersistent: of }), t } var nl = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (e) { return e.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, Wv = Or(nl), Nu = Ge({}, nl, { view: 0, detail: 0 }), MD = Or(Nu), Ty, Ey, Xc, Jf = Ge({}, Nu, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: jv, button: 0, buttons: 0, relatedTarget: function (e) { return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget }, movementX: function (e) { return "movementX" in e ? e.movementX : (e !== Xc && (Xc && e.type === "mousemove" ? (Ty = e.screenX - Xc.screenX, Ey = e.screenY - Xc.screenY) : Ey = Ty = 0, Xc = e), Ty) }, movementY: function (e) { return "movementY" in e ? e.movementY : Ey } }), nC = Or(Jf), BD = Ge({}, Jf, { dataTransfer: 0 }), VD = Or(BD), FD = Ge({}, Nu, { relatedTarget: 0 }), Cy = Or(FD), zD = Ge({}, nl, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), HD = Or(zD), WD = Ge({}, nl, { clipboardData: function (e) { return "clipboardData" in e ? e.clipboardData : window.clipboardData } }), jD = Or(WD), UD = Ge({}, nl, { data: 0 }), oC = Or(UD), GD = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, $D = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, KD = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function XD(e) { var t = this.nativeEvent; return t.getModifierState ? t.getModifierState(e) : (e = KD[e]) ? !!t[e] : !1 } function jv() { return XD } var YD = Ge({}, Nu, { key: function (e) { if (e.key) { var t = GD[e.key] || e.key; if (t !== "Unidentified") return t } return e.type === "keypress" ? (e = xf(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? $D[e.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: jv, charCode: function (e) { return e.type === "keypress" ? xf(e) : 0 }, keyCode: function (e) { return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 }, which: function (e) { return e.type === "keypress" ? xf(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 } }), qD = Or(YD), QD = Ge({}, Jf, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), iC = Or(QD), ZD = Ge({}, Nu, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: jv }), JD = Or(ZD), eM = Ge({}, nl, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), tM = Or(eM), rM = Ge({}, Jf, { deltaX: function (e) { return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0 }, deltaY: function (e) { return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), nM = Or(rM), oM = [9, 13, 27, 32], Uv = wo && "CompositionEvent" in window, iu = null; wo && "documentMode" in document && (iu = document.documentMode); var iM = wo && "TextEvent" in window && !iu, kb = wo && (!Uv || iu && 8 < iu && 11 >= iu), sC = String.fromCharCode(32), aC = !1; function Ab(e, t) { switch (e) { case "keyup": return oM.indexOf(t.keyCode) !== -1; case "keydown": return t.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function Nb(e) { return e = e.detail, typeof e == "object" && "data" in e ? e.data : null } var _a = !1; function sM(e, t) { switch (e) { case "compositionend": return Nb(t); case "keypress": return t.which !== 32 ? null : (aC = !0, sC); case "textInput": return e = t.data, e === sC && aC ? null : e; default: return null } } function aM(e, t) { if (_a) return e === "compositionend" || !Uv && Ab(e, t) ? (e = Rb(), Sf = Hv = vi = null, _a = !1, e) : null; switch (e) { case "paste": return null; case "keypress": if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) { if (t.char && 1 < t.char.length) return t.char; if (t.which) return String.fromCharCode(t.which) } return null; case "compositionend": return kb && t.locale !== "ko" ? null : t.data; default: return null } } var lM = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function lC(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t === "input" ? !!lM[e.type] : t === "textarea" } function Ob(e, t, r, n) { lb(n), t = Df(t, "onChange"), 0 < t.length && (r = new Wv("onChange", "change", null, r, n), e.push({ event: r, listeners: t })) } var su = null, vu = null; function cM(e) { Wb(e, 0) } function ep(e) { var t = Ba(e); if (tb(t)) return e } function uM(e, t) { if (e === "change") return t } var Pb = !1; wo && (wo ? (af = "oninput" in document, af || (by = document.createElement("div"), by.setAttribute("oninput", "return;"), af = typeof by.oninput == "function"), sf = af) : sf = !1, Pb = sf && (!document.documentMode || 9 < document.documentMode)); var sf, af, by; function cC() { su && (su.detachEvent("onpropertychange", Lb), vu = su = null) } function Lb(e) { if (e.propertyName === "value" && ep(vu)) { var t = []; Ob(t, vu, e, Mv(e)), fb(cM, t) } } function dM(e, t, r) { e === "focusin" ? (cC(), su = t, vu = r, su.attachEvent("onpropertychange", Lb)) : e === "focusout" && cC() } function fM(e) { if (e === "selectionchange" || e === "keyup" || e === "keydown") return ep(vu) } function pM(e, t) { if (e === "click") return ep(t) } function mM(e, t) { if (e === "input" || e === "change") return ep(t) } function hM(e, t) { return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t } var On = typeof Object.is == "function" ? Object.is : hM; function Su(e, t) { if (On(e, t)) return !0; if (typeof e != "object" || e === null || typeof t != "object" || t === null) return !1; var r = Object.keys(e), n = Object.keys(t); if (r.length !== n.length) return !1; for (n = 0; n < r.length; n++) { var o = r[n]; if (!Vy.call(t, o) || !On(e[o], t[o])) return !1 } return !0 } function uC(e) { for (; e && e.firstChild;)e = e.firstChild; return e } function dC(e, t) { var r = uC(e); e = 0; for (var n; r;) { if (r.nodeType === 3) { if (n = e + r.textContent.length, e <= t && n >= t) return { node: r, offset: t - e }; e = n } e: { for (; r;) { if (r.nextSibling) { r = r.nextSibling; break e } r = r.parentNode } r = void 0 } r = uC(r) } } function _b(e, t) { return e && t ? e === t ? !0 : e && e.nodeType === 3 ? !1 : t && t.nodeType === 3 ? _b(e, t.parentNode) : "contains" in e ? e.contains(t) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(t) & 16) : !1 : !1 } function Db() { for (var e = window, t = kf(); t instanceof e.HTMLIFrameElement;) { try { var r = typeof t.contentWindow.location.href == "string" } catch { r = !1 } if (r) e = t.contentWindow; else break; t = kf(e.document) } return t } function Gv(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true") } function gM(e) { var t = Db(), r = e.focusedElem, n = e.selectionRange; if (t !== r && r && r.ownerDocument && _b(r.ownerDocument.documentElement, r)) { if (n !== null && Gv(r)) { if (t = n.start, e = n.end, e === void 0 && (e = t), "selectionStart" in r) r.selectionStart = t, r.selectionEnd = Math.min(e, r.value.length); else if (e = (t = r.ownerDocument || document) && t.defaultView || window, e.getSelection) { e = e.getSelection(); var o = r.textContent.length, i = Math.min(n.start, o); n = n.end === void 0 ? i : Math.min(n.end, o), !e.extend && i > n && (o = n, n = i, i = o), o = dC(r, i); var s = dC(r, n); o && s && (e.rangeCount !== 1 || e.anchorNode !== o.node || e.anchorOffset !== o.offset || e.focusNode !== s.node || e.focusOffset !== s.offset) && (t = t.createRange(), t.setStart(o.node, o.offset), e.removeAllRanges(), i > n ? (e.addRange(t), e.extend(s.node, s.offset)) : (t.setEnd(s.node, s.offset), e.addRange(t))) } } for (t = [], e = r; e = e.parentNode;)e.nodeType === 1 && t.push({ element: e, left: e.scrollLeft, top: e.scrollTop }); for (typeof r.focus == "function" && r.focus(), r = 0; r < t.length; r++)e = t[r], e.element.scrollLeft = e.left, e.element.scrollTop = e.top } } var yM = wo && "documentMode" in document && 11 >= document.documentMode, Da = null, nv = null, au = null, ov = !1; function fC(e, t, r) { var n = r.window === r ? r.document : r.nodeType === 9 ? r : r.ownerDocument; ov || Da == null || Da !== kf(n) || (n = Da, "selectionStart" in n && Gv(n) ? n = { start: n.selectionStart, end: n.selectionEnd } : (n = (n.ownerDocument && n.ownerDocument.defaultView || window).getSelection(), n = { anchorNode: n.anchorNode, anchorOffset: n.anchorOffset, focusNode: n.focusNode, focusOffset: n.focusOffset }), au && Su(au, n) || (au = n, n = Df(nv, "onSelect"), 0 < n.length && (t = new Wv("onSelect", "select", null, t, r), e.push({ event: t, listeners: n }), t.target = Da))) } function lf(e, t) { var r = {}; return r[e.toLowerCase()] = t.toLowerCase(), r["Webkit" + e] = "webkit" + t, r["Moz" + e] = "moz" + t, r } var Ma = { animationend: lf("Animation", "AnimationEnd"), animationiteration: lf("Animation", "AnimationIteration"), animationstart: lf("Animation", "AnimationStart"), transitionend: lf("Transition", "TransitionEnd") }, wy = {}, Mb = {}; wo && (Mb = document.createElement("div").style, "AnimationEvent" in window || (delete Ma.animationend.animation, delete Ma.animationiteration.animation, delete Ma.animationstart.animation), "TransitionEvent" in window || delete Ma.transitionend.transition); function tp(e) { if (wy[e]) return wy[e]; if (!Ma[e]) return e; var t = Ma[e], r; for (r in t) if (t.hasOwnProperty(r) && r in Mb) return wy[e] = t[r]; return e } var Bb = tp("animationend"), Vb = tp("animationiteration"), Fb = tp("animationstart"), zb = tp("transitionend"), Hb = new Map, pC = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function Ni(e, t) { Hb.set(e, t), Vs(t, [e]) } for (cf = 0; cf < pC.length; cf++)uf = pC[cf], mC = uf.toLowerCase(), hC = uf[0].toUpperCase() + uf.slice(1), Ni(mC, "on" + hC); var uf, mC, hC, cf; Ni(Bb, "onAnimationEnd"); Ni(Vb, "onAnimationIteration"); Ni(Fb, "onAnimationStart"); Ni("dblclick", "onDoubleClick"); Ni("focusin", "onFocus"); Ni("focusout", "onBlur"); Ni(zb, "onTransitionEnd"); qa("onMouseEnter", ["mouseout", "mouseover"]); qa("onMouseLeave", ["mouseout", "mouseover"]); qa("onPointerEnter", ["pointerout", "pointerover"]); qa("onPointerLeave", ["pointerout", "pointerover"]); Vs("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")); Vs("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")); Vs("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]); Vs("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")); Vs("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")); Vs("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var ru = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), vM = new Set("cancel close invalid load scroll toggle".split(" ").concat(ru)); function gC(e, t, r) { var n = e.type || "unknown-event"; e.currentTarget = r, vD(n, t, void 0, e), e.currentTarget = null } function Wb(e, t) { t = (t & 4) !== 0; for (var r = 0; r < e.length; r++) { var n = e[r], o = n.event; n = n.listeners; e: { var i = void 0; if (t) for (var s = n.length - 1; 0 <= s; s--) { var a = n[s], l = a.instance, c = a.currentTarget; if (a = a.listener, l !== i && o.isPropagationStopped()) break e; gC(o, a, c), i = l } else for (s = 0; s < n.length; s++) { if (a = n[s], l = a.instance, c = a.currentTarget, a = a.listener, l !== i && o.isPropagationStopped()) break e; gC(o, a, c), i = l } } } if (Nf) throw e = Jy, Nf = !1, Jy = null, e } function De(e, t) { var r = t[cv]; r === void 0 && (r = t[cv] = new Set); var n = e + "__bubble"; r.has(n) || (jb(t, e, 2, !1), r.add(n)) } function Iy(e, t, r) { var n = 0; t && (n |= 4), jb(r, e, n, t) } var df = "_reactListening" + Math.random().toString(36).slice(2); function xu(e) { if (!e[df]) { e[df] = !0, qC.forEach(function (r) { r !== "selectionchange" && (vM.has(r) || Iy(r, !1, e), Iy(r, !0, e)) }); var t = e.nodeType === 9 ? e : e.ownerDocument; t === null || t[df] || (t[df] = !0, Iy("selectionchange", !1, t)) } } function jb(e, t, r, n) { switch (Ib(t)) { case 1: var o = _D; break; case 4: o = DD; break; default: o = zv }r = o.bind(null, t, r, e), o = void 0, !Zy || t !== "touchstart" && t !== "touchmove" && t !== "wheel" || (o = !0), n ? o !== void 0 ? e.addEventListener(t, r, { capture: !0, passive: o }) : e.addEventListener(t, r, !0) : o !== void 0 ? e.addEventListener(t, r, { passive: o }) : e.addEventListener(t, r, !1) } function Ry(e, t, r, n, o) { var i = n; if (!(t & 1) && !(t & 2) && n !== null) e: for (; ;) { if (n === null) return; var s = n.tag; if (s === 3 || s === 4) { var a = n.stateNode.containerInfo; if (a === o || a.nodeType === 8 && a.parentNode === o) break; if (s === 4) for (s = n.return; s !== null;) { var l = s.tag; if ((l === 3 || l === 4) && (l = s.stateNode.containerInfo, l === o || l.nodeType === 8 && l.parentNode === o)) return; s = s.return } for (; a !== null;) { if (s = ks(a), s === null) return; if (l = s.tag, l === 5 || l === 6) { n = i = s; continue e } a = a.parentNode } } n = n.return } fb(function () { var c = i, u = Mv(r), d = []; e: { var f = Hb.get(e); if (f !== void 0) { var p = Wv, y = e; switch (e) { case "keypress": if (xf(r) === 0) break e; case "keydown": case "keyup": p = qD; break; case "focusin": y = "focus", p = Cy; break; case "focusout": y = "blur", p = Cy; break; case "beforeblur": case "afterblur": p = Cy; break; case "click": if (r.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": p = nC; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": p = VD; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": p = JD; break; case Bb: case Vb: case Fb: p = HD; break; case zb: p = tM; break; case "scroll": p = MD; break; case "wheel": p = nM; break; case "copy": case "cut": case "paste": p = jD; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": p = iC }var g = (t & 4) !== 0, S = !g && e === "scroll", h = g ? f !== null ? f + "Capture" : null : f; g = []; for (var m = c, v; m !== null;) { v = m; var x = v.stateNode; if (v.tag === 5 && x !== null && (v = x, h !== null && (x = mu(m, h), x != null && g.push(Tu(m, x, v)))), S) break; m = m.return } 0 < g.length && (f = new p(f, y, null, r, u), d.push({ event: f, listeners: g })) } } if (!(t & 7)) { e: { if (f = e === "mouseover" || e === "pointerover", p = e === "mouseout" || e === "pointerout", f && r !== qy && (y = r.relatedTarget || r.fromElement) && (ks(y) || y[Io])) break e; if ((p || f) && (f = u.window === u ? u : (f = u.ownerDocument) ? f.defaultView || f.parentWindow : window, p ? (y = r.relatedTarget || r.toElement, p = c, y = y ? ks(y) : null, y !== null && (S = Fs(y), y !== S || y.tag !== 5 && y.tag !== 6) && (y = null)) : (p = null, y = c), p !== y)) { if (g = nC, x = "onMouseLeave", h = "onMouseEnter", m = "mouse", (e === "pointerout" || e === "pointerover") && (g = iC, x = "onPointerLeave", h = "onPointerEnter", m = "pointer"), S = p == null ? f : Ba(p), v = y == null ? f : Ba(y), f = new g(x, m + "leave", p, r, u), f.target = S, f.relatedTarget = v, x = null, ks(u) === c && (g = new g(h, m + "enter", y, r, u), g.target = v, g.relatedTarget = S, x = g), S = x, p && y) t: { for (g = p, h = y, m = 0, v = g; v; v = Oa(v))m++; for (v = 0, x = h; x; x = Oa(x))v++; for (; 0 < m - v;)g = Oa(g), m--; for (; 0 < v - m;)h = Oa(h), v--; for (; m--;) { if (g === h || h !== null && g === h.alternate) break t; g = Oa(g), h = Oa(h) } g = null } else g = null; p !== null && yC(d, f, p, g, !1), y !== null && S !== null && yC(d, S, y, g, !0) } } e: { if (f = c ? Ba(c) : window, p = f.nodeName && f.nodeName.toLowerCase(), p === "select" || p === "input" && f.type === "file") var C = uM; else if (lC(f)) if (Pb) C = mM; else { C = fM; var T = dM } else (p = f.nodeName) && p.toLowerCase() === "input" && (f.type === "checkbox" || f.type === "radio") && (C = pM); if (C && (C = C(e, c))) { Ob(d, C, r, u); break e } T && T(e, f, c), e === "focusout" && (T = f._wrapperState) && T.controlled && f.type === "number" && Gy(f, "number", f.value) } switch (T = c ? Ba(c) : window, e) { case "focusin": (lC(T) || T.contentEditable === "true") && (Da = T, nv = c, au = null); break; case "focusout": au = nv = Da = null; break; case "mousedown": ov = !0; break; case "contextmenu": case "mouseup": case "dragend": ov = !1, fC(d, r, u); break; case "selectionchange": if (yM) break; case "keydown": case "keyup": fC(d, r, u) }var E; if (Uv) e: { switch (e) { case "compositionstart": var w = "onCompositionStart"; break e; case "compositionend": w = "onCompositionEnd"; break e; case "compositionupdate": w = "onCompositionUpdate"; break e }w = void 0 } else _a ? Ab(e, r) && (w = "onCompositionEnd") : e === "keydown" && r.keyCode === 229 && (w = "onCompositionStart"); w && (kb && r.locale !== "ko" && (_a || w !== "onCompositionStart" ? w === "onCompositionEnd" && _a && (E = Rb()) : (vi = u, Hv = "value" in vi ? vi.value : vi.textContent, _a = !0)), T = Df(c, w), 0 < T.length && (w = new oC(w, e, null, r, u), d.push({ event: w, listeners: T }), E ? w.data = E : (E = Nb(r), E !== null && (w.data = E)))), (E = iM ? sM(e, r) : aM(e, r)) && (c = Df(c, "onBeforeInput"), 0 < c.length && (u = new oC("onBeforeInput", "beforeinput", null, r, u), d.push({ event: u, listeners: c }), u.data = E)) } Wb(d, t) }) } function Tu(e, t, r) { return { instance: e, listener: t, currentTarget: r } } function Df(e, t) { for (var r = t + "Capture", n = []; e !== null;) { var o = e, i = o.stateNode; o.tag === 5 && i !== null && (o = i, i = mu(e, r), i != null && n.unshift(Tu(e, i, o)), i = mu(e, t), i != null && n.push(Tu(e, i, o))), e = e.return } return n } function Oa(e) { if (e === null) return null; do e = e.return; while (e && e.tag !== 5); return e || null } function yC(e, t, r, n, o) { for (var i = t._reactName, s = []; r !== null && r !== n;) { var a = r, l = a.alternate, c = a.stateNode; if (l !== null && l === n) break; a.tag === 5 && c !== null && (a = c, o ? (l = mu(r, i), l != null && s.unshift(Tu(r, l, a))) : o || (l = mu(r, i), l != null && s.push(Tu(r, l, a)))), r = r.return } s.length !== 0 && e.push({ event: t, listeners: s }) } var SM = /\r\n?/g, xM = /\u0000|\uFFFD/g; function vC(e) {
    return (typeof e == "string" ? e : "" + e).replace(SM, `
`).replace(xM, "")
  } function ff(e, t, r) { if (t = vC(t), vC(e) !== t && r) throw Error(_(425)) } function Mf() { } var iv = null, sv = null; function av(e, t) { return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null } var lv = typeof setTimeout == "function" ? setTimeout : void 0, TM = typeof clearTimeout == "function" ? clearTimeout : void 0, SC = typeof Promise == "function" ? Promise : void 0, EM = typeof queueMicrotask == "function" ? queueMicrotask : typeof SC < "u" ? function (e) { return SC.resolve(null).then(e).catch(CM) } : lv; function CM(e) { setTimeout(function () { throw e }) } function ky(e, t) { var r = t, n = 0; do { var o = r.nextSibling; if (e.removeChild(r), o && o.nodeType === 8) if (r = o.data, r === "/$") { if (n === 0) { e.removeChild(o), yu(t); return } n-- } else r !== "$" && r !== "$?" && r !== "$!" || n++; r = o } while (r); yu(t) } function Ci(e) { for (; e != null; e = e.nextSibling) { var t = e.nodeType; if (t === 1 || t === 3) break; if (t === 8) { if (t = e.data, t === "$" || t === "$!" || t === "$?") break; if (t === "/$") return null } } return e } function xC(e) { e = e.previousSibling; for (var t = 0; e;) { if (e.nodeType === 8) { var r = e.data; if (r === "$" || r === "$!" || r === "$?") { if (t === 0) return e; t-- } else r === "/$" && t++ } e = e.previousSibling } return null } var ol = Math.random().toString(36).slice(2), Xn = "__reactFiber$" + ol, Eu = "__reactProps$" + ol, Io = "__reactContainer$" + ol, cv = "__reactEvents$" + ol, bM = "__reactListeners$" + ol, wM = "__reactHandles$" + ol; function ks(e) { var t = e[Xn]; if (t) return t; for (var r = e.parentNode; r;) { if (t = r[Io] || r[Xn]) { if (r = t.alternate, t.child !== null || r !== null && r.child !== null) for (e = xC(e); e !== null;) { if (r = e[Xn]) return r; e = xC(e) } return t } e = r, r = e.parentNode } return null } function Ou(e) { return e = e[Xn] || e[Io], !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e } function Ba(e) { if (e.tag === 5 || e.tag === 6) return e.stateNode; throw Error(_(33)) } function rp(e) { return e[Eu] || null } var uv = [], Va = -1; function Oi(e) { return { current: e } } function Me(e) { 0 > Va || (e.current = uv[Va], uv[Va] = null, Va--) } function Le(e, t) { Va++, uv[Va] = e.current, e.current = t } var Ai = {}, Vt = Oi(Ai), cr = Oi(!1), Ls = Ai; function Qa(e, t) { var r = e.type.contextTypes; if (!r) return Ai; var n = e.stateNode; if (n && n.__reactInternalMemoizedUnmaskedChildContext === t) return n.__reactInternalMemoizedMaskedChildContext; var o = {}, i; for (i in r) o[i] = t[i]; return n && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = o), o } function ur(e) { return e = e.childContextTypes, e != null } function Bf() { Me(cr), Me(Vt) } function TC(e, t, r) { if (Vt.current !== Ai) throw Error(_(168)); Le(Vt, t), Le(cr, r) } function Ub(e, t, r) { var n = e.stateNode; if (t = t.childContextTypes, typeof n.getChildContext != "function") return r; n = n.getChildContext(); for (var o in n) if (!(o in t)) throw Error(_(108, dD(e) || "Unknown", o)); return Ge({}, r, n) } function Vf(e) { return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || Ai, Ls = Vt.current, Le(Vt, e), Le(cr, cr.current), !0 } function EC(e, t, r) { var n = e.stateNode; if (!n) throw Error(_(169)); r ? (e = Ub(e, t, Ls), n.__reactInternalMemoizedMergedChildContext = e, Me(cr), Me(Vt), Le(Vt, e)) : Me(cr), Le(cr, r) } var To = null, np = !1, Ay = !1; function Gb(e) { To === null ? To = [e] : To.push(e) } function IM(e) { np = !0, Gb(e) } function Pi() { if (!Ay && To !== null) { Ay = !0; var e = 0, t = be; try { var r = To; for (be = 1; e < r.length; e++) { var n = r[e]; do n = n(!0); while (n !== null) } To = null, np = !1 } catch (o) { throw To !== null && (To = To.slice(e + 1)), gb(Bv, Pi), o } finally { be = t, Ay = !1 } } return null } var Fa = [], za = 0, Ff = null, zf = 0, Gr = [], $r = 0, _s = null, Eo = 1, Co = ""; function Is(e, t) { Fa[za++] = zf, Fa[za++] = Ff, Ff = e, zf = t } function $b(e, t, r) { Gr[$r++] = Eo, Gr[$r++] = Co, Gr[$r++] = _s, _s = e; var n = Eo; e = Co; var o = 32 - An(n) - 1; n &= ~(1 << o), r += 1; var i = 32 - An(t) + o; if (30 < i) { var s = o - o % 5; i = (n & (1 << s) - 1).toString(32), n >>= s, o -= s, Eo = 1 << 32 - An(t) + o | r << o | n, Co = i + e } else Eo = 1 << i | r << o | n, Co = e } function $v(e) { e.return !== null && (Is(e, 1), $b(e, 1, 0)) } function Kv(e) { for (; e === Ff;)Ff = Fa[--za], Fa[za] = null, zf = Fa[--za], Fa[za] = null; for (; e === _s;)_s = Gr[--$r], Gr[$r] = null, Co = Gr[--$r], Gr[$r] = null, Eo = Gr[--$r], Gr[$r] = null } var Ar = null, kr = null, Fe = !1, kn = null; function Kb(e, t) { var r = Kr(5, null, null, 0); r.elementType = "DELETED", r.stateNode = t, r.return = e, t = e.deletions, t === null ? (e.deletions = [r], e.flags |= 16) : t.push(r) } function CC(e, t) { switch (e.tag) { case 5: var r = e.type; return t = t.nodeType !== 1 || r.toLowerCase() !== t.nodeName.toLowerCase() ? null : t, t !== null ? (e.stateNode = t, Ar = e, kr = Ci(t.firstChild), !0) : !1; case 6: return t = e.pendingProps === "" || t.nodeType !== 3 ? null : t, t !== null ? (e.stateNode = t, Ar = e, kr = null, !0) : !1; case 13: return t = t.nodeType !== 8 ? null : t, t !== null ? (r = _s !== null ? { id: Eo, overflow: Co } : null, e.memoizedState = { dehydrated: t, treeContext: r, retryLane: 1073741824 }, r = Kr(18, null, null, 0), r.stateNode = t, r.return = e, e.child = r, Ar = e, kr = null, !0) : !1; default: return !1 } } function dv(e) { return (e.mode & 1) !== 0 && (e.flags & 128) === 0 } function fv(e) { if (Fe) { var t = kr; if (t) { var r = t; if (!CC(e, t)) { if (dv(e)) throw Error(_(418)); t = Ci(r.nextSibling); var n = Ar; t && CC(e, t) ? Kb(n, r) : (e.flags = e.flags & -4097 | 2, Fe = !1, Ar = e) } } else { if (dv(e)) throw Error(_(418)); e.flags = e.flags & -4097 | 2, Fe = !1, Ar = e } } } function bC(e) { for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13;)e = e.return; Ar = e } function pf(e) { if (e !== Ar) return !1; if (!Fe) return bC(e), Fe = !0, !1; var t; if ((t = e.tag !== 3) && !(t = e.tag !== 5) && (t = e.type, t = t !== "head" && t !== "body" && !av(e.type, e.memoizedProps)), t && (t = kr)) { if (dv(e)) throw Xb(), Error(_(418)); for (; t;)Kb(e, t), t = Ci(t.nextSibling) } if (bC(e), e.tag === 13) { if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(_(317)); e: { for (e = e.nextSibling, t = 0; e;) { if (e.nodeType === 8) { var r = e.data; if (r === "/$") { if (t === 0) { kr = Ci(e.nextSibling); break e } t-- } else r !== "$" && r !== "$!" && r !== "$?" || t++ } e = e.nextSibling } kr = null } } else kr = Ar ? Ci(e.stateNode.nextSibling) : null; return !0 } function Xb() { for (var e = kr; e;)e = Ci(e.nextSibling) } function Za() { kr = Ar = null, Fe = !1 } function Xv(e) { kn === null ? kn = [e] : kn.push(e) } var RM = Ao.ReactCurrentBatchConfig; function Yc(e, t, r) { if (e = r.ref, e !== null && typeof e != "function" && typeof e != "object") { if (r._owner) { if (r = r._owner, r) { if (r.tag !== 1) throw Error(_(309)); var n = r.stateNode } if (!n) throw Error(_(147, e)); var o = n, i = "" + e; return t !== null && t.ref !== null && typeof t.ref == "function" && t.ref._stringRef === i ? t.ref : (t = function (s) { var a = o.refs; s === null ? delete a[i] : a[i] = s }, t._stringRef = i, t) } if (typeof e != "string") throw Error(_(284)); if (!r._owner) throw Error(_(290, e)) } return e } function mf(e, t) { throw e = Object.prototype.toString.call(t), Error(_(31, e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e)) } function wC(e) { var t = e._init; return t(e._payload) } function Yb(e) { function t(h, m) { if (e) { var v = h.deletions; v === null ? (h.deletions = [m], h.flags |= 16) : v.push(m) } } function r(h, m) { if (!e) return null; for (; m !== null;)t(h, m), m = m.sibling; return null } function n(h, m) { for (h = new Map; m !== null;)m.key !== null ? h.set(m.key, m) : h.set(m.index, m), m = m.sibling; return h } function o(h, m) { return h = Ri(h, m), h.index = 0, h.sibling = null, h } function i(h, m, v) { return h.index = v, e ? (v = h.alternate, v !== null ? (v = v.index, v < m ? (h.flags |= 2, m) : v) : (h.flags |= 2, m)) : (h.flags |= 1048576, m) } function s(h) { return e && h.alternate === null && (h.flags |= 2), h } function a(h, m, v, x) { return m === null || m.tag !== 6 ? (m = My(v, h.mode, x), m.return = h, m) : (m = o(m, v), m.return = h, m) } function l(h, m, v, x) { var C = v.type; return C === La ? u(h, m, v.props.children, x, v.key) : m !== null && (m.elementType === C || typeof C == "object" && C !== null && C.$$typeof === mi && wC(C) === m.type) ? (x = o(m, v.props), x.ref = Yc(h, m, v), x.return = h, x) : (x = Rf(v.type, v.key, v.props, null, h.mode, x), x.ref = Yc(h, m, v), x.return = h, x) } function c(h, m, v, x) { return m === null || m.tag !== 4 || m.stateNode.containerInfo !== v.containerInfo || m.stateNode.implementation !== v.implementation ? (m = By(v, h.mode, x), m.return = h, m) : (m = o(m, v.children || []), m.return = h, m) } function u(h, m, v, x, C) { return m === null || m.tag !== 7 ? (m = Ps(v, h.mode, x, C), m.return = h, m) : (m = o(m, v), m.return = h, m) } function d(h, m, v) { if (typeof m == "string" && m !== "" || typeof m == "number") return m = My("" + m, h.mode, v), m.return = h, m; if (typeof m == "object" && m !== null) { switch (m.$$typeof) { case Zd: return v = Rf(m.type, m.key, m.props, null, h.mode, v), v.ref = Yc(h, null, m), v.return = h, v; case Pa: return m = By(m, h.mode, v), m.return = h, m; case mi: var x = m._init; return d(h, x(m._payload), v) }if (eu(m) || Gc(m)) return m = Ps(m, h.mode, v, null), m.return = h, m; mf(h, m) } return null } function f(h, m, v, x) { var C = m !== null ? m.key : null; if (typeof v == "string" && v !== "" || typeof v == "number") return C !== null ? null : a(h, m, "" + v, x); if (typeof v == "object" && v !== null) { switch (v.$$typeof) { case Zd: return v.key === C ? l(h, m, v, x) : null; case Pa: return v.key === C ? c(h, m, v, x) : null; case mi: return C = v._init, f(h, m, C(v._payload), x) }if (eu(v) || Gc(v)) return C !== null ? null : u(h, m, v, x, null); mf(h, v) } return null } function p(h, m, v, x, C) { if (typeof x == "string" && x !== "" || typeof x == "number") return h = h.get(v) || null, a(m, h, "" + x, C); if (typeof x == "object" && x !== null) { switch (x.$$typeof) { case Zd: return h = h.get(x.key === null ? v : x.key) || null, l(m, h, x, C); case Pa: return h = h.get(x.key === null ? v : x.key) || null, c(m, h, x, C); case mi: var T = x._init; return p(h, m, v, T(x._payload), C) }if (eu(x) || Gc(x)) return h = h.get(v) || null, u(m, h, x, C, null); mf(m, x) } return null } function y(h, m, v, x) { for (var C = null, T = null, E = m, w = m = 0, k = null; E !== null && w < v.length; w++) { E.index > w ? (k = E, E = null) : k = E.sibling; var R = f(h, E, v[w], x); if (R === null) { E === null && (E = k); break } e && E && R.alternate === null && t(h, E), m = i(R, m, w), T === null ? C = R : T.sibling = R, T = R, E = k } if (w === v.length) return r(h, E), Fe && Is(h, w), C; if (E === null) { for (; w < v.length; w++)E = d(h, v[w], x), E !== null && (m = i(E, m, w), T === null ? C = E : T.sibling = E, T = E); return Fe && Is(h, w), C } for (E = n(h, E); w < v.length; w++)k = p(E, h, w, v[w], x), k !== null && (e && k.alternate !== null && E.delete(k.key === null ? w : k.key), m = i(k, m, w), T === null ? C = k : T.sibling = k, T = k); return e && E.forEach(function (A) { return t(h, A) }), Fe && Is(h, w), C } function g(h, m, v, x) { var C = Gc(v); if (typeof C != "function") throw Error(_(150)); if (v = C.call(v), v == null) throw Error(_(151)); for (var T = C = null, E = m, w = m = 0, k = null, R = v.next(); E !== null && !R.done; w++, R = v.next()) { E.index > w ? (k = E, E = null) : k = E.sibling; var A = f(h, E, R.value, x); if (A === null) { E === null && (E = k); break } e && E && A.alternate === null && t(h, E), m = i(A, m, w), T === null ? C = A : T.sibling = A, T = A, E = k } if (R.done) return r(h, E), Fe && Is(h, w), C; if (E === null) { for (; !R.done; w++, R = v.next())R = d(h, R.value, x), R !== null && (m = i(R, m, w), T === null ? C = R : T.sibling = R, T = R); return Fe && Is(h, w), C } for (E = n(h, E); !R.done; w++, R = v.next())R = p(E, h, w, R.value, x), R !== null && (e && R.alternate !== null && E.delete(R.key === null ? w : R.key), m = i(R, m, w), T === null ? C = R : T.sibling = R, T = R); return e && E.forEach(function (N) { return t(h, N) }), Fe && Is(h, w), C } function S(h, m, v, x) { if (typeof v == "object" && v !== null && v.type === La && v.key === null && (v = v.props.children), typeof v == "object" && v !== null) { switch (v.$$typeof) { case Zd: e: { for (var C = v.key, T = m; T !== null;) { if (T.key === C) { if (C = v.type, C === La) { if (T.tag === 7) { r(h, T.sibling), m = o(T, v.props.children), m.return = h, h = m; break e } } else if (T.elementType === C || typeof C == "object" && C !== null && C.$$typeof === mi && wC(C) === T.type) { r(h, T.sibling), m = o(T, v.props), m.ref = Yc(h, T, v), m.return = h, h = m; break e } r(h, T); break } else t(h, T); T = T.sibling } v.type === La ? (m = Ps(v.props.children, h.mode, x, v.key), m.return = h, h = m) : (x = Rf(v.type, v.key, v.props, null, h.mode, x), x.ref = Yc(h, m, v), x.return = h, h = x) } return s(h); case Pa: e: { for (T = v.key; m !== null;) { if (m.key === T) if (m.tag === 4 && m.stateNode.containerInfo === v.containerInfo && m.stateNode.implementation === v.implementation) { r(h, m.sibling), m = o(m, v.children || []), m.return = h, h = m; break e } else { r(h, m); break } else t(h, m); m = m.sibling } m = By(v, h.mode, x), m.return = h, h = m } return s(h); case mi: return T = v._init, S(h, m, T(v._payload), x) }if (eu(v)) return y(h, m, v, x); if (Gc(v)) return g(h, m, v, x); mf(h, v) } return typeof v == "string" && v !== "" || typeof v == "number" ? (v = "" + v, m !== null && m.tag === 6 ? (r(h, m.sibling), m = o(m, v), m.return = h, h = m) : (r(h, m), m = My(v, h.mode, x), m.return = h, h = m), s(h)) : r(h, m) } return S } var Ja = Yb(!0), qb = Yb(!1), Hf = Oi(null), Wf = null, Ha = null, Yv = null; function qv() { Yv = Ha = Wf = null } function Qv(e) { var t = Hf.current; Me(Hf), e._currentValue = t } function pv(e, t, r) { for (; e !== null;) { var n = e.alternate; if ((e.childLanes & t) !== t ? (e.childLanes |= t, n !== null && (n.childLanes |= t)) : n !== null && (n.childLanes & t) !== t && (n.childLanes |= t), e === r) break; e = e.return } } function Xa(e, t) { Wf = e, Yv = Ha = null, e = e.dependencies, e !== null && e.firstContext !== null && (e.lanes & t && (lr = !0), e.firstContext = null) } function Yr(e) { var t = e._currentValue; if (Yv !== e) if (e = { context: e, memoizedValue: t, next: null }, Ha === null) { if (Wf === null) throw Error(_(308)); Ha = e, Wf.dependencies = { lanes: 0, firstContext: e } } else Ha = Ha.next = e; return t } var As = null; function Zv(e) { As === null ? As = [e] : As.push(e) } function Qb(e, t, r, n) { var o = t.interleaved; return o === null ? (r.next = r, Zv(t)) : (r.next = o.next, o.next = r), t.interleaved = r, Ro(e, n) } function Ro(e, t) { e.lanes |= t; var r = e.alternate; for (r !== null && (r.lanes |= t), r = e, e = e.return; e !== null;)e.childLanes |= t, r = e.alternate, r !== null && (r.childLanes |= t), r = e, e = e.return; return r.tag === 3 ? r.stateNode : null } var hi = !1; function Jv(e) { e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function Zb(e, t) { e = e.updateQueue, t.updateQueue === e && (t.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects }) } function bo(e, t) { return { eventTime: e, lane: t, tag: 0, payload: null, callback: null, next: null } } function bi(e, t, r) { var n = e.updateQueue; if (n === null) return null; if (n = n.shared, pe & 2) { var o = n.pending; return o === null ? t.next = t : (t.next = o.next, o.next = t), n.pending = t, Ro(e, r) } return o = n.interleaved, o === null ? (t.next = t, Zv(n)) : (t.next = o.next, o.next = t), n.interleaved = t, Ro(e, r) } function Tf(e, t, r) { if (t = t.updateQueue, t !== null && (t = t.shared, (r & 4194240) !== 0)) { var n = t.lanes; n &= e.pendingLanes, r |= n, t.lanes = r, Vv(e, r) } } function IC(e, t) { var r = e.updateQueue, n = e.alternate; if (n !== null && (n = n.updateQueue, r === n)) { var o = null, i = null; if (r = r.firstBaseUpdate, r !== null) { do { var s = { eventTime: r.eventTime, lane: r.lane, tag: r.tag, payload: r.payload, callback: r.callback, next: null }; i === null ? o = i = s : i = i.next = s, r = r.next } while (r !== null); i === null ? o = i = t : i = i.next = t } else o = i = t; r = { baseState: n.baseState, firstBaseUpdate: o, lastBaseUpdate: i, shared: n.shared, effects: n.effects }, e.updateQueue = r; return } e = r.lastBaseUpdate, e === null ? r.firstBaseUpdate = t : e.next = t, r.lastBaseUpdate = t } function jf(e, t, r, n) { var o = e.updateQueue; hi = !1; var i = o.firstBaseUpdate, s = o.lastBaseUpdate, a = o.shared.pending; if (a !== null) { o.shared.pending = null; var l = a, c = l.next; l.next = null, s === null ? i = c : s.next = c, s = l; var u = e.alternate; u !== null && (u = u.updateQueue, a = u.lastBaseUpdate, a !== s && (a === null ? u.firstBaseUpdate = c : a.next = c, u.lastBaseUpdate = l)) } if (i !== null) { var d = o.baseState; s = 0, u = c = l = null, a = i; do { var f = a.lane, p = a.eventTime; if ((n & f) === f) { u !== null && (u = u.next = { eventTime: p, lane: 0, tag: a.tag, payload: a.payload, callback: a.callback, next: null }); e: { var y = e, g = a; switch (f = t, p = r, g.tag) { case 1: if (y = g.payload, typeof y == "function") { d = y.call(p, d, f); break e } d = y; break e; case 3: y.flags = y.flags & -65537 | 128; case 0: if (y = g.payload, f = typeof y == "function" ? y.call(p, d, f) : y, f == null) break e; d = Ge({}, d, f); break e; case 2: hi = !0 } } a.callback !== null && a.lane !== 0 && (e.flags |= 64, f = o.effects, f === null ? o.effects = [a] : f.push(a)) } else p = { eventTime: p, lane: f, tag: a.tag, payload: a.payload, callback: a.callback, next: null }, u === null ? (c = u = p, l = d) : u = u.next = p, s |= f; if (a = a.next, a === null) { if (a = o.shared.pending, a === null) break; f = a, a = f.next, f.next = null, o.lastBaseUpdate = f, o.shared.pending = null } } while (1); if (u === null && (l = d), o.baseState = l, o.firstBaseUpdate = c, o.lastBaseUpdate = u, t = o.shared.interleaved, t !== null) { o = t; do s |= o.lane, o = o.next; while (o !== t) } else i === null && (o.shared.lanes = 0); Ms |= s, e.lanes = s, e.memoizedState = d } } function RC(e, t, r) { if (e = t.effects, t.effects = null, e !== null) for (t = 0; t < e.length; t++) { var n = e[t], o = n.callback; if (o !== null) { if (n.callback = null, n = r, typeof o != "function") throw Error(_(191, o)); o.call(n) } } } var Pu = {}, qn = Oi(Pu), Cu = Oi(Pu), bu = Oi(Pu); function Ns(e) { if (e === Pu) throw Error(_(174)); return e } function eS(e, t) { switch (Le(bu, t), Le(Cu, e), Le(qn, Pu), e = t.nodeType, e) { case 9: case 11: t = (t = t.documentElement) ? t.namespaceURI : Ky(null, ""); break; default: e = e === 8 ? t.parentNode : t, t = e.namespaceURI || null, e = e.tagName, t = Ky(t, e) }Me(qn), Le(qn, t) } function el() { Me(qn), Me(Cu), Me(bu) } function Jb(e) { Ns(bu.current); var t = Ns(qn.current), r = Ky(t, e.type); t !== r && (Le(Cu, e), Le(qn, r)) } function tS(e) { Cu.current === e && (Me(qn), Me(Cu)) } var je = Oi(0); function Uf(e) { for (var t = e; t !== null;) { if (t.tag === 13) { var r = t.memoizedState; if (r !== null && (r = r.dehydrated, r === null || r.data === "$?" || r.data === "$!")) return t } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) { if (t.flags & 128) return t } else if (t.child !== null) { t.child.return = t, t = t.child; continue } if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return null; t = t.return } t.sibling.return = t.return, t = t.sibling } return null } var Ny = []; function rS() { for (var e = 0; e < Ny.length; e++)Ny[e]._workInProgressVersionPrimary = null; Ny.length = 0 } var Ef = Ao.ReactCurrentDispatcher, Oy = Ao.ReactCurrentBatchConfig, Ds = 0, Ue = null, st = null, yt = null, Gf = !1, lu = !1, wu = 0, kM = 0; function Dt() { throw Error(_(321)) } function nS(e, t) { if (t === null) return !1; for (var r = 0; r < t.length && r < e.length; r++)if (!On(e[r], t[r])) return !1; return !0 } function oS(e, t, r, n, o, i) { if (Ds = i, Ue = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, Ef.current = e === null || e.memoizedState === null ? PM : LM, e = r(n, o), lu) { i = 0; do { if (lu = !1, wu = 0, 25 <= i) throw Error(_(301)); i += 1, yt = st = null, t.updateQueue = null, Ef.current = _M, e = r(n, o) } while (lu) } if (Ef.current = $f, t = st !== null && st.next !== null, Ds = 0, yt = st = Ue = null, Gf = !1, t) throw Error(_(300)); return e } function iS() { var e = wu !== 0; return wu = 0, e } function Kn() { var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return yt === null ? Ue.memoizedState = yt = e : yt = yt.next = e, yt } function qr() { if (st === null) { var e = Ue.alternate; e = e !== null ? e.memoizedState : null } else e = st.next; var t = yt === null ? Ue.memoizedState : yt.next; if (t !== null) yt = t, st = e; else { if (e === null) throw Error(_(310)); st = e, e = { memoizedState: st.memoizedState, baseState: st.baseState, baseQueue: st.baseQueue, queue: st.queue, next: null }, yt === null ? Ue.memoizedState = yt = e : yt = yt.next = e } return yt } function Iu(e, t) { return typeof t == "function" ? t(e) : t } function Py(e) { var t = qr(), r = t.queue; if (r === null) throw Error(_(311)); r.lastRenderedReducer = e; var n = st, o = n.baseQueue, i = r.pending; if (i !== null) { if (o !== null) { var s = o.next; o.next = i.next, i.next = s } n.baseQueue = o = i, r.pending = null } if (o !== null) { i = o.next, n = n.baseState; var a = s = null, l = null, c = i; do { var u = c.lane; if ((Ds & u) === u) l !== null && (l = l.next = { lane: 0, action: c.action, hasEagerState: c.hasEagerState, eagerState: c.eagerState, next: null }), n = c.hasEagerState ? c.eagerState : e(n, c.action); else { var d = { lane: u, action: c.action, hasEagerState: c.hasEagerState, eagerState: c.eagerState, next: null }; l === null ? (a = l = d, s = n) : l = l.next = d, Ue.lanes |= u, Ms |= u } c = c.next } while (c !== null && c !== i); l === null ? s = n : l.next = a, On(n, t.memoizedState) || (lr = !0), t.memoizedState = n, t.baseState = s, t.baseQueue = l, r.lastRenderedState = n } if (e = r.interleaved, e !== null) { o = e; do i = o.lane, Ue.lanes |= i, Ms |= i, o = o.next; while (o !== e) } else o === null && (r.lanes = 0); return [t.memoizedState, r.dispatch] } function Ly(e) { var t = qr(), r = t.queue; if (r === null) throw Error(_(311)); r.lastRenderedReducer = e; var n = r.dispatch, o = r.pending, i = t.memoizedState; if (o !== null) { r.pending = null; var s = o = o.next; do i = e(i, s.action), s = s.next; while (s !== o); On(i, t.memoizedState) || (lr = !0), t.memoizedState = i, t.baseQueue === null && (t.baseState = i), r.lastRenderedState = i } return [i, n] } function e1() { } function t1(e, t) { var r = Ue, n = qr(), o = t(), i = !On(n.memoizedState, o); if (i && (n.memoizedState = o, lr = !0), n = n.queue, sS(o1.bind(null, r, n, e), [e]), n.getSnapshot !== t || i || yt !== null && yt.memoizedState.tag & 1) { if (r.flags |= 2048, Ru(9, n1.bind(null, r, n, o, t), void 0, null), vt === null) throw Error(_(349)); Ds & 30 || r1(r, t, o) } return o } function r1(e, t, r) { e.flags |= 16384, e = { getSnapshot: t, value: r }, t = Ue.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, Ue.updateQueue = t, t.stores = [e]) : (r = t.stores, r === null ? t.stores = [e] : r.push(e)) } function n1(e, t, r, n) { t.value = r, t.getSnapshot = n, i1(t) && s1(e) } function o1(e, t, r) { return r(function () { i1(t) && s1(e) }) } function i1(e) { var t = e.getSnapshot; e = e.value; try { var r = t(); return !On(e, r) } catch { return !0 } } function s1(e) { var t = Ro(e, 1); t !== null && Nn(t, e, 1, -1) } function kC(e) { var t = Kn(); return typeof e == "function" && (e = e()), t.memoizedState = t.baseState = e, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Iu, lastRenderedState: e }, t.queue = e, e = e.dispatch = OM.bind(null, Ue, e), [t.memoizedState, e] } function Ru(e, t, r, n) { return e = { tag: e, create: t, destroy: r, deps: n, next: null }, t = Ue.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, Ue.updateQueue = t, t.lastEffect = e.next = e) : (r = t.lastEffect, r === null ? t.lastEffect = e.next = e : (n = r.next, r.next = e, e.next = n, t.lastEffect = e)), e } function a1() { return qr().memoizedState } function Cf(e, t, r, n) { var o = Kn(); Ue.flags |= e, o.memoizedState = Ru(1 | t, r, void 0, n === void 0 ? null : n) } function op(e, t, r, n) { var o = qr(); n = n === void 0 ? null : n; var i = void 0; if (st !== null) { var s = st.memoizedState; if (i = s.destroy, n !== null && nS(n, s.deps)) { o.memoizedState = Ru(t, r, i, n); return } } Ue.flags |= e, o.memoizedState = Ru(1 | t, r, i, n) } function AC(e, t) { return Cf(8390656, 8, e, t) } function sS(e, t) { return op(2048, 8, e, t) } function l1(e, t) { return op(4, 2, e, t) } function c1(e, t) { return op(4, 4, e, t) } function u1(e, t) { if (typeof t == "function") return e = e(), t(e), function () { t(null) }; if (t != null) return e = e(), t.current = e, function () { t.current = null } } function d1(e, t, r) { return r = r != null ? r.concat([e]) : null, op(4, 4, u1.bind(null, t, e), r) } function aS() { } function f1(e, t) { var r = qr(); t = t === void 0 ? null : t; var n = r.memoizedState; return n !== null && t !== null && nS(t, n[1]) ? n[0] : (r.memoizedState = [e, t], e) } function p1(e, t) { var r = qr(); t = t === void 0 ? null : t; var n = r.memoizedState; return n !== null && t !== null && nS(t, n[1]) ? n[0] : (e = e(), r.memoizedState = [e, t], e) } function m1(e, t, r) { return Ds & 21 ? (On(r, t) || (r = Sb(), Ue.lanes |= r, Ms |= r, e.baseState = !0), t) : (e.baseState && (e.baseState = !1, lr = !0), e.memoizedState = r) } function AM(e, t) { var r = be; be = r !== 0 && 4 > r ? r : 4, e(!0); var n = Oy.transition; Oy.transition = {}; try { e(!1), t() } finally { be = r, Oy.transition = n } } function h1() { return qr().memoizedState } function NM(e, t, r) { var n = Ii(e); if (r = { lane: n, action: r, hasEagerState: !1, eagerState: null, next: null }, g1(e)) y1(t, r); else if (r = Qb(e, t, r, n), r !== null) { var o = Zt(); Nn(r, e, n, o), v1(r, t, n) } } function OM(e, t, r) { var n = Ii(e), o = { lane: n, action: r, hasEagerState: !1, eagerState: null, next: null }; if (g1(e)) y1(t, o); else { var i = e.alternate; if (e.lanes === 0 && (i === null || i.lanes === 0) && (i = t.lastRenderedReducer, i !== null)) try { var s = t.lastRenderedState, a = i(s, r); if (o.hasEagerState = !0, o.eagerState = a, On(a, s)) { var l = t.interleaved; l === null ? (o.next = o, Zv(t)) : (o.next = l.next, l.next = o), t.interleaved = o; return } } catch { } finally { } r = Qb(e, t, o, n), r !== null && (o = Zt(), Nn(r, e, n, o), v1(r, t, n)) } } function g1(e) { var t = e.alternate; return e === Ue || t !== null && t === Ue } function y1(e, t) { lu = Gf = !0; var r = e.pending; r === null ? t.next = t : (t.next = r.next, r.next = t), e.pending = t } function v1(e, t, r) { if (r & 4194240) { var n = t.lanes; n &= e.pendingLanes, r |= n, t.lanes = r, Vv(e, r) } } var $f = { readContext: Yr, useCallback: Dt, useContext: Dt, useEffect: Dt, useImperativeHandle: Dt, useInsertionEffect: Dt, useLayoutEffect: Dt, useMemo: Dt, useReducer: Dt, useRef: Dt, useState: Dt, useDebugValue: Dt, useDeferredValue: Dt, useTransition: Dt, useMutableSource: Dt, useSyncExternalStore: Dt, useId: Dt, unstable_isNewReconciler: !1 }, PM = { readContext: Yr, useCallback: function (e, t) { return Kn().memoizedState = [e, t === void 0 ? null : t], e }, useContext: Yr, useEffect: AC, useImperativeHandle: function (e, t, r) { return r = r != null ? r.concat([e]) : null, Cf(4194308, 4, u1.bind(null, t, e), r) }, useLayoutEffect: function (e, t) { return Cf(4194308, 4, e, t) }, useInsertionEffect: function (e, t) { return Cf(4, 2, e, t) }, useMemo: function (e, t) { var r = Kn(); return t = t === void 0 ? null : t, e = e(), r.memoizedState = [e, t], e }, useReducer: function (e, t, r) { var n = Kn(); return t = r !== void 0 ? r(t) : t, n.memoizedState = n.baseState = t, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: t }, n.queue = e, e = e.dispatch = NM.bind(null, Ue, e), [n.memoizedState, e] }, useRef: function (e) { var t = Kn(); return e = { current: e }, t.memoizedState = e }, useState: kC, useDebugValue: aS, useDeferredValue: function (e) { return Kn().memoizedState = e }, useTransition: function () { var e = kC(!1), t = e[0]; return e = AM.bind(null, e[1]), Kn().memoizedState = e, [t, e] }, useMutableSource: function () { }, useSyncExternalStore: function (e, t, r) { var n = Ue, o = Kn(); if (Fe) { if (r === void 0) throw Error(_(407)); r = r() } else { if (r = t(), vt === null) throw Error(_(349)); Ds & 30 || r1(n, t, r) } o.memoizedState = r; var i = { value: r, getSnapshot: t }; return o.queue = i, AC(o1.bind(null, n, i, e), [e]), n.flags |= 2048, Ru(9, n1.bind(null, n, i, r, t), void 0, null), r }, useId: function () { var e = Kn(), t = vt.identifierPrefix; if (Fe) { var r = Co, n = Eo; r = (n & ~(1 << 32 - An(n) - 1)).toString(32) + r, t = ":" + t + "R" + r, r = wu++, 0 < r && (t += "H" + r.toString(32)), t += ":" } else r = kM++, t = ":" + t + "r" + r.toString(32) + ":"; return e.memoizedState = t }, unstable_isNewReconciler: !1 }, LM = { readContext: Yr, useCallback: f1, useContext: Yr, useEffect: sS, useImperativeHandle: d1, useInsertionEffect: l1, useLayoutEffect: c1, useMemo: p1, useReducer: Py, useRef: a1, useState: function () { return Py(Iu) }, useDebugValue: aS, useDeferredValue: function (e) { var t = qr(); return m1(t, st.memoizedState, e) }, useTransition: function () { var e = Py(Iu)[0], t = qr().memoizedState; return [e, t] }, useMutableSource: e1, useSyncExternalStore: t1, useId: h1, unstable_isNewReconciler: !1 }, _M = { readContext: Yr, useCallback: f1, useContext: Yr, useEffect: sS, useImperativeHandle: d1, useInsertionEffect: l1, useLayoutEffect: c1, useMemo: p1, useReducer: Ly, useRef: a1, useState: function () { return Ly(Iu) }, useDebugValue: aS, useDeferredValue: function (e) { var t = qr(); return st === null ? t.memoizedState = e : m1(t, st.memoizedState, e) }, useTransition: function () { var e = Ly(Iu)[0], t = qr().memoizedState; return [e, t] }, useMutableSource: e1, useSyncExternalStore: t1, useId: h1, unstable_isNewReconciler: !1 }; function In(e, t) { if (e && e.defaultProps) { t = Ge({}, t), e = e.defaultProps; for (var r in e) t[r] === void 0 && (t[r] = e[r]); return t } return t } function mv(e, t, r, n) { t = e.memoizedState, r = r(n, t), r = r == null ? t : Ge({}, t, r), e.memoizedState = r, e.lanes === 0 && (e.updateQueue.baseState = r) } var ip = { isMounted: function (e) { return (e = e._reactInternals) ? Fs(e) === e : !1 }, enqueueSetState: function (e, t, r) { e = e._reactInternals; var n = Zt(), o = Ii(e), i = bo(n, o); i.payload = t, r != null && (i.callback = r), t = bi(e, i, o), t !== null && (Nn(t, e, o, n), Tf(t, e, o)) }, enqueueReplaceState: function (e, t, r) { e = e._reactInternals; var n = Zt(), o = Ii(e), i = bo(n, o); i.tag = 1, i.payload = t, r != null && (i.callback = r), t = bi(e, i, o), t !== null && (Nn(t, e, o, n), Tf(t, e, o)) }, enqueueForceUpdate: function (e, t) { e = e._reactInternals; var r = Zt(), n = Ii(e), o = bo(r, n); o.tag = 2, t != null && (o.callback = t), t = bi(e, o, n), t !== null && (Nn(t, e, n, r), Tf(t, e, n)) } }; function NC(e, t, r, n, o, i, s) { return e = e.stateNode, typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(n, i, s) : t.prototype && t.prototype.isPureReactComponent ? !Su(r, n) || !Su(o, i) : !0 } function S1(e, t, r) { var n = !1, o = Ai, i = t.contextType; return typeof i == "object" && i !== null ? i = Yr(i) : (o = ur(t) ? Ls : Vt.current, n = t.contextTypes, i = (n = n != null) ? Qa(e, o) : Ai), t = new t(r, i), e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null, t.updater = ip, e.stateNode = t, t._reactInternals = e, n && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = o, e.__reactInternalMemoizedMaskedChildContext = i), t } function OC(e, t, r, n) { e = t.state, typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(r, n), typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(r, n), t.state !== e && ip.enqueueReplaceState(t, t.state, null) } function hv(e, t, r, n) { var o = e.stateNode; o.props = r, o.state = e.memoizedState, o.refs = {}, Jv(e); var i = t.contextType; typeof i == "object" && i !== null ? o.context = Yr(i) : (i = ur(t) ? Ls : Vt.current, o.context = Qa(e, i)), o.state = e.memoizedState, i = t.getDerivedStateFromProps, typeof i == "function" && (mv(e, t, i, r), o.state = e.memoizedState), typeof t.getDerivedStateFromProps == "function" || typeof o.getSnapshotBeforeUpdate == "function" || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (t = o.state, typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount(), t !== o.state && ip.enqueueReplaceState(o, o.state, null), jf(e, r, o, n), o.state = e.memoizedState), typeof o.componentDidMount == "function" && (e.flags |= 4194308) } function tl(e, t) {
    try { var r = "", n = t; do r += uD(n), n = n.return; while (n); var o = r } catch (i) {
      o = `
Error generating stack: `+ i.message + `
`+ i.stack
    } return { value: e, source: t, stack: o, digest: null }
  } function _y(e, t, r) { return { value: e, source: null, stack: r ?? null, digest: t ?? null } } function gv(e, t) { try { console.error(t.value) } catch (r) { setTimeout(function () { throw r }) } } var DM = typeof WeakMap == "function" ? WeakMap : Map; function x1(e, t, r) { r = bo(-1, r), r.tag = 3, r.payload = { element: null }; var n = t.value; return r.callback = function () { Xf || (Xf = !0, Iv = n), gv(e, t) }, r } function T1(e, t, r) { r = bo(-1, r), r.tag = 3; var n = e.type.getDerivedStateFromError; if (typeof n == "function") { var o = t.value; r.payload = function () { return n(o) }, r.callback = function () { gv(e, t) } } var i = e.stateNode; return i !== null && typeof i.componentDidCatch == "function" && (r.callback = function () { gv(e, t), typeof n != "function" && (wi === null ? wi = new Set([this]) : wi.add(this)); var s = t.stack; this.componentDidCatch(t.value, { componentStack: s !== null ? s : "" }) }), r } function PC(e, t, r) { var n = e.pingCache; if (n === null) { n = e.pingCache = new DM; var o = new Set; n.set(t, o) } else o = n.get(t), o === void 0 && (o = new Set, n.set(t, o)); o.has(r) || (o.add(r), e = YM.bind(null, e, t, r), t.then(e, e)) } function LC(e) { do { var t; if ((t = e.tag === 13) && (t = e.memoizedState, t = t !== null ? t.dehydrated !== null : !0), t) return e; e = e.return } while (e !== null); return null } function _C(e, t, r, n, o) { return e.mode & 1 ? (e.flags |= 65536, e.lanes = o, e) : (e === t ? e.flags |= 65536 : (e.flags |= 128, r.flags |= 131072, r.flags &= -52805, r.tag === 1 && (r.alternate === null ? r.tag = 17 : (t = bo(-1, 1), t.tag = 2, bi(r, t, 1))), r.lanes |= 1), e) } var MM = Ao.ReactCurrentOwner, lr = !1; function Qt(e, t, r, n) { t.child = e === null ? qb(t, null, r, n) : Ja(t, e.child, r, n) } function DC(e, t, r, n, o) { r = r.render; var i = t.ref; return Xa(t, o), n = oS(e, t, r, n, i, o), r = iS(), e !== null && !lr ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~o, ko(e, t, o)) : (Fe && r && $v(t), t.flags |= 1, Qt(e, t, n, o), t.child) } function MC(e, t, r, n, o) { if (e === null) { var i = r.type; return typeof i == "function" && !hS(i) && i.defaultProps === void 0 && r.compare === null && r.defaultProps === void 0 ? (t.tag = 15, t.type = i, E1(e, t, i, n, o)) : (e = Rf(r.type, null, n, t, t.mode, o), e.ref = t.ref, e.return = t, t.child = e) } if (i = e.child, !(e.lanes & o)) { var s = i.memoizedProps; if (r = r.compare, r = r !== null ? r : Su, r(s, n) && e.ref === t.ref) return ko(e, t, o) } return t.flags |= 1, e = Ri(i, n), e.ref = t.ref, e.return = t, t.child = e } function E1(e, t, r, n, o) { if (e !== null) { var i = e.memoizedProps; if (Su(i, n) && e.ref === t.ref) if (lr = !1, t.pendingProps = n = i, (e.lanes & o) !== 0) e.flags & 131072 && (lr = !0); else return t.lanes = e.lanes, ko(e, t, o) } return yv(e, t, r, n, o) } function C1(e, t, r) { var n = t.pendingProps, o = n.children, i = e !== null ? e.memoizedState : null; if (n.mode === "hidden") if (!(t.mode & 1)) t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Le(ja, Rr), Rr |= r; else { if (!(r & 1073741824)) return e = i !== null ? i.baseLanes | r : r, t.lanes = t.childLanes = 1073741824, t.memoizedState = { baseLanes: e, cachePool: null, transitions: null }, t.updateQueue = null, Le(ja, Rr), Rr |= e, null; t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, n = i !== null ? i.baseLanes : r, Le(ja, Rr), Rr |= n } else i !== null ? (n = i.baseLanes | r, t.memoizedState = null) : n = r, Le(ja, Rr), Rr |= n; return Qt(e, t, o, r), t.child } function b1(e, t) { var r = t.ref; (e === null && r !== null || e !== null && e.ref !== r) && (t.flags |= 512, t.flags |= 2097152) } function yv(e, t, r, n, o) { var i = ur(r) ? Ls : Vt.current; return i = Qa(t, i), Xa(t, o), r = oS(e, t, r, n, i, o), n = iS(), e !== null && !lr ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~o, ko(e, t, o)) : (Fe && n && $v(t), t.flags |= 1, Qt(e, t, r, o), t.child) } function BC(e, t, r, n, o) { if (ur(r)) { var i = !0; Vf(t) } else i = !1; if (Xa(t, o), t.stateNode === null) bf(e, t), S1(t, r, n), hv(t, r, n, o), n = !0; else if (e === null) { var s = t.stateNode, a = t.memoizedProps; s.props = a; var l = s.context, c = r.contextType; typeof c == "object" && c !== null ? c = Yr(c) : (c = ur(r) ? Ls : Vt.current, c = Qa(t, c)); var u = r.getDerivedStateFromProps, d = typeof u == "function" || typeof s.getSnapshotBeforeUpdate == "function"; d || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (a !== n || l !== c) && OC(t, s, n, c), hi = !1; var f = t.memoizedState; s.state = f, jf(t, n, s, o), l = t.memoizedState, a !== n || f !== l || cr.current || hi ? (typeof u == "function" && (mv(t, r, u, n), l = t.memoizedState), (a = hi || NC(t, r, a, n, f, l, c)) ? (d || typeof s.UNSAFE_componentWillMount != "function" && typeof s.componentWillMount != "function" || (typeof s.componentWillMount == "function" && s.componentWillMount(), typeof s.UNSAFE_componentWillMount == "function" && s.UNSAFE_componentWillMount()), typeof s.componentDidMount == "function" && (t.flags |= 4194308)) : (typeof s.componentDidMount == "function" && (t.flags |= 4194308), t.memoizedProps = n, t.memoizedState = l), s.props = n, s.state = l, s.context = c, n = a) : (typeof s.componentDidMount == "function" && (t.flags |= 4194308), n = !1) } else { s = t.stateNode, Zb(e, t), a = t.memoizedProps, c = t.type === t.elementType ? a : In(t.type, a), s.props = c, d = t.pendingProps, f = s.context, l = r.contextType, typeof l == "object" && l !== null ? l = Yr(l) : (l = ur(r) ? Ls : Vt.current, l = Qa(t, l)); var p = r.getDerivedStateFromProps; (u = typeof p == "function" || typeof s.getSnapshotBeforeUpdate == "function") || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (a !== d || f !== l) && OC(t, s, n, l), hi = !1, f = t.memoizedState, s.state = f, jf(t, n, s, o); var y = t.memoizedState; a !== d || f !== y || cr.current || hi ? (typeof p == "function" && (mv(t, r, p, n), y = t.memoizedState), (c = hi || NC(t, r, c, n, f, y, l) || !1) ? (u || typeof s.UNSAFE_componentWillUpdate != "function" && typeof s.componentWillUpdate != "function" || (typeof s.componentWillUpdate == "function" && s.componentWillUpdate(n, y, l), typeof s.UNSAFE_componentWillUpdate == "function" && s.UNSAFE_componentWillUpdate(n, y, l)), typeof s.componentDidUpdate == "function" && (t.flags |= 4), typeof s.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024)) : (typeof s.componentDidUpdate != "function" || a === e.memoizedProps && f === e.memoizedState || (t.flags |= 4), typeof s.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && f === e.memoizedState || (t.flags |= 1024), t.memoizedProps = n, t.memoizedState = y), s.props = n, s.state = y, s.context = l, n = c) : (typeof s.componentDidUpdate != "function" || a === e.memoizedProps && f === e.memoizedState || (t.flags |= 4), typeof s.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && f === e.memoizedState || (t.flags |= 1024), n = !1) } return vv(e, t, r, n, i, o) } function vv(e, t, r, n, o, i) { b1(e, t); var s = (t.flags & 128) !== 0; if (!n && !s) return o && EC(t, r, !1), ko(e, t, i); n = t.stateNode, MM.current = t; var a = s && typeof r.getDerivedStateFromError != "function" ? null : n.render(); return t.flags |= 1, e !== null && s ? (t.child = Ja(t, e.child, null, i), t.child = Ja(t, null, a, i)) : Qt(e, t, a, i), t.memoizedState = n.state, o && EC(t, r, !0), t.child } function w1(e) { var t = e.stateNode; t.pendingContext ? TC(e, t.pendingContext, t.pendingContext !== t.context) : t.context && TC(e, t.context, !1), eS(e, t.containerInfo) } function VC(e, t, r, n, o) { return Za(), Xv(o), t.flags |= 256, Qt(e, t, r, n), t.child } var Sv = { dehydrated: null, treeContext: null, retryLane: 0 }; function xv(e) { return { baseLanes: e, cachePool: null, transitions: null } } function I1(e, t, r) { var n = t.pendingProps, o = je.current, i = !1, s = (t.flags & 128) !== 0, a; if ((a = s) || (a = e !== null && e.memoizedState === null ? !1 : (o & 2) !== 0), a ? (i = !0, t.flags &= -129) : (e === null || e.memoizedState !== null) && (o |= 1), Le(je, o & 1), e === null) return fv(t), e = t.memoizedState, e !== null && (e = e.dehydrated, e !== null) ? (t.mode & 1 ? e.data === "$!" ? t.lanes = 8 : t.lanes = 1073741824 : t.lanes = 1, null) : (s = n.children, e = n.fallback, i ? (n = t.mode, i = t.child, s = { mode: "hidden", children: s }, !(n & 1) && i !== null ? (i.childLanes = 0, i.pendingProps = s) : i = lp(s, n, 0, null), e = Ps(e, n, r, null), i.return = t, e.return = t, i.sibling = e, t.child = i, t.child.memoizedState = xv(r), t.memoizedState = Sv, e) : lS(t, s)); if (o = e.memoizedState, o !== null && (a = o.dehydrated, a !== null)) return BM(e, t, s, n, a, o, r); if (i) { i = n.fallback, s = t.mode, o = e.child, a = o.sibling; var l = { mode: "hidden", children: n.children }; return !(s & 1) && t.child !== o ? (n = t.child, n.childLanes = 0, n.pendingProps = l, t.deletions = null) : (n = Ri(o, l), n.subtreeFlags = o.subtreeFlags & 14680064), a !== null ? i = Ri(a, i) : (i = Ps(i, s, r, null), i.flags |= 2), i.return = t, n.return = t, n.sibling = i, t.child = n, n = i, i = t.child, s = e.child.memoizedState, s = s === null ? xv(r) : { baseLanes: s.baseLanes | r, cachePool: null, transitions: s.transitions }, i.memoizedState = s, i.childLanes = e.childLanes & ~r, t.memoizedState = Sv, n } return i = e.child, e = i.sibling, n = Ri(i, { mode: "visible", children: n.children }), !(t.mode & 1) && (n.lanes = r), n.return = t, n.sibling = null, e !== null && (r = t.deletions, r === null ? (t.deletions = [e], t.flags |= 16) : r.push(e)), t.child = n, t.memoizedState = null, n } function lS(e, t) { return t = lp({ mode: "visible", children: t }, e.mode, 0, null), t.return = e, e.child = t } function hf(e, t, r, n) { return n !== null && Xv(n), Ja(t, e.child, null, r), e = lS(t, t.pendingProps.children), e.flags |= 2, t.memoizedState = null, e } function BM(e, t, r, n, o, i, s) { if (r) return t.flags & 256 ? (t.flags &= -257, n = _y(Error(_(422))), hf(e, t, s, n)) : t.memoizedState !== null ? (t.child = e.child, t.flags |= 128, null) : (i = n.fallback, o = t.mode, n = lp({ mode: "visible", children: n.children }, o, 0, null), i = Ps(i, o, s, null), i.flags |= 2, n.return = t, i.return = t, n.sibling = i, t.child = n, t.mode & 1 && Ja(t, e.child, null, s), t.child.memoizedState = xv(s), t.memoizedState = Sv, i); if (!(t.mode & 1)) return hf(e, t, s, null); if (o.data === "$!") { if (n = o.nextSibling && o.nextSibling.dataset, n) var a = n.dgst; return n = a, i = Error(_(419)), n = _y(i, n, void 0), hf(e, t, s, n) } if (a = (s & e.childLanes) !== 0, lr || a) { if (n = vt, n !== null) { switch (s & -s) { case 4: o = 2; break; case 16: o = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: o = 32; break; case 536870912: o = 268435456; break; default: o = 0 }o = o & (n.suspendedLanes | s) ? 0 : o, o !== 0 && o !== i.retryLane && (i.retryLane = o, Ro(e, o), Nn(n, e, o, -1)) } return mS(), n = _y(Error(_(421))), hf(e, t, s, n) } return o.data === "$?" ? (t.flags |= 128, t.child = e.child, t = qM.bind(null, e), o._reactRetry = t, null) : (e = i.treeContext, kr = Ci(o.nextSibling), Ar = t, Fe = !0, kn = null, e !== null && (Gr[$r++] = Eo, Gr[$r++] = Co, Gr[$r++] = _s, Eo = e.id, Co = e.overflow, _s = t), t = lS(t, n.children), t.flags |= 4096, t) } function FC(e, t, r) { e.lanes |= t; var n = e.alternate; n !== null && (n.lanes |= t), pv(e.return, t, r) } function Dy(e, t, r, n, o) { var i = e.memoizedState; i === null ? e.memoizedState = { isBackwards: t, rendering: null, renderingStartTime: 0, last: n, tail: r, tailMode: o } : (i.isBackwards = t, i.rendering = null, i.renderingStartTime = 0, i.last = n, i.tail = r, i.tailMode = o) } function R1(e, t, r) { var n = t.pendingProps, o = n.revealOrder, i = n.tail; if (Qt(e, t, n.children, r), n = je.current, n & 2) n = n & 1 | 2, t.flags |= 128; else { if (e !== null && e.flags & 128) e: for (e = t.child; e !== null;) { if (e.tag === 13) e.memoizedState !== null && FC(e, r, t); else if (e.tag === 19) FC(e, r, t); else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === t) break e; for (; e.sibling === null;) { if (e.return === null || e.return === t) break e; e = e.return } e.sibling.return = e.return, e = e.sibling } n &= 1 } if (Le(je, n), !(t.mode & 1)) t.memoizedState = null; else switch (o) { case "forwards": for (r = t.child, o = null; r !== null;)e = r.alternate, e !== null && Uf(e) === null && (o = r), r = r.sibling; r = o, r === null ? (o = t.child, t.child = null) : (o = r.sibling, r.sibling = null), Dy(t, !1, o, r, i); break; case "backwards": for (r = null, o = t.child, t.child = null; o !== null;) { if (e = o.alternate, e !== null && Uf(e) === null) { t.child = o; break } e = o.sibling, o.sibling = r, r = o, o = e } Dy(t, !0, r, null, i); break; case "together": Dy(t, !1, null, null, void 0); break; default: t.memoizedState = null }return t.child } function bf(e, t) { !(t.mode & 1) && e !== null && (e.alternate = null, t.alternate = null, t.flags |= 2) } function ko(e, t, r) { if (e !== null && (t.dependencies = e.dependencies), Ms |= t.lanes, !(r & t.childLanes)) return null; if (e !== null && t.child !== e.child) throw Error(_(153)); if (t.child !== null) { for (e = t.child, r = Ri(e, e.pendingProps), t.child = r, r.return = t; e.sibling !== null;)e = e.sibling, r = r.sibling = Ri(e, e.pendingProps), r.return = t; r.sibling = null } return t.child } function VM(e, t, r) { switch (t.tag) { case 3: w1(t), Za(); break; case 5: Jb(t); break; case 1: ur(t.type) && Vf(t); break; case 4: eS(t, t.stateNode.containerInfo); break; case 10: var n = t.type._context, o = t.memoizedProps.value; Le(Hf, n._currentValue), n._currentValue = o; break; case 13: if (n = t.memoizedState, n !== null) return n.dehydrated !== null ? (Le(je, je.current & 1), t.flags |= 128, null) : r & t.child.childLanes ? I1(e, t, r) : (Le(je, je.current & 1), e = ko(e, t, r), e !== null ? e.sibling : null); Le(je, je.current & 1); break; case 19: if (n = (r & t.childLanes) !== 0, e.flags & 128) { if (n) return R1(e, t, r); t.flags |= 128 } if (o = t.memoizedState, o !== null && (o.rendering = null, o.tail = null, o.lastEffect = null), Le(je, je.current), n) break; return null; case 22: case 23: return t.lanes = 0, C1(e, t, r) }return ko(e, t, r) } var k1, Tv, A1, N1; k1 = function (e, t) { for (var r = t.child; r !== null;) { if (r.tag === 5 || r.tag === 6) e.appendChild(r.stateNode); else if (r.tag !== 4 && r.child !== null) { r.child.return = r, r = r.child; continue } if (r === t) break; for (; r.sibling === null;) { if (r.return === null || r.return === t) return; r = r.return } r.sibling.return = r.return, r = r.sibling } }; Tv = function () { }; A1 = function (e, t, r, n) { var o = e.memoizedProps; if (o !== n) { e = t.stateNode, Ns(qn.current); var i = null; switch (r) { case "input": o = jy(e, o), n = jy(e, n), i = []; break; case "select": o = Ge({}, o, { value: void 0 }), n = Ge({}, n, { value: void 0 }), i = []; break; case "textarea": o = $y(e, o), n = $y(e, n), i = []; break; default: typeof o.onClick != "function" && typeof n.onClick == "function" && (e.onclick = Mf) }Xy(r, n); var s; r = null; for (c in o) if (!n.hasOwnProperty(c) && o.hasOwnProperty(c) && o[c] != null) if (c === "style") { var a = o[c]; for (s in a) a.hasOwnProperty(s) && (r || (r = {}), r[s] = "") } else c !== "dangerouslySetInnerHTML" && c !== "children" && c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && c !== "autoFocus" && (fu.hasOwnProperty(c) ? i || (i = []) : (i = i || []).push(c, null)); for (c in n) { var l = n[c]; if (a = o?.[c], n.hasOwnProperty(c) && l !== a && (l != null || a != null)) if (c === "style") if (a) { for (s in a) !a.hasOwnProperty(s) || l && l.hasOwnProperty(s) || (r || (r = {}), r[s] = ""); for (s in l) l.hasOwnProperty(s) && a[s] !== l[s] && (r || (r = {}), r[s] = l[s]) } else r || (i || (i = []), i.push(c, r)), r = l; else c === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, a = a ? a.__html : void 0, l != null && a !== l && (i = i || []).push(c, l)) : c === "children" ? typeof l != "string" && typeof l != "number" || (i = i || []).push(c, "" + l) : c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && (fu.hasOwnProperty(c) ? (l != null && c === "onScroll" && De("scroll", e), i || a === l || (i = [])) : (i = i || []).push(c, l)) } r && (i = i || []).push("style", r); var c = i; (t.updateQueue = c) && (t.flags |= 4) } }; N1 = function (e, t, r, n) { r !== n && (t.flags |= 4) }; function qc(e, t) { if (!Fe) switch (e.tailMode) { case "hidden": t = e.tail; for (var r = null; t !== null;)t.alternate !== null && (r = t), t = t.sibling; r === null ? e.tail = null : r.sibling = null; break; case "collapsed": r = e.tail; for (var n = null; r !== null;)r.alternate !== null && (n = r), r = r.sibling; n === null ? t || e.tail === null ? e.tail = null : e.tail.sibling = null : n.sibling = null } } function Mt(e) { var t = e.alternate !== null && e.alternate.child === e.child, r = 0, n = 0; if (t) for (var o = e.child; o !== null;)r |= o.lanes | o.childLanes, n |= o.subtreeFlags & 14680064, n |= o.flags & 14680064, o.return = e, o = o.sibling; else for (o = e.child; o !== null;)r |= o.lanes | o.childLanes, n |= o.subtreeFlags, n |= o.flags, o.return = e, o = o.sibling; return e.subtreeFlags |= n, e.childLanes = r, t } function FM(e, t, r) { var n = t.pendingProps; switch (Kv(t), t.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return Mt(t), null; case 1: return ur(t.type) && Bf(), Mt(t), null; case 3: return n = t.stateNode, el(), Me(cr), Me(Vt), rS(), n.pendingContext && (n.context = n.pendingContext, n.pendingContext = null), (e === null || e.child === null) && (pf(t) ? t.flags |= 4 : e === null || e.memoizedState.isDehydrated && !(t.flags & 256) || (t.flags |= 1024, kn !== null && (Av(kn), kn = null))), Tv(e, t), Mt(t), null; case 5: tS(t); var o = Ns(bu.current); if (r = t.type, e !== null && t.stateNode != null) A1(e, t, r, n, o), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152); else { if (!n) { if (t.stateNode === null) throw Error(_(166)); return Mt(t), null } if (e = Ns(qn.current), pf(t)) { n = t.stateNode, r = t.type; var i = t.memoizedProps; switch (n[Xn] = t, n[Eu] = i, e = (t.mode & 1) !== 0, r) { case "dialog": De("cancel", n), De("close", n); break; case "iframe": case "object": case "embed": De("load", n); break; case "video": case "audio": for (o = 0; o < ru.length; o++)De(ru[o], n); break; case "source": De("error", n); break; case "img": case "image": case "link": De("error", n), De("load", n); break; case "details": De("toggle", n); break; case "input": KE(n, i), De("invalid", n); break; case "select": n._wrapperState = { wasMultiple: !!i.multiple }, De("invalid", n); break; case "textarea": YE(n, i), De("invalid", n) }Xy(r, i), o = null; for (var s in i) if (i.hasOwnProperty(s)) { var a = i[s]; s === "children" ? typeof a == "string" ? n.textContent !== a && (i.suppressHydrationWarning !== !0 && ff(n.textContent, a, e), o = ["children", a]) : typeof a == "number" && n.textContent !== "" + a && (i.suppressHydrationWarning !== !0 && ff(n.textContent, a, e), o = ["children", "" + a]) : fu.hasOwnProperty(s) && a != null && s === "onScroll" && De("scroll", n) } switch (r) { case "input": Jd(n), XE(n, i, !0); break; case "textarea": Jd(n), qE(n); break; case "select": case "option": break; default: typeof i.onClick == "function" && (n.onclick = Mf) }n = o, t.updateQueue = n, n !== null && (t.flags |= 4) } else { s = o.nodeType === 9 ? o : o.ownerDocument, e === "http://www.w3.org/1999/xhtml" && (e = ob(r)), e === "http://www.w3.org/1999/xhtml" ? r === "script" ? (e = s.createElement("div"), e.innerHTML = "<script></script>", e = e.removeChild(e.firstChild)) : typeof n.is == "string" ? e = s.createElement(r, { is: n.is }) : (e = s.createElement(r), r === "select" && (s = e, n.multiple ? s.multiple = !0 : n.size && (s.size = n.size))) : e = s.createElementNS(e, r), e[Xn] = t, e[Eu] = n, k1(e, t, !1, !1), t.stateNode = e; e: { switch (s = Yy(r, n), r) { case "dialog": De("cancel", e), De("close", e), o = n; break; case "iframe": case "object": case "embed": De("load", e), o = n; break; case "video": case "audio": for (o = 0; o < ru.length; o++)De(ru[o], e); o = n; break; case "source": De("error", e), o = n; break; case "img": case "image": case "link": De("error", e), De("load", e), o = n; break; case "details": De("toggle", e), o = n; break; case "input": KE(e, n), o = jy(e, n), De("invalid", e); break; case "option": o = n; break; case "select": e._wrapperState = { wasMultiple: !!n.multiple }, o = Ge({}, n, { value: void 0 }), De("invalid", e); break; case "textarea": YE(e, n), o = $y(e, n), De("invalid", e); break; default: o = n }Xy(r, o), a = o; for (i in a) if (a.hasOwnProperty(i)) { var l = a[i]; i === "style" ? ab(e, l) : i === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, l != null && ib(e, l)) : i === "children" ? typeof l == "string" ? (r !== "textarea" || l !== "") && pu(e, l) : typeof l == "number" && pu(e, "" + l) : i !== "suppressContentEditableWarning" && i !== "suppressHydrationWarning" && i !== "autoFocus" && (fu.hasOwnProperty(i) ? l != null && i === "onScroll" && De("scroll", e) : l != null && Pv(e, i, l, s)) } switch (r) { case "input": Jd(e), XE(e, n, !1); break; case "textarea": Jd(e), qE(e); break; case "option": n.value != null && e.setAttribute("value", "" + ki(n.value)); break; case "select": e.multiple = !!n.multiple, i = n.value, i != null ? Ua(e, !!n.multiple, i, !1) : n.defaultValue != null && Ua(e, !!n.multiple, n.defaultValue, !0); break; default: typeof o.onClick == "function" && (e.onclick = Mf) }switch (r) { case "button": case "input": case "select": case "textarea": n = !!n.autoFocus; break e; case "img": n = !0; break e; default: n = !1 } } n && (t.flags |= 4) } t.ref !== null && (t.flags |= 512, t.flags |= 2097152) } return Mt(t), null; case 6: if (e && t.stateNode != null) N1(e, t, e.memoizedProps, n); else { if (typeof n != "string" && t.stateNode === null) throw Error(_(166)); if (r = Ns(bu.current), Ns(qn.current), pf(t)) { if (n = t.stateNode, r = t.memoizedProps, n[Xn] = t, (i = n.nodeValue !== r) && (e = Ar, e !== null)) switch (e.tag) { case 3: ff(n.nodeValue, r, (e.mode & 1) !== 0); break; case 5: e.memoizedProps.suppressHydrationWarning !== !0 && ff(n.nodeValue, r, (e.mode & 1) !== 0) }i && (t.flags |= 4) } else n = (r.nodeType === 9 ? r : r.ownerDocument).createTextNode(n), n[Xn] = t, t.stateNode = n } return Mt(t), null; case 13: if (Me(je), n = t.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) { if (Fe && kr !== null && t.mode & 1 && !(t.flags & 128)) Xb(), Za(), t.flags |= 98560, i = !1; else if (i = pf(t), n !== null && n.dehydrated !== null) { if (e === null) { if (!i) throw Error(_(318)); if (i = t.memoizedState, i = i !== null ? i.dehydrated : null, !i) throw Error(_(317)); i[Xn] = t } else Za(), !(t.flags & 128) && (t.memoizedState = null), t.flags |= 4; Mt(t), i = !1 } else kn !== null && (Av(kn), kn = null), i = !0; if (!i) return t.flags & 65536 ? t : null } return t.flags & 128 ? (t.lanes = r, t) : (n = n !== null, n !== (e !== null && e.memoizedState !== null) && n && (t.child.flags |= 8192, t.mode & 1 && (e === null || je.current & 1 ? at === 0 && (at = 3) : mS())), t.updateQueue !== null && (t.flags |= 4), Mt(t), null); case 4: return el(), Tv(e, t), e === null && xu(t.stateNode.containerInfo), Mt(t), null; case 10: return Qv(t.type._context), Mt(t), null; case 17: return ur(t.type) && Bf(), Mt(t), null; case 19: if (Me(je), i = t.memoizedState, i === null) return Mt(t), null; if (n = (t.flags & 128) !== 0, s = i.rendering, s === null) if (n) qc(i, !1); else { if (at !== 0 || e !== null && e.flags & 128) for (e = t.child; e !== null;) { if (s = Uf(e), s !== null) { for (t.flags |= 128, qc(i, !1), n = s.updateQueue, n !== null && (t.updateQueue = n, t.flags |= 4), t.subtreeFlags = 0, n = r, r = t.child; r !== null;)i = r, e = n, i.flags &= 14680066, s = i.alternate, s === null ? (i.childLanes = 0, i.lanes = e, i.child = null, i.subtreeFlags = 0, i.memoizedProps = null, i.memoizedState = null, i.updateQueue = null, i.dependencies = null, i.stateNode = null) : (i.childLanes = s.childLanes, i.lanes = s.lanes, i.child = s.child, i.subtreeFlags = 0, i.deletions = null, i.memoizedProps = s.memoizedProps, i.memoizedState = s.memoizedState, i.updateQueue = s.updateQueue, i.type = s.type, e = s.dependencies, i.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }), r = r.sibling; return Le(je, je.current & 1 | 2), t.child } e = e.sibling } i.tail !== null && Ze() > rl && (t.flags |= 128, n = !0, qc(i, !1), t.lanes = 4194304) } else { if (!n) if (e = Uf(s), e !== null) { if (t.flags |= 128, n = !0, r = e.updateQueue, r !== null && (t.updateQueue = r, t.flags |= 4), qc(i, !0), i.tail === null && i.tailMode === "hidden" && !s.alternate && !Fe) return Mt(t), null } else 2 * Ze() - i.renderingStartTime > rl && r !== 1073741824 && (t.flags |= 128, n = !0, qc(i, !1), t.lanes = 4194304); i.isBackwards ? (s.sibling = t.child, t.child = s) : (r = i.last, r !== null ? r.sibling = s : t.child = s, i.last = s) } return i.tail !== null ? (t = i.tail, i.rendering = t, i.tail = t.sibling, i.renderingStartTime = Ze(), t.sibling = null, r = je.current, Le(je, n ? r & 1 | 2 : r & 1), t) : (Mt(t), null); case 22: case 23: return pS(), n = t.memoizedState !== null, e !== null && e.memoizedState !== null !== n && (t.flags |= 8192), n && t.mode & 1 ? Rr & 1073741824 && (Mt(t), t.subtreeFlags & 6 && (t.flags |= 8192)) : Mt(t), null; case 24: return null; case 25: return null }throw Error(_(156, t.tag)) } function zM(e, t) { switch (Kv(t), t.tag) { case 1: return ur(t.type) && Bf(), e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null; case 3: return el(), Me(cr), Me(Vt), rS(), e = t.flags, e & 65536 && !(e & 128) ? (t.flags = e & -65537 | 128, t) : null; case 5: return tS(t), null; case 13: if (Me(je), e = t.memoizedState, e !== null && e.dehydrated !== null) { if (t.alternate === null) throw Error(_(340)); Za() } return e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null; case 19: return Me(je), null; case 4: return el(), null; case 10: return Qv(t.type._context), null; case 22: case 23: return pS(), null; case 24: return null; default: return null } } var gf = !1, Bt = !1, HM = typeof WeakSet == "function" ? WeakSet : Set, F = null; function Wa(e, t) { var r = e.ref; if (r !== null) if (typeof r == "function") try { r(null) } catch (n) { Xe(e, t, n) } else r.current = null } function Ev(e, t, r) { try { r() } catch (n) { Xe(e, t, n) } } var zC = !1; function WM(e, t) { if (iv = Lf, e = Db(), Gv(e)) { if ("selectionStart" in e) var r = { start: e.selectionStart, end: e.selectionEnd }; else e: { r = (r = e.ownerDocument) && r.defaultView || window; var n = r.getSelection && r.getSelection(); if (n && n.rangeCount !== 0) { r = n.anchorNode; var o = n.anchorOffset, i = n.focusNode; n = n.focusOffset; try { r.nodeType, i.nodeType } catch { r = null; break e } var s = 0, a = -1, l = -1, c = 0, u = 0, d = e, f = null; t: for (; ;) { for (var p; d !== r || o !== 0 && d.nodeType !== 3 || (a = s + o), d !== i || n !== 0 && d.nodeType !== 3 || (l = s + n), d.nodeType === 3 && (s += d.nodeValue.length), (p = d.firstChild) !== null;)f = d, d = p; for (; ;) { if (d === e) break t; if (f === r && ++c === o && (a = s), f === i && ++u === n && (l = s), (p = d.nextSibling) !== null) break; d = f, f = d.parentNode } d = p } r = a === -1 || l === -1 ? null : { start: a, end: l } } else r = null } r = r || { start: 0, end: 0 } } else r = null; for (sv = { focusedElem: e, selectionRange: r }, Lf = !1, F = t; F !== null;)if (t = F, e = t.child, (t.subtreeFlags & 1028) !== 0 && e !== null) e.return = t, F = e; else for (; F !== null;) { t = F; try { var y = t.alternate; if (t.flags & 1024) switch (t.tag) { case 0: case 11: case 15: break; case 1: if (y !== null) { var g = y.memoizedProps, S = y.memoizedState, h = t.stateNode, m = h.getSnapshotBeforeUpdate(t.elementType === t.type ? g : In(t.type, g), S); h.__reactInternalSnapshotBeforeUpdate = m } break; case 3: var v = t.stateNode.containerInfo; v.nodeType === 1 ? v.textContent = "" : v.nodeType === 9 && v.documentElement && v.removeChild(v.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(_(163)) } } catch (x) { Xe(t, t.return, x) } if (e = t.sibling, e !== null) { e.return = t.return, F = e; break } F = t.return } return y = zC, zC = !1, y } function cu(e, t, r) { var n = t.updateQueue; if (n = n !== null ? n.lastEffect : null, n !== null) { var o = n = n.next; do { if ((o.tag & e) === e) { var i = o.destroy; o.destroy = void 0, i !== void 0 && Ev(t, r, i) } o = o.next } while (o !== n) } } function sp(e, t) { if (t = t.updateQueue, t = t !== null ? t.lastEffect : null, t !== null) { var r = t = t.next; do { if ((r.tag & e) === e) { var n = r.create; r.destroy = n() } r = r.next } while (r !== t) } } function Cv(e) { var t = e.ref; if (t !== null) { var r = e.stateNode; switch (e.tag) { case 5: e = r; break; default: e = r }typeof t == "function" ? t(e) : t.current = e } } function O1(e) { var t = e.alternate; t !== null && (e.alternate = null, O1(t)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (t = e.stateNode, t !== null && (delete t[Xn], delete t[Eu], delete t[cv], delete t[bM], delete t[wM])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null } function P1(e) { return e.tag === 5 || e.tag === 3 || e.tag === 4 } function HC(e) { e: for (; ;) { for (; e.sibling === null;) { if (e.return === null || P1(e.return)) return null; e = e.return } for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18;) { if (e.flags & 2 || e.child === null || e.tag === 4) continue e; e.child.return = e, e = e.child } if (!(e.flags & 2)) return e.stateNode } } function bv(e, t, r) { var n = e.tag; if (n === 5 || n === 6) e = e.stateNode, t ? r.nodeType === 8 ? r.parentNode.insertBefore(e, t) : r.insertBefore(e, t) : (r.nodeType === 8 ? (t = r.parentNode, t.insertBefore(e, r)) : (t = r, t.appendChild(e)), r = r._reactRootContainer, r != null || t.onclick !== null || (t.onclick = Mf)); else if (n !== 4 && (e = e.child, e !== null)) for (bv(e, t, r), e = e.sibling; e !== null;)bv(e, t, r), e = e.sibling } function wv(e, t, r) { var n = e.tag; if (n === 5 || n === 6) e = e.stateNode, t ? r.insertBefore(e, t) : r.appendChild(e); else if (n !== 4 && (e = e.child, e !== null)) for (wv(e, t, r), e = e.sibling; e !== null;)wv(e, t, r), e = e.sibling } var bt = null, Rn = !1; function pi(e, t, r) { for (r = r.child; r !== null;)L1(e, t, r), r = r.sibling } function L1(e, t, r) { if (Yn && typeof Yn.onCommitFiberUnmount == "function") try { Yn.onCommitFiberUnmount(Zf, r) } catch { } switch (r.tag) { case 5: Bt || Wa(r, t); case 6: var n = bt, o = Rn; bt = null, pi(e, t, r), bt = n, Rn = o, bt !== null && (Rn ? (e = bt, r = r.stateNode, e.nodeType === 8 ? e.parentNode.removeChild(r) : e.removeChild(r)) : bt.removeChild(r.stateNode)); break; case 18: bt !== null && (Rn ? (e = bt, r = r.stateNode, e.nodeType === 8 ? ky(e.parentNode, r) : e.nodeType === 1 && ky(e, r), yu(e)) : ky(bt, r.stateNode)); break; case 4: n = bt, o = Rn, bt = r.stateNode.containerInfo, Rn = !0, pi(e, t, r), bt = n, Rn = o; break; case 0: case 11: case 14: case 15: if (!Bt && (n = r.updateQueue, n !== null && (n = n.lastEffect, n !== null))) { o = n = n.next; do { var i = o, s = i.destroy; i = i.tag, s !== void 0 && (i & 2 || i & 4) && Ev(r, t, s), o = o.next } while (o !== n) } pi(e, t, r); break; case 1: if (!Bt && (Wa(r, t), n = r.stateNode, typeof n.componentWillUnmount == "function")) try { n.props = r.memoizedProps, n.state = r.memoizedState, n.componentWillUnmount() } catch (a) { Xe(r, t, a) } pi(e, t, r); break; case 21: pi(e, t, r); break; case 22: r.mode & 1 ? (Bt = (n = Bt) || r.memoizedState !== null, pi(e, t, r), Bt = n) : pi(e, t, r); break; default: pi(e, t, r) } } function WC(e) { var t = e.updateQueue; if (t !== null) { e.updateQueue = null; var r = e.stateNode; r === null && (r = e.stateNode = new HM), t.forEach(function (n) { var o = QM.bind(null, e, n); r.has(n) || (r.add(n), n.then(o, o)) }) } } function wn(e, t) { var r = t.deletions; if (r !== null) for (var n = 0; n < r.length; n++) { var o = r[n]; try { var i = e, s = t, a = s; e: for (; a !== null;) { switch (a.tag) { case 5: bt = a.stateNode, Rn = !1; break e; case 3: bt = a.stateNode.containerInfo, Rn = !0; break e; case 4: bt = a.stateNode.containerInfo, Rn = !0; break e }a = a.return } if (bt === null) throw Error(_(160)); L1(i, s, o), bt = null, Rn = !1; var l = o.alternate; l !== null && (l.return = null), o.return = null } catch (c) { Xe(o, t, c) } } if (t.subtreeFlags & 12854) for (t = t.child; t !== null;)_1(t, e), t = t.sibling } function _1(e, t) { var r = e.alternate, n = e.flags; switch (e.tag) { case 0: case 11: case 14: case 15: if (wn(t, e), $n(e), n & 4) { try { cu(3, e, e.return), sp(3, e) } catch (g) { Xe(e, e.return, g) } try { cu(5, e, e.return) } catch (g) { Xe(e, e.return, g) } } break; case 1: wn(t, e), $n(e), n & 512 && r !== null && Wa(r, r.return); break; case 5: if (wn(t, e), $n(e), n & 512 && r !== null && Wa(r, r.return), e.flags & 32) { var o = e.stateNode; try { pu(o, "") } catch (g) { Xe(e, e.return, g) } } if (n & 4 && (o = e.stateNode, o != null)) { var i = e.memoizedProps, s = r !== null ? r.memoizedProps : i, a = e.type, l = e.updateQueue; if (e.updateQueue = null, l !== null) try { a === "input" && i.type === "radio" && i.name != null && rb(o, i), Yy(a, s); var c = Yy(a, i); for (s = 0; s < l.length; s += 2) { var u = l[s], d = l[s + 1]; u === "style" ? ab(o, d) : u === "dangerouslySetInnerHTML" ? ib(o, d) : u === "children" ? pu(o, d) : Pv(o, u, d, c) } switch (a) { case "input": Uy(o, i); break; case "textarea": nb(o, i); break; case "select": var f = o._wrapperState.wasMultiple; o._wrapperState.wasMultiple = !!i.multiple; var p = i.value; p != null ? Ua(o, !!i.multiple, p, !1) : f !== !!i.multiple && (i.defaultValue != null ? Ua(o, !!i.multiple, i.defaultValue, !0) : Ua(o, !!i.multiple, i.multiple ? [] : "", !1)) }o[Eu] = i } catch (g) { Xe(e, e.return, g) } } break; case 6: if (wn(t, e), $n(e), n & 4) { if (e.stateNode === null) throw Error(_(162)); o = e.stateNode, i = e.memoizedProps; try { o.nodeValue = i } catch (g) { Xe(e, e.return, g) } } break; case 3: if (wn(t, e), $n(e), n & 4 && r !== null && r.memoizedState.isDehydrated) try { yu(t.containerInfo) } catch (g) { Xe(e, e.return, g) } break; case 4: wn(t, e), $n(e); break; case 13: wn(t, e), $n(e), o = e.child, o.flags & 8192 && (i = o.memoizedState !== null, o.stateNode.isHidden = i, !i || o.alternate !== null && o.alternate.memoizedState !== null || (dS = Ze())), n & 4 && WC(e); break; case 22: if (u = r !== null && r.memoizedState !== null, e.mode & 1 ? (Bt = (c = Bt) || u, wn(t, e), Bt = c) : wn(t, e), $n(e), n & 8192) { if (c = e.memoizedState !== null, (e.stateNode.isHidden = c) && !u && e.mode & 1) for (F = e, u = e.child; u !== null;) { for (d = F = u; F !== null;) { switch (f = F, p = f.child, f.tag) { case 0: case 11: case 14: case 15: cu(4, f, f.return); break; case 1: Wa(f, f.return); var y = f.stateNode; if (typeof y.componentWillUnmount == "function") { n = f, r = f.return; try { t = n, y.props = t.memoizedProps, y.state = t.memoizedState, y.componentWillUnmount() } catch (g) { Xe(n, r, g) } } break; case 5: Wa(f, f.return); break; case 22: if (f.memoizedState !== null) { UC(d); continue } }p !== null ? (p.return = f, F = p) : UC(d) } u = u.sibling } e: for (u = null, d = e; ;) { if (d.tag === 5) { if (u === null) { u = d; try { o = d.stateNode, c ? (i = o.style, typeof i.setProperty == "function" ? i.setProperty("display", "none", "important") : i.display = "none") : (a = d.stateNode, l = d.memoizedProps.style, s = l != null && l.hasOwnProperty("display") ? l.display : null, a.style.display = sb("display", s)) } catch (g) { Xe(e, e.return, g) } } } else if (d.tag === 6) { if (u === null) try { d.stateNode.nodeValue = c ? "" : d.memoizedProps } catch (g) { Xe(e, e.return, g) } } else if ((d.tag !== 22 && d.tag !== 23 || d.memoizedState === null || d === e) && d.child !== null) { d.child.return = d, d = d.child; continue } if (d === e) break e; for (; d.sibling === null;) { if (d.return === null || d.return === e) break e; u === d && (u = null), d = d.return } u === d && (u = null), d.sibling.return = d.return, d = d.sibling } } break; case 19: wn(t, e), $n(e), n & 4 && WC(e); break; case 21: break; default: wn(t, e), $n(e) } } function $n(e) { var t = e.flags; if (t & 2) { try { e: { for (var r = e.return; r !== null;) { if (P1(r)) { var n = r; break e } r = r.return } throw Error(_(160)) } switch (n.tag) { case 5: var o = n.stateNode; n.flags & 32 && (pu(o, ""), n.flags &= -33); var i = HC(e); wv(e, i, o); break; case 3: case 4: var s = n.stateNode.containerInfo, a = HC(e); bv(e, a, s); break; default: throw Error(_(161)) } } catch (l) { Xe(e, e.return, l) } e.flags &= -3 } t & 4096 && (e.flags &= -4097) } function jM(e, t, r) { F = e, D1(e, t, r) } function D1(e, t, r) { for (var n = (e.mode & 1) !== 0; F !== null;) { var o = F, i = o.child; if (o.tag === 22 && n) { var s = o.memoizedState !== null || gf; if (!s) { var a = o.alternate, l = a !== null && a.memoizedState !== null || Bt; a = gf; var c = Bt; if (gf = s, (Bt = l) && !c) for (F = o; F !== null;)s = F, l = s.child, s.tag === 22 && s.memoizedState !== null ? GC(o) : l !== null ? (l.return = s, F = l) : GC(o); for (; i !== null;)F = i, D1(i, t, r), i = i.sibling; F = o, gf = a, Bt = c } jC(e, t, r) } else o.subtreeFlags & 8772 && i !== null ? (i.return = o, F = i) : jC(e, t, r) } } function jC(e) { for (; F !== null;) { var t = F; if (t.flags & 8772) { var r = t.alternate; try { if (t.flags & 8772) switch (t.tag) { case 0: case 11: case 15: Bt || sp(5, t); break; case 1: var n = t.stateNode; if (t.flags & 4 && !Bt) if (r === null) n.componentDidMount(); else { var o = t.elementType === t.type ? r.memoizedProps : In(t.type, r.memoizedProps); n.componentDidUpdate(o, r.memoizedState, n.__reactInternalSnapshotBeforeUpdate) } var i = t.updateQueue; i !== null && RC(t, i, n); break; case 3: var s = t.updateQueue; if (s !== null) { if (r = null, t.child !== null) switch (t.child.tag) { case 5: r = t.child.stateNode; break; case 1: r = t.child.stateNode }RC(t, s, r) } break; case 5: var a = t.stateNode; if (r === null && t.flags & 4) { r = a; var l = t.memoizedProps; switch (t.type) { case "button": case "input": case "select": case "textarea": l.autoFocus && r.focus(); break; case "img": l.src && (r.src = l.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (t.memoizedState === null) { var c = t.alternate; if (c !== null) { var u = c.memoizedState; if (u !== null) { var d = u.dehydrated; d !== null && yu(d) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(_(163)) }Bt || t.flags & 512 && Cv(t) } catch (f) { Xe(t, t.return, f) } } if (t === e) { F = null; break } if (r = t.sibling, r !== null) { r.return = t.return, F = r; break } F = t.return } } function UC(e) { for (; F !== null;) { var t = F; if (t === e) { F = null; break } var r = t.sibling; if (r !== null) { r.return = t.return, F = r; break } F = t.return } } function GC(e) { for (; F !== null;) { var t = F; try { switch (t.tag) { case 0: case 11: case 15: var r = t.return; try { sp(4, t) } catch (l) { Xe(t, r, l) } break; case 1: var n = t.stateNode; if (typeof n.componentDidMount == "function") { var o = t.return; try { n.componentDidMount() } catch (l) { Xe(t, o, l) } } var i = t.return; try { Cv(t) } catch (l) { Xe(t, i, l) } break; case 5: var s = t.return; try { Cv(t) } catch (l) { Xe(t, s, l) } } } catch (l) { Xe(t, t.return, l) } if (t === e) { F = null; break } var a = t.sibling; if (a !== null) { a.return = t.return, F = a; break } F = t.return } } var UM = Math.ceil, Kf = Ao.ReactCurrentDispatcher, cS = Ao.ReactCurrentOwner, Xr = Ao.ReactCurrentBatchConfig, pe = 0, vt = null, tt = null, wt = 0, Rr = 0, ja = Oi(0), at = 0, ku = null, Ms = 0, ap = 0, uS = 0, uu = null, ar = null, dS = 0, rl = 1 / 0, xo = null, Xf = !1, Iv = null, wi = null, yf = !1, Si = null, Yf = 0, du = 0, Rv = null, wf = -1, If = 0; function Zt() { return pe & 6 ? Ze() : wf !== -1 ? wf : wf = Ze() } function Ii(e) { return e.mode & 1 ? pe & 2 && wt !== 0 ? wt & -wt : RM.transition !== null ? (If === 0 && (If = Sb()), If) : (e = be, e !== 0 || (e = window.event, e = e === void 0 ? 16 : Ib(e.type)), e) : 1 } function Nn(e, t, r, n) { if (50 < du) throw du = 0, Rv = null, Error(_(185)); Au(e, r, n), (!(pe & 2) || e !== vt) && (e === vt && (!(pe & 2) && (ap |= r), at === 4 && yi(e, wt)), dr(e, n), r === 1 && pe === 0 && !(t.mode & 1) && (rl = Ze() + 500, np && Pi())) } function dr(e, t) { var r = e.callbackNode; AD(e, t); var n = Pf(e, e === vt ? wt : 0); if (n === 0) r !== null && JE(r), e.callbackNode = null, e.callbackPriority = 0; else if (t = n & -n, e.callbackPriority !== t) { if (r != null && JE(r), t === 1) e.tag === 0 ? IM($C.bind(null, e)) : Gb($C.bind(null, e)), EM(function () { !(pe & 6) && Pi() }), r = null; else { switch (xb(n)) { case 1: r = Bv; break; case 4: r = yb; break; case 16: r = Of; break; case 536870912: r = vb; break; default: r = Of }r = j1(r, M1.bind(null, e)) } e.callbackPriority = t, e.callbackNode = r } } function M1(e, t) { if (wf = -1, If = 0, pe & 6) throw Error(_(327)); var r = e.callbackNode; if (Ya() && e.callbackNode !== r) return null; var n = Pf(e, e === vt ? wt : 0); if (n === 0) return null; if (n & 30 || n & e.expiredLanes || t) t = qf(e, n); else { t = n; var o = pe; pe |= 2; var i = V1(); (vt !== e || wt !== t) && (xo = null, rl = Ze() + 500, Os(e, t)); do try { KM(); break } catch (a) { B1(e, a) } while (1); qv(), Kf.current = i, pe = o, tt !== null ? t = 0 : (vt = null, wt = 0, t = at) } if (t !== 0) { if (t === 2 && (o = ev(e), o !== 0 && (n = o, t = kv(e, o))), t === 1) throw r = ku, Os(e, 0), yi(e, n), dr(e, Ze()), r; if (t === 6) yi(e, n); else { if (o = e.current.alternate, !(n & 30) && !GM(o) && (t = qf(e, n), t === 2 && (i = ev(e), i !== 0 && (n = i, t = kv(e, i))), t === 1)) throw r = ku, Os(e, 0), yi(e, n), dr(e, Ze()), r; switch (e.finishedWork = o, e.finishedLanes = n, t) { case 0: case 1: throw Error(_(345)); case 2: Rs(e, ar, xo); break; case 3: if (yi(e, n), (n & 130023424) === n && (t = dS + 500 - Ze(), 10 < t)) { if (Pf(e, 0) !== 0) break; if (o = e.suspendedLanes, (o & n) !== n) { Zt(), e.pingedLanes |= e.suspendedLanes & o; break } e.timeoutHandle = lv(Rs.bind(null, e, ar, xo), t); break } Rs(e, ar, xo); break; case 4: if (yi(e, n), (n & 4194240) === n) break; for (t = e.eventTimes, o = -1; 0 < n;) { var s = 31 - An(n); i = 1 << s, s = t[s], s > o && (o = s), n &= ~i } if (n = o, n = Ze() - n, n = (120 > n ? 120 : 480 > n ? 480 : 1080 > n ? 1080 : 1920 > n ? 1920 : 3e3 > n ? 3e3 : 4320 > n ? 4320 : 1960 * UM(n / 1960)) - n, 10 < n) { e.timeoutHandle = lv(Rs.bind(null, e, ar, xo), n); break } Rs(e, ar, xo); break; case 5: Rs(e, ar, xo); break; default: throw Error(_(329)) } } } return dr(e, Ze()), e.callbackNode === r ? M1.bind(null, e) : null } function kv(e, t) { var r = uu; return e.current.memoizedState.isDehydrated && (Os(e, t).flags |= 256), e = qf(e, t), e !== 2 && (t = ar, ar = r, t !== null && Av(t)), e } function Av(e) { ar === null ? ar = e : ar.push.apply(ar, e) } function GM(e) { for (var t = e; ;) { if (t.flags & 16384) { var r = t.updateQueue; if (r !== null && (r = r.stores, r !== null)) for (var n = 0; n < r.length; n++) { var o = r[n], i = o.getSnapshot; o = o.value; try { if (!On(i(), o)) return !1 } catch { return !1 } } } if (r = t.child, t.subtreeFlags & 16384 && r !== null) r.return = t, t = r; else { if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return !0; t = t.return } t.sibling.return = t.return, t = t.sibling } } return !0 } function yi(e, t) { for (t &= ~uS, t &= ~ap, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t;) { var r = 31 - An(t), n = 1 << r; e[r] = -1, t &= ~n } } function $C(e) { if (pe & 6) throw Error(_(327)); Ya(); var t = Pf(e, 0); if (!(t & 1)) return dr(e, Ze()), null; var r = qf(e, t); if (e.tag !== 0 && r === 2) { var n = ev(e); n !== 0 && (t = n, r = kv(e, n)) } if (r === 1) throw r = ku, Os(e, 0), yi(e, t), dr(e, Ze()), r; if (r === 6) throw Error(_(345)); return e.finishedWork = e.current.alternate, e.finishedLanes = t, Rs(e, ar, xo), dr(e, Ze()), null } function fS(e, t) { var r = pe; pe |= 1; try { return e(t) } finally { pe = r, pe === 0 && (rl = Ze() + 500, np && Pi()) } } function Bs(e) { Si !== null && Si.tag === 0 && !(pe & 6) && Ya(); var t = pe; pe |= 1; var r = Xr.transition, n = be; try { if (Xr.transition = null, be = 1, e) return e() } finally { be = n, Xr.transition = r, pe = t, !(pe & 6) && Pi() } } function pS() { Rr = ja.current, Me(ja) } function Os(e, t) { e.finishedWork = null, e.finishedLanes = 0; var r = e.timeoutHandle; if (r !== -1 && (e.timeoutHandle = -1, TM(r)), tt !== null) for (r = tt.return; r !== null;) { var n = r; switch (Kv(n), n.tag) { case 1: n = n.type.childContextTypes, n != null && Bf(); break; case 3: el(), Me(cr), Me(Vt), rS(); break; case 5: tS(n); break; case 4: el(); break; case 13: Me(je); break; case 19: Me(je); break; case 10: Qv(n.type._context); break; case 22: case 23: pS() }r = r.return } if (vt = e, tt = e = Ri(e.current, null), wt = Rr = t, at = 0, ku = null, uS = ap = Ms = 0, ar = uu = null, As !== null) { for (t = 0; t < As.length; t++)if (r = As[t], n = r.interleaved, n !== null) { r.interleaved = null; var o = n.next, i = r.pending; if (i !== null) { var s = i.next; i.next = o, n.next = s } r.pending = n } As = null } return e } function B1(e, t) { do { var r = tt; try { if (qv(), Ef.current = $f, Gf) { for (var n = Ue.memoizedState; n !== null;) { var o = n.queue; o !== null && (o.pending = null), n = n.next } Gf = !1 } if (Ds = 0, yt = st = Ue = null, lu = !1, wu = 0, cS.current = null, r === null || r.return === null) { at = 1, ku = t, tt = null; break } e: { var i = e, s = r.return, a = r, l = t; if (t = wt, a.flags |= 32768, l !== null && typeof l == "object" && typeof l.then == "function") { var c = l, u = a, d = u.tag; if (!(u.mode & 1) && (d === 0 || d === 11 || d === 15)) { var f = u.alternate; f ? (u.updateQueue = f.updateQueue, u.memoizedState = f.memoizedState, u.lanes = f.lanes) : (u.updateQueue = null, u.memoizedState = null) } var p = LC(s); if (p !== null) { p.flags &= -257, _C(p, s, a, i, t), p.mode & 1 && PC(i, c, t), t = p, l = c; var y = t.updateQueue; if (y === null) { var g = new Set; g.add(l), t.updateQueue = g } else y.add(l); break e } else { if (!(t & 1)) { PC(i, c, t), mS(); break e } l = Error(_(426)) } } else if (Fe && a.mode & 1) { var S = LC(s); if (S !== null) { !(S.flags & 65536) && (S.flags |= 256), _C(S, s, a, i, t), Xv(tl(l, a)); break e } } i = l = tl(l, a), at !== 4 && (at = 2), uu === null ? uu = [i] : uu.push(i), i = s; do { switch (i.tag) { case 3: i.flags |= 65536, t &= -t, i.lanes |= t; var h = x1(i, l, t); IC(i, h); break e; case 1: a = l; var m = i.type, v = i.stateNode; if (!(i.flags & 128) && (typeof m.getDerivedStateFromError == "function" || v !== null && typeof v.componentDidCatch == "function" && (wi === null || !wi.has(v)))) { i.flags |= 65536, t &= -t, i.lanes |= t; var x = T1(i, a, t); IC(i, x); break e } }i = i.return } while (i !== null) } z1(r) } catch (C) { t = C, tt === r && r !== null && (tt = r = r.return); continue } break } while (1) } function V1() { var e = Kf.current; return Kf.current = $f, e === null ? $f : e } function mS() { (at === 0 || at === 3 || at === 2) && (at = 4), vt === null || !(Ms & 268435455) && !(ap & 268435455) || yi(vt, wt) } function qf(e, t) { var r = pe; pe |= 2; var n = V1(); (vt !== e || wt !== t) && (xo = null, Os(e, t)); do try { $M(); break } catch (o) { B1(e, o) } while (1); if (qv(), pe = r, Kf.current = n, tt !== null) throw Error(_(261)); return vt = null, wt = 0, at } function $M() { for (; tt !== null;)F1(tt) } function KM() { for (; tt !== null && !xD();)F1(tt) } function F1(e) { var t = W1(e.alternate, e, Rr); e.memoizedProps = e.pendingProps, t === null ? z1(e) : tt = t, cS.current = null } function z1(e) { var t = e; do { var r = t.alternate; if (e = t.return, t.flags & 32768) { if (r = zM(r, t), r !== null) { r.flags &= 32767, tt = r; return } if (e !== null) e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null; else { at = 6, tt = null; return } } else if (r = FM(r, t, Rr), r !== null) { tt = r; return } if (t = t.sibling, t !== null) { tt = t; return } tt = t = e } while (t !== null); at === 0 && (at = 5) } function Rs(e, t, r) { var n = be, o = Xr.transition; try { Xr.transition = null, be = 1, XM(e, t, r, n) } finally { Xr.transition = o, be = n } return null } function XM(e, t, r, n) { do Ya(); while (Si !== null); if (pe & 6) throw Error(_(327)); r = e.finishedWork; var o = e.finishedLanes; if (r === null) return null; if (e.finishedWork = null, e.finishedLanes = 0, r === e.current) throw Error(_(177)); e.callbackNode = null, e.callbackPriority = 0; var i = r.lanes | r.childLanes; if (ND(e, i), e === vt && (tt = vt = null, wt = 0), !(r.subtreeFlags & 2064) && !(r.flags & 2064) || yf || (yf = !0, j1(Of, function () { return Ya(), null })), i = (r.flags & 15990) !== 0, r.subtreeFlags & 15990 || i) { i = Xr.transition, Xr.transition = null; var s = be; be = 1; var a = pe; pe |= 4, cS.current = null, WM(e, r), _1(r, e), gM(sv), Lf = !!iv, sv = iv = null, e.current = r, jM(r, e, o), TD(), pe = a, be = s, Xr.transition = i } else e.current = r; if (yf && (yf = !1, Si = e, Yf = o), i = e.pendingLanes, i === 0 && (wi = null), bD(r.stateNode, n), dr(e, Ze()), t !== null) for (n = e.onRecoverableError, r = 0; r < t.length; r++)o = t[r], n(o.value, { componentStack: o.stack, digest: o.digest }); if (Xf) throw Xf = !1, e = Iv, Iv = null, e; return Yf & 1 && e.tag !== 0 && Ya(), i = e.pendingLanes, i & 1 ? e === Rv ? du++ : (du = 0, Rv = e) : du = 0, Pi(), null } function Ya() { if (Si !== null) { var e = xb(Yf), t = Xr.transition, r = be; try { if (Xr.transition = null, be = 16 > e ? 16 : e, Si === null) var n = !1; else { if (e = Si, Si = null, Yf = 0, pe & 6) throw Error(_(331)); var o = pe; for (pe |= 4, F = e.current; F !== null;) { var i = F, s = i.child; if (F.flags & 16) { var a = i.deletions; if (a !== null) { for (var l = 0; l < a.length; l++) { var c = a[l]; for (F = c; F !== null;) { var u = F; switch (u.tag) { case 0: case 11: case 15: cu(8, u, i) }var d = u.child; if (d !== null) d.return = u, F = d; else for (; F !== null;) { u = F; var f = u.sibling, p = u.return; if (O1(u), u === c) { F = null; break } if (f !== null) { f.return = p, F = f; break } F = p } } } var y = i.alternate; if (y !== null) { var g = y.child; if (g !== null) { y.child = null; do { var S = g.sibling; g.sibling = null, g = S } while (g !== null) } } F = i } } if (i.subtreeFlags & 2064 && s !== null) s.return = i, F = s; else e: for (; F !== null;) { if (i = F, i.flags & 2048) switch (i.tag) { case 0: case 11: case 15: cu(9, i, i.return) }var h = i.sibling; if (h !== null) { h.return = i.return, F = h; break e } F = i.return } } var m = e.current; for (F = m; F !== null;) { s = F; var v = s.child; if (s.subtreeFlags & 2064 && v !== null) v.return = s, F = v; else e: for (s = m; F !== null;) { if (a = F, a.flags & 2048) try { switch (a.tag) { case 0: case 11: case 15: sp(9, a) } } catch (C) { Xe(a, a.return, C) } if (a === s) { F = null; break e } var x = a.sibling; if (x !== null) { x.return = a.return, F = x; break e } F = a.return } } if (pe = o, Pi(), Yn && typeof Yn.onPostCommitFiberRoot == "function") try { Yn.onPostCommitFiberRoot(Zf, e) } catch { } n = !0 } return n } finally { be = r, Xr.transition = t } } return !1 } function KC(e, t, r) { t = tl(r, t), t = x1(e, t, 1), e = bi(e, t, 1), t = Zt(), e !== null && (Au(e, 1, t), dr(e, t)) } function Xe(e, t, r) { if (e.tag === 3) KC(e, e, r); else for (; t !== null;) { if (t.tag === 3) { KC(t, e, r); break } else if (t.tag === 1) { var n = t.stateNode; if (typeof t.type.getDerivedStateFromError == "function" || typeof n.componentDidCatch == "function" && (wi === null || !wi.has(n))) { e = tl(r, e), e = T1(t, e, 1), t = bi(t, e, 1), e = Zt(), t !== null && (Au(t, 1, e), dr(t, e)); break } } t = t.return } } function YM(e, t, r) { var n = e.pingCache; n !== null && n.delete(t), t = Zt(), e.pingedLanes |= e.suspendedLanes & r, vt === e && (wt & r) === r && (at === 4 || at === 3 && (wt & 130023424) === wt && 500 > Ze() - dS ? Os(e, 0) : uS |= r), dr(e, t) } function H1(e, t) { t === 0 && (e.mode & 1 ? (t = rf, rf <<= 1, !(rf & 130023424) && (rf = 4194304)) : t = 1); var r = Zt(); e = Ro(e, t), e !== null && (Au(e, t, r), dr(e, r)) } function qM(e) { var t = e.memoizedState, r = 0; t !== null && (r = t.retryLane), H1(e, r) } function QM(e, t) { var r = 0; switch (e.tag) { case 13: var n = e.stateNode, o = e.memoizedState; o !== null && (r = o.retryLane); break; case 19: n = e.stateNode; break; default: throw Error(_(314)) }n !== null && n.delete(t), H1(e, r) } var W1; W1 = function (e, t, r) { if (e !== null) if (e.memoizedProps !== t.pendingProps || cr.current) lr = !0; else { if (!(e.lanes & r) && !(t.flags & 128)) return lr = !1, VM(e, t, r); lr = !!(e.flags & 131072) } else lr = !1, Fe && t.flags & 1048576 && $b(t, zf, t.index); switch (t.lanes = 0, t.tag) { case 2: var n = t.type; bf(e, t), e = t.pendingProps; var o = Qa(t, Vt.current); Xa(t, r), o = oS(null, t, n, e, o, r); var i = iS(); return t.flags |= 1, typeof o == "object" && o !== null && typeof o.render == "function" && o.$$typeof === void 0 ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, ur(n) ? (i = !0, Vf(t)) : i = !1, t.memoizedState = o.state !== null && o.state !== void 0 ? o.state : null, Jv(t), o.updater = ip, t.stateNode = o, o._reactInternals = t, hv(t, n, e, r), t = vv(null, t, n, !0, i, r)) : (t.tag = 0, Fe && i && $v(t), Qt(null, t, o, r), t = t.child), t; case 16: n = t.elementType; e: { switch (bf(e, t), e = t.pendingProps, o = n._init, n = o(n._payload), t.type = n, o = t.tag = JM(n), e = In(n, e), o) { case 0: t = yv(null, t, n, e, r); break e; case 1: t = BC(null, t, n, e, r); break e; case 11: t = DC(null, t, n, e, r); break e; case 14: t = MC(null, t, n, In(n.type, e), r); break e }throw Error(_(306, n, "")) } return t; case 0: return n = t.type, o = t.pendingProps, o = t.elementType === n ? o : In(n, o), yv(e, t, n, o, r); case 1: return n = t.type, o = t.pendingProps, o = t.elementType === n ? o : In(n, o), BC(e, t, n, o, r); case 3: e: { if (w1(t), e === null) throw Error(_(387)); n = t.pendingProps, i = t.memoizedState, o = i.element, Zb(e, t), jf(t, n, null, r); var s = t.memoizedState; if (n = s.element, i.isDehydrated) if (i = { element: n, isDehydrated: !1, cache: s.cache, pendingSuspenseBoundaries: s.pendingSuspenseBoundaries, transitions: s.transitions }, t.updateQueue.baseState = i, t.memoizedState = i, t.flags & 256) { o = tl(Error(_(423)), t), t = VC(e, t, n, r, o); break e } else if (n !== o) { o = tl(Error(_(424)), t), t = VC(e, t, n, r, o); break e } else for (kr = Ci(t.stateNode.containerInfo.firstChild), Ar = t, Fe = !0, kn = null, r = qb(t, null, n, r), t.child = r; r;)r.flags = r.flags & -3 | 4096, r = r.sibling; else { if (Za(), n === o) { t = ko(e, t, r); break e } Qt(e, t, n, r) } t = t.child } return t; case 5: return Jb(t), e === null && fv(t), n = t.type, o = t.pendingProps, i = e !== null ? e.memoizedProps : null, s = o.children, av(n, o) ? s = null : i !== null && av(n, i) && (t.flags |= 32), b1(e, t), Qt(e, t, s, r), t.child; case 6: return e === null && fv(t), null; case 13: return I1(e, t, r); case 4: return eS(t, t.stateNode.containerInfo), n = t.pendingProps, e === null ? t.child = Ja(t, null, n, r) : Qt(e, t, n, r), t.child; case 11: return n = t.type, o = t.pendingProps, o = t.elementType === n ? o : In(n, o), DC(e, t, n, o, r); case 7: return Qt(e, t, t.pendingProps, r), t.child; case 8: return Qt(e, t, t.pendingProps.children, r), t.child; case 12: return Qt(e, t, t.pendingProps.children, r), t.child; case 10: e: { if (n = t.type._context, o = t.pendingProps, i = t.memoizedProps, s = o.value, Le(Hf, n._currentValue), n._currentValue = s, i !== null) if (On(i.value, s)) { if (i.children === o.children && !cr.current) { t = ko(e, t, r); break e } } else for (i = t.child, i !== null && (i.return = t); i !== null;) { var a = i.dependencies; if (a !== null) { s = i.child; for (var l = a.firstContext; l !== null;) { if (l.context === n) { if (i.tag === 1) { l = bo(-1, r & -r), l.tag = 2; var c = i.updateQueue; if (c !== null) { c = c.shared; var u = c.pending; u === null ? l.next = l : (l.next = u.next, u.next = l), c.pending = l } } i.lanes |= r, l = i.alternate, l !== null && (l.lanes |= r), pv(i.return, r, t), a.lanes |= r; break } l = l.next } } else if (i.tag === 10) s = i.type === t.type ? null : i.child; else if (i.tag === 18) { if (s = i.return, s === null) throw Error(_(341)); s.lanes |= r, a = s.alternate, a !== null && (a.lanes |= r), pv(s, r, t), s = i.sibling } else s = i.child; if (s !== null) s.return = i; else for (s = i; s !== null;) { if (s === t) { s = null; break } if (i = s.sibling, i !== null) { i.return = s.return, s = i; break } s = s.return } i = s } Qt(e, t, o.children, r), t = t.child } return t; case 9: return o = t.type, n = t.pendingProps.children, Xa(t, r), o = Yr(o), n = n(o), t.flags |= 1, Qt(e, t, n, r), t.child; case 14: return n = t.type, o = In(n, t.pendingProps), o = In(n.type, o), MC(e, t, n, o, r); case 15: return E1(e, t, t.type, t.pendingProps, r); case 17: return n = t.type, o = t.pendingProps, o = t.elementType === n ? o : In(n, o), bf(e, t), t.tag = 1, ur(n) ? (e = !0, Vf(t)) : e = !1, Xa(t, r), S1(t, n, o), hv(t, n, o, r), vv(null, t, n, !0, e, r); case 19: return R1(e, t, r); case 22: return C1(e, t, r) }throw Error(_(156, t.tag)) }; function j1(e, t) { return gb(e, t) } function ZM(e, t, r, n) { this.tag = e, this.key = r, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = n, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function Kr(e, t, r, n) { return new ZM(e, t, r, n) } function hS(e) { return e = e.prototype, !(!e || !e.isReactComponent) } function JM(e) { if (typeof e == "function") return hS(e) ? 1 : 0; if (e != null) { if (e = e.$$typeof, e === _v) return 11; if (e === Dv) return 14 } return 2 } function Ri(e, t) { var r = e.alternate; return r === null ? (r = Kr(e.tag, t, e.key, e.mode), r.elementType = e.elementType, r.type = e.type, r.stateNode = e.stateNode, r.alternate = e, e.alternate = r) : (r.pendingProps = t, r.type = e.type, r.flags = 0, r.subtreeFlags = 0, r.deletions = null), r.flags = e.flags & 14680064, r.childLanes = e.childLanes, r.lanes = e.lanes, r.child = e.child, r.memoizedProps = e.memoizedProps, r.memoizedState = e.memoizedState, r.updateQueue = e.updateQueue, t = e.dependencies, r.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }, r.sibling = e.sibling, r.index = e.index, r.ref = e.ref, r } function Rf(e, t, r, n, o, i) { var s = 2; if (n = e, typeof e == "function") hS(e) && (s = 1); else if (typeof e == "string") s = 5; else e: switch (e) { case La: return Ps(r.children, o, i, t); case Lv: s = 8, o |= 8; break; case Fy: return e = Kr(12, r, t, o | 2), e.elementType = Fy, e.lanes = i, e; case zy: return e = Kr(13, r, t, o), e.elementType = zy, e.lanes = i, e; case Hy: return e = Kr(19, r, t, o), e.elementType = Hy, e.lanes = i, e; case JC: return lp(r, o, i, t); default: if (typeof e == "object" && e !== null) switch (e.$$typeof) { case QC: s = 10; break e; case ZC: s = 9; break e; case _v: s = 11; break e; case Dv: s = 14; break e; case mi: s = 16, n = null; break e }throw Error(_(130, e == null ? e : typeof e, "")) }return t = Kr(s, r, t, o), t.elementType = e, t.type = n, t.lanes = i, t } function Ps(e, t, r, n) { return e = Kr(7, e, n, t), e.lanes = r, e } function lp(e, t, r, n) { return e = Kr(22, e, n, t), e.elementType = JC, e.lanes = r, e.stateNode = { isHidden: !1 }, e } function My(e, t, r) { return e = Kr(6, e, null, t), e.lanes = r, e } function By(e, t, r) { return t = Kr(4, e.children !== null ? e.children : [], e.key, t), t.lanes = r, t.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, t } function eB(e, t, r, n, o) { this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = xy(0), this.expirationTimes = xy(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = xy(0), this.identifierPrefix = n, this.onRecoverableError = o, this.mutableSourceEagerHydrationData = null } function gS(e, t, r, n, o, i, s, a, l) { return e = new eB(e, t, r, a, l), t === 1 ? (t = 1, i === !0 && (t |= 8)) : t = 0, i = Kr(3, null, null, t), e.current = i, i.stateNode = e, i.memoizedState = { element: n, isDehydrated: r, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Jv(i), e } function tB(e, t, r) { var n = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: Pa, key: n == null ? null : "" + n, children: e, containerInfo: t, implementation: r } } function U1(e) { if (!e) return Ai; e = e._reactInternals; e: { if (Fs(e) !== e || e.tag !== 1) throw Error(_(170)); var t = e; do { switch (t.tag) { case 3: t = t.stateNode.context; break e; case 1: if (ur(t.type)) { t = t.stateNode.__reactInternalMemoizedMergedChildContext; break e } }t = t.return } while (t !== null); throw Error(_(171)) } if (e.tag === 1) { var r = e.type; if (ur(r)) return Ub(e, r, t) } return t } function G1(e, t, r, n, o, i, s, a, l) { return e = gS(r, n, !0, e, o, i, s, a, l), e.context = U1(null), r = e.current, n = Zt(), o = Ii(r), i = bo(n, o), i.callback = t ?? null, bi(r, i, o), e.current.lanes = o, Au(e, o, n), dr(e, n), e } function cp(e, t, r, n) { var o = t.current, i = Zt(), s = Ii(o); return r = U1(r), t.context === null ? t.context = r : t.pendingContext = r, t = bo(i, s), t.payload = { element: e }, n = n === void 0 ? null : n, n !== null && (t.callback = n), e = bi(o, t, s), e !== null && (Nn(e, o, s, i), Tf(e, o, s)), s } function Qf(e) { if (e = e.current, !e.child) return null; switch (e.child.tag) { case 5: return e.child.stateNode; default: return e.child.stateNode } } function XC(e, t) { if (e = e.memoizedState, e !== null && e.dehydrated !== null) { var r = e.retryLane; e.retryLane = r !== 0 && r < t ? r : t } } function yS(e, t) { XC(e, t), (e = e.alternate) && XC(e, t) } function rB() { return null } var $1 = typeof reportError == "function" ? reportError : function (e) { console.error(e) }; function vS(e) { this._internalRoot = e } up.prototype.render = vS.prototype.render = function (e) { var t = this._internalRoot; if (t === null) throw Error(_(409)); cp(e, t, null, null) }; up.prototype.unmount = vS.prototype.unmount = function () { var e = this._internalRoot; if (e !== null) { this._internalRoot = null; var t = e.containerInfo; Bs(function () { cp(null, e, null, null) }), t[Io] = null } }; function up(e) { this._internalRoot = e } up.prototype.unstable_scheduleHydration = function (e) { if (e) { var t = Cb(); e = { blockedOn: null, target: e, priority: t }; for (var r = 0; r < gi.length && t !== 0 && t < gi[r].priority; r++); gi.splice(r, 0, e), r === 0 && wb(e) } }; function SS(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11) } function dp(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable ")) } function YC() { } function nB(e, t, r, n, o) { if (o) { if (typeof n == "function") { var i = n; n = function () { var c = Qf(s); i.call(c) } } var s = G1(t, n, e, 0, null, !1, !1, "", YC); return e._reactRootContainer = s, e[Io] = s.current, xu(e.nodeType === 8 ? e.parentNode : e), Bs(), s } for (; o = e.lastChild;)e.removeChild(o); if (typeof n == "function") { var a = n; n = function () { var c = Qf(l); a.call(c) } } var l = gS(e, 0, !1, null, null, !1, !1, "", YC); return e._reactRootContainer = l, e[Io] = l.current, xu(e.nodeType === 8 ? e.parentNode : e), Bs(function () { cp(t, l, r, n) }), l } function fp(e, t, r, n, o) { var i = r._reactRootContainer; if (i) { var s = i; if (typeof o == "function") { var a = o; o = function () { var l = Qf(s); a.call(l) } } cp(t, s, e, o) } else s = nB(r, t, e, o, n); return Qf(s) } Tb = function (e) { switch (e.tag) { case 3: var t = e.stateNode; if (t.current.memoizedState.isDehydrated) { var r = tu(t.pendingLanes); r !== 0 && (Vv(t, r | 1), dr(t, Ze()), !(pe & 6) && (rl = Ze() + 500, Pi())) } break; case 13: Bs(function () { var n = Ro(e, 1); if (n !== null) { var o = Zt(); Nn(n, e, 1, o) } }), yS(e, 1) } }; Fv = function (e) { if (e.tag === 13) { var t = Ro(e, 134217728); if (t !== null) { var r = Zt(); Nn(t, e, 134217728, r) } yS(e, 134217728) } }; Eb = function (e) { if (e.tag === 13) { var t = Ii(e), r = Ro(e, t); if (r !== null) { var n = Zt(); Nn(r, e, t, n) } yS(e, t) } }; Cb = function () { return be }; bb = function (e, t) { var r = be; try { return be = e, t() } finally { be = r } }; Qy = function (e, t, r) { switch (t) { case "input": if (Uy(e, r), t = r.name, r.type === "radio" && t != null) { for (r = e; r.parentNode;)r = r.parentNode; for (r = r.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < r.length; t++) { var n = r[t]; if (n !== e && n.form === e.form) { var o = rp(n); if (!o) throw Error(_(90)); tb(n), Uy(n, o) } } } break; case "textarea": nb(e, r); break; case "select": t = r.value, t != null && Ua(e, !!r.multiple, t, !1) } }; ub = fS; db = Bs; var oB = { usingClientEntryPoint: !1, Events: [Ou, Ba, rp, lb, cb, fS] }, Qc = { findFiberByHostInstance: ks, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, iB = { bundleType: Qc.bundleType, version: Qc.version, rendererPackageName: Qc.rendererPackageName, rendererConfig: Qc.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: Ao.ReactCurrentDispatcher, findHostInstanceByFiber: function (e) { return e = mb(e), e === null ? null : e.stateNode }, findFiberByHostInstance: Qc.findFiberByHostInstance || rB, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && (Zc = __REACT_DEVTOOLS_GLOBAL_HOOK__, !Zc.isDisabled && Zc.supportsFiber)) try { Zf = Zc.inject(iB), Yn = Zc } catch { } var Zc; Pr.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = oB; Pr.createPortal = function (e, t) { var r = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!SS(t)) throw Error(_(200)); return tB(e, t, null, r) }; Pr.createRoot = function (e, t) { if (!SS(e)) throw Error(_(299)); var r = !1, n = "", o = $1; return t != null && (t.unstable_strictMode === !0 && (r = !0), t.identifierPrefix !== void 0 && (n = t.identifierPrefix), t.onRecoverableError !== void 0 && (o = t.onRecoverableError)), t = gS(e, 1, !1, null, null, r, !1, n, o), e[Io] = t.current, xu(e.nodeType === 8 ? e.parentNode : e), new vS(t) }; Pr.findDOMNode = function (e) { if (e == null) return null; if (e.nodeType === 1) return e; var t = e._reactInternals; if (t === void 0) throw typeof e.render == "function" ? Error(_(188)) : (e = Object.keys(e).join(","), Error(_(268, e))); return e = mb(t), e = e === null ? null : e.stateNode, e }; Pr.flushSync = function (e) { return Bs(e) }; Pr.hydrate = function (e, t, r) { if (!dp(t)) throw Error(_(200)); return fp(null, e, t, !0, r) }; Pr.hydrateRoot = function (e, t, r) { if (!SS(e)) throw Error(_(405)); var n = r != null && r.hydratedSources || null, o = !1, i = "", s = $1; if (r != null && (r.unstable_strictMode === !0 && (o = !0), r.identifierPrefix !== void 0 && (i = r.identifierPrefix), r.onRecoverableError !== void 0 && (s = r.onRecoverableError)), t = G1(t, null, e, 1, r ?? null, o, !1, i, s), e[Io] = t.current, xu(e), n) for (e = 0; e < n.length; e++)r = n[e], o = r._getVersion, o = o(r._source), t.mutableSourceEagerHydrationData == null ? t.mutableSourceEagerHydrationData = [r, o] : t.mutableSourceEagerHydrationData.push(r, o); return new up(t) }; Pr.render = function (e, t, r) { if (!dp(t)) throw Error(_(200)); return fp(null, e, t, !1, r) }; Pr.unmountComponentAtNode = function (e) { if (!dp(e)) throw Error(_(40)); return e._reactRootContainer ? (Bs(function () { fp(null, null, e, !1, function () { e._reactRootContainer = null, e[Io] = null }) }), !0) : !1 }; Pr.unstable_batchedUpdates = fS; Pr.unstable_renderSubtreeIntoContainer = function (e, t, r, n) { if (!dp(r)) throw Error(_(200)); if (e == null || e._reactInternals === void 0) throw Error(_(38)); return fp(e, t, r, !1, n) }; Pr.version = "18.3.1-next-f1338f8080-20240426"
}); var il = wr((s4, Y1) => { "use strict"; function X1() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(X1) } catch (e) { console.error(e) } } X1(), Y1.exports = K1() }); var pp = wr(xS => { "use strict"; var q1 = il(); xS.createRoot = q1.createRoot, xS.hydrateRoot = q1.hydrateRoot; var a4 }); var lw = wr(yp => { "use strict"; var gB = P(), yB = Symbol.for("react.element"), vB = Symbol.for("react.fragment"), SB = Object.prototype.hasOwnProperty, xB = gB.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, TB = { key: !0, ref: !0, __self: !0, __source: !0 }; function aw(e, t, r) { var n, o = {}, i = null, s = null; r !== void 0 && (i = "" + r), t.key !== void 0 && (i = "" + t.key), t.ref !== void 0 && (s = t.ref); for (n in t) SB.call(t, n) && !TB.hasOwnProperty(n) && (o[n] = t[n]); if (e && e.defaultProps) for (n in t = e.defaultProps, t) o[n] === void 0 && (o[n] = t[n]); return { $$typeof: yB, type: e, key: i, ref: s, props: o, _owner: xB.current } } yp.Fragment = vB; yp.jsx = aw; yp.jsxs = aw }); var W = wr((p4, cw) => { "use strict"; cw.exports = lw() }); var MS = wr((oI, Np) => { (function (e, t, r) { typeof Np < "u" && Np.exports ? Np.exports = r() : typeof define == "function" && define.amd ? define(t, r) : e[t] = r() })(oI, "bowser", function () { var e = !0; function t(l) { function c(Q) { var se = l.match(Q); return se && se.length > 1 && se[1] || "" } function u(Q) { var se = l.match(Q); return se && se.length > 1 && se[2] || "" } var d = c(/(ipod|iphone|ipad)/i).toLowerCase(), f = /like android/i.test(l), p = !f && /android/i.test(l), y = /nexus\s*[0-6]\s*/i.test(l), g = !y && /nexus\s*[0-9]+/i.test(l), S = /CrOS/.test(l), h = /silk/i.test(l), m = /sailfish/i.test(l), v = /tizen/i.test(l), x = /(web|hpw)os/i.test(l), C = /windows phone/i.test(l), T = /SamsungBrowser/i.test(l), E = !C && /windows/i.test(l), w = !d && !h && /macintosh/i.test(l), k = !p && !m && !v && !x && /linux/i.test(l), R = u(/edg([ea]|ios)\/(\d+(\.\d+)?)/i), A = c(/version\/(\d+(\.\d+)?)/i), N = /tablet/i.test(l) && !/tablet pc/i.test(l), O = !N && /[^-]mobi/i.test(l), D = /xbox/i.test(l), b; /opera/i.test(l) ? b = { name: "Opera", opera: e, version: A || c(/(?:opera|opr|opios)[\s\/](\d+(\.\d+)?)/i) } : /opr\/|opios/i.test(l) ? b = { name: "Opera", opera: e, version: c(/(?:opr|opios)[\s\/](\d+(\.\d+)?)/i) || A } : /SamsungBrowser/i.test(l) ? b = { name: "Samsung Internet for Android", samsungBrowser: e, version: A || c(/(?:SamsungBrowser)[\s\/](\d+(\.\d+)?)/i) } : /coast/i.test(l) ? b = { name: "Opera Coast", coast: e, version: A || c(/(?:coast)[\s\/](\d+(\.\d+)?)/i) } : /yabrowser/i.test(l) ? b = { name: "Yandex Browser", yandexbrowser: e, version: A || c(/(?:yabrowser)[\s\/](\d+(\.\d+)?)/i) } : /ucbrowser/i.test(l) ? b = { name: "UC Browser", ucbrowser: e, version: c(/(?:ucbrowser)[\s\/](\d+(?:\.\d+)+)/i) } : /mxios/i.test(l) ? b = { name: "Maxthon", maxthon: e, version: c(/(?:mxios)[\s\/](\d+(?:\.\d+)+)/i) } : /epiphany/i.test(l) ? b = { name: "Epiphany", epiphany: e, version: c(/(?:epiphany)[\s\/](\d+(?:\.\d+)+)/i) } : /puffin/i.test(l) ? b = { name: "Puffin", puffin: e, version: c(/(?:puffin)[\s\/](\d+(?:\.\d+)?)/i) } : /sleipnir/i.test(l) ? b = { name: "Sleipnir", sleipnir: e, version: c(/(?:sleipnir)[\s\/](\d+(?:\.\d+)+)/i) } : /k-meleon/i.test(l) ? b = { name: "K-Meleon", kMeleon: e, version: c(/(?:k-meleon)[\s\/](\d+(?:\.\d+)+)/i) } : C ? (b = { name: "Windows Phone", osname: "Windows Phone", windowsphone: e }, R ? (b.msedge = e, b.version = R) : (b.msie = e, b.version = c(/iemobile\/(\d+(\.\d+)?)/i))) : /msie|trident/i.test(l) ? b = { name: "Internet Explorer", msie: e, version: c(/(?:msie |rv:)(\d+(\.\d+)?)/i) } : S ? b = { name: "Chrome", osname: "Chrome OS", chromeos: e, chromeBook: e, chrome: e, version: c(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i) } : /edg([ea]|ios)/i.test(l) ? b = { name: "Microsoft Edge", msedge: e, version: R } : /vivaldi/i.test(l) ? b = { name: "Vivaldi", vivaldi: e, version: c(/vivaldi\/(\d+(\.\d+)?)/i) || A } : m ? b = { name: "Sailfish", osname: "Sailfish OS", sailfish: e, version: c(/sailfish\s?browser\/(\d+(\.\d+)?)/i) } : /seamonkey\//i.test(l) ? b = { name: "SeaMonkey", seamonkey: e, version: c(/seamonkey\/(\d+(\.\d+)?)/i) } : /firefox|iceweasel|fxios/i.test(l) ? (b = { name: "Firefox", firefox: e, version: c(/(?:firefox|iceweasel|fxios)[ \/](\d+(\.\d+)?)/i) }, /\((mobile|tablet);[^\)]*rv:[\d\.]+\)/i.test(l) && (b.firefoxos = e, b.osname = "Firefox OS")) : h ? b = { name: "Amazon Silk", silk: e, version: c(/silk\/(\d+(\.\d+)?)/i) } : /phantom/i.test(l) ? b = { name: "PhantomJS", phantom: e, version: c(/phantomjs\/(\d+(\.\d+)?)/i) } : /slimerjs/i.test(l) ? b = { name: "SlimerJS", slimer: e, version: c(/slimerjs\/(\d+(\.\d+)?)/i) } : /blackberry|\bbb\d+/i.test(l) || /rim\stablet/i.test(l) ? b = { name: "BlackBerry", osname: "BlackBerry OS", blackberry: e, version: A || c(/blackberry[\d]+\/(\d+(\.\d+)?)/i) } : x ? (b = { name: "WebOS", osname: "WebOS", webos: e, version: A || c(/w(?:eb)?osbrowser\/(\d+(\.\d+)?)/i) }, /touchpad\//i.test(l) && (b.touchpad = e)) : /bada/i.test(l) ? b = { name: "Bada", osname: "Bada", bada: e, version: c(/dolfin\/(\d+(\.\d+)?)/i) } : v ? b = { name: "Tizen", osname: "Tizen", tizen: e, version: c(/(?:tizen\s?)?browser\/(\d+(\.\d+)?)/i) || A } : /qupzilla/i.test(l) ? b = { name: "QupZilla", qupzilla: e, version: c(/(?:qupzilla)[\s\/](\d+(?:\.\d+)+)/i) || A } : /chromium/i.test(l) ? b = { name: "Chromium", chromium: e, version: c(/(?:chromium)[\s\/](\d+(?:\.\d+)?)/i) || A } : /chrome|crios|crmo/i.test(l) ? b = { name: "Chrome", chrome: e, version: c(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i) } : p ? b = { name: "Android", version: A } : /safari|applewebkit/i.test(l) ? (b = { name: "Safari", safari: e }, A && (b.version = A)) : d ? (b = { name: d == "iphone" ? "iPhone" : d == "ipad" ? "iPad" : "iPod" }, A && (b.version = A)) : /googlebot/i.test(l) ? b = { name: "Googlebot", googlebot: e, version: c(/googlebot\/(\d+(\.\d+))/i) || A } : b = { name: c(/^(.*)\/(.*) /), version: u(/^(.*)\/(.*) /) }, !b.msedge && /(apple)?webkit/i.test(l) ? (/(apple)?webkit\/537\.36/i.test(l) ? (b.name = b.name || "Blink", b.blink = e) : (b.name = b.name || "Webkit", b.webkit = e), !b.version && A && (b.version = A)) : !b.opera && /gecko\//i.test(l) && (b.name = b.name || "Gecko", b.gecko = e, b.version = b.version || c(/gecko\/(\d+(\.\d+)?)/i)), !b.windowsphone && (p || b.silk) ? (b.android = e, b.osname = "Android") : !b.windowsphone && d ? (b[d] = e, b.ios = e, b.osname = "iOS") : w ? (b.mac = e, b.osname = "macOS") : D ? (b.xbox = e, b.osname = "Xbox") : E ? (b.windows = e, b.osname = "Windows") : k && (b.linux = e, b.osname = "Linux"); function H(Q) { switch (Q) { case "NT": return "NT"; case "XP": return "XP"; case "NT 5.0": return "2000"; case "NT 5.1": return "XP"; case "NT 5.2": return "2003"; case "NT 6.0": return "Vista"; case "NT 6.1": return "7"; case "NT 6.2": return "8"; case "NT 6.3": return "8.1"; case "NT 10.0": return "10"; default: return } } var B = ""; b.windows ? B = H(c(/Windows ((NT|XP)( \d\d?.\d)?)/i)) : b.windowsphone ? B = c(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i) : b.mac ? (B = c(/Mac OS X (\d+([_\.\s]\d+)*)/i), B = B.replace(/[_\s]/g, ".")) : d ? (B = c(/os (\d+([_\s]\d+)*) like mac os x/i), B = B.replace(/[_\s]/g, ".")) : p ? B = c(/android[ \/-](\d+(\.\d+)*)/i) : b.webos ? B = c(/(?:web|hpw)os\/(\d+(\.\d+)*)/i) : b.blackberry ? B = c(/rim\stablet\sos\s(\d+(\.\d+)*)/i) : b.bada ? B = c(/bada\/(\d+(\.\d+)*)/i) : b.tizen && (B = c(/tizen[\/\s](\d+(\.\d+)*)/i)), B && (b.osversion = B); var z = !b.windows && B.split(".")[0]; return N || g || d == "ipad" || p && (z == 3 || z >= 4 && !O) || b.silk ? b.tablet = e : (O || d == "iphone" || d == "ipod" || p || y || b.blackberry || b.webos || b.bada) && (b.mobile = e), b.msedge || b.msie && b.version >= 10 || b.yandexbrowser && b.version >= 15 || b.vivaldi && b.version >= 1 || b.chrome && b.version >= 20 || b.samsungBrowser && b.version >= 4 || b.firefox && b.version >= 20 || b.safari && b.version >= 6 || b.opera && b.version >= 10 || b.ios && b.osversion && b.osversion.split(".")[0] >= 6 || b.blackberry && b.version >= 10.1 || b.chromium && b.version >= 20 ? b.a = e : b.msie && b.version < 10 || b.chrome && b.version < 20 || b.firefox && b.version < 20 || b.safari && b.version < 6 || b.opera && b.version < 10 || b.ios && b.osversion && b.osversion.split(".")[0] < 6 || b.chromium && b.version < 20 ? b.c = e : b.x = e, b } var r = t(typeof navigator < "u" && navigator.userAgent || ""); r.test = function (l) { for (var c = 0; c < l.length; ++c) { var u = l[c]; if (typeof u == "string" && u in r) return !0 } return !1 }; function n(l) { return l.split(".").length } function o(l, c) { var u = [], d; if (Array.prototype.map) return Array.prototype.map.call(l, c); for (d = 0; d < l.length; d++)u.push(c(l[d])); return u } function i(l) { for (var c = Math.max(n(l[0]), n(l[1])), u = o(l, function (d) { var f = c - n(d); return d = d + new Array(f + 1).join(".0"), o(d.split("."), function (p) { return new Array(20 - p.length).join("0") + p }).reverse() }); --c >= 0;) { if (u[0][c] > u[1][c]) return 1; if (u[0][c] === u[1][c]) { if (c === 0) return 0 } else return -1 } } function s(l, c, u) { var d = r; typeof c == "string" && (u = c, c = void 0), c === void 0 && (c = !1), u && (d = t(u)); var f = "" + d.version; for (var p in l) if (l.hasOwnProperty(p) && d[p]) { if (typeof l[p] != "string") throw new Error("Browser version in the minVersion map should be a string: " + p + ": " + String(l)); return i([f, l[p]]) < 0 } return c } function a(l, c, u) { return !s(l, c, u) } return r.isUnsupportedBrowser = s, r.compareVersions = i, r.check = a, r._detect = t, r.detect = t, r }) }); var un = wr((Gle, ig) => { (function () { "use strict"; var e = {}.hasOwnProperty; function t() { for (var o = "", i = 0; i < arguments.length; i++) { var s = arguments[i]; s && (o = n(o, r(s))) } return o } function r(o) { if (typeof o == "string" || typeof o == "number") return o; if (typeof o != "object") return ""; if (Array.isArray(o)) return t.apply(null, o); if (o.toString !== Object.prototype.toString && !o.toString.toString().includes("[native code]")) return o.toString(); var i = ""; for (var s in o) e.call(o, s) && o[s] && (i = n(i, s)); return i } function n(o, i) { return i ? o ? o + " " + i : o + i : o } typeof ig < "u" && ig.exports ? (t.default = t, ig.exports = t) : typeof define == "function" && typeof define.amd == "object" && define.amd ? define("classnames", [], function () { return t }) : window.classNames = t })() }); var xP = wr(rT => { "use strict"; var pH = Symbol.for("react.fragment"); rT.Fragment = pH; rT.jsxDEV = void 0 }); var nT = wr((rue, TP) => { "use strict"; TP.exports = xP() }); var Yg = I(P()), qg = I(pp()); var sB = 0; function q(e, t) { let r = `atom${++sB}`, n = { toString() { return (import.meta.env ? import.meta.env.MODE : void 0) !== "production" && this.debugLabel ? r + ":" + this.debugLabel : r } }; return typeof e == "function" ? n.read = e : (n.init = e, n.read = aB, n.write = lB), t && (n.write = t), n } function aB(e) { return e(this) } function lB(e, t, r) { return t(this, typeof r == "function" ? r(e(this)) : r) } var Q1 = (e, t) => e.unstable_is ? e.unstable_is(t) : t === e, ES = e => "init" in e, TS = e => !!e.write, hp = new WeakMap, CS = e => { var t; return bS(e) && !((t = hp.get(e)) != null && t[1]) }, cB = (e, t) => { let r = hp.get(e); if (r) r[1] = !0, r[0].forEach(n => n(t)); else if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") throw new Error("[Bug] cancelable promise not found") }, uB = e => { if (hp.has(e)) return; let t = [new Set, !1]; hp.set(e, t); let r = () => { t[1] = !0 }; e.then(r, r), e.onCancel = n => { t[0].add(n) } }, bS = e => typeof e?.then == "function", Z1 = e => "v" in e || "e" in e, mp = e => { if ("e" in e) throw e.e; if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && !("v" in e)) throw new Error("[Bug] atom state is not initialized"); return e.v }, tw = (e, t, r) => { r.p.has(e) || (r.p.add(e), t.then(() => { r.p.delete(e) }, () => { r.p.delete(e) })) }, J1 = (e, t, r, n, o) => { var i; if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && n === t) throw new Error("[Bug] atom cannot depend on itself"); r.d.set(n, o.n), CS(r.v) && tw(t, r.v, o), (i = o.m) == null || i.t.add(t), e && dB(e, n, t) }, Lu = () => ({ D: new Map, H: new Set, M: new Set, L: new Set }), Du = (e, t, r) => { e[t].add(r) }, ew = (e, t, r) => { e.D.has(t) || (e.D.set(t, new Set), Du(e, "M", () => { var n; (n = r.m) == null || n.l.forEach(o => Du(e, "M", o)) })) }, dB = (e, t, r) => { let n = e.D.get(t); n && n.add(r) }, fB = (e, t) => e.D.get(t), zs = e => { let t, r = !1, n = o => { try { o() } catch (i) { r || (t = i, r = !0) } }; for (; e.H.size || e.M.size || e.L.size;)e.D.clear(), e.H.forEach(n), e.H.clear(), e.M.forEach(n), e.M.clear(), e.L.forEach(n), e.L.clear(); if (r) throw t }, rw = (...[e, t, r, n]) => { let o = (h, m, v) => { let x = "v" in m, C = m.v, T = CS(m.v) ? m.v : null; if (bS(v)) { uB(v); for (let E of m.d.keys()) tw(h, v, e(E)); m.v = v } else m.v = v; delete m.e, delete m.x, (!x || !Object.is(C, m.v)) && (++m.n, T && cB(T, v)) }, i = (h, m) => { var v; let x = e(m); if (Z1(x) && (x.m && !x.x || Array.from(x.d).every(([R, A]) => i(h, R).n === A))) return x; x.d.clear(); let C = !0, T = R => { if (Q1(m, R)) { let N = e(R); if (!Z1(N)) if (ES(R)) o(R, N, R.init); else throw new Error("no atom init"); return mp(N) } let A = i(h, R); try { return mp(A) } finally { if (C) J1(h, m, x, R, A); else { let N = Lu(); J1(N, m, x, R, A), d(N, m, x), zs(N) } } }, E, w, k = { get signal() { return E || (E = new AbortController), E.signal }, get setSelf() { return (import.meta.env ? import.meta.env.MODE : void 0) !== "production" && !TS(m) && console.warn("setSelf function cannot be used with read-only atom"), !w && TS(m) && (w = (...R) => { if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && C && console.warn("setSelf function cannot be called in sync"), !C) return u(m, ...R) }), w } }; try { let R = t(m, T, k); if (o(m, x, R), bS(R)) { (v = R.onCancel) == null || v.call(R, () => E?.abort()); let A = () => { if (x.m) { let N = Lu(); d(N, m, x), zs(N) } }; R.then(A, A) } return x } catch (R) { return delete x.v, x.e = R, delete x.x, ++x.n, x } finally { C = !1 } }, s = h => mp(i(void 0, h)), a = (h, m, v) => { var x, C; let T = new Map; for (let E of ((x = v.m) == null ? void 0 : x.t) || []) { let w = e(E); w.m && T.set(E, w) } for (let E of v.p) T.set(E, e(E)); return (C = fB(h, m)) == null || C.forEach(E => { T.set(E, e(E)) }), T }, l = (h, m, v) => { let x = [], C = new Set, T = new Set, E = [[m, v]]; for (; E.length > 0;) { let [w, k] = E[E.length - 1]; if (T.has(w)) { E.pop(); continue } if (C.has(w)) { x.push([w, k, k.n]), T.add(w), k.x = !0, E.pop(); continue } C.add(w); for (let [R, A] of a(h, w, k)) w !== R && !C.has(R) && E.push([R, A]) } Du(h, "H", () => { let w = new Set([m]); for (let k = x.length - 1; k >= 0; --k) { let [R, A, N] = x[k], O = !1; for (let D of A.d.keys()) if (D !== R && w.has(D)) { O = !0; break } O && (i(h, R), d(h, R, A), N !== A.n && (ew(h, R, A), w.add(R))), delete A.x } }) }, c = (h, m, ...v) => { let x = !0, C = E => mp(i(h, E)), T = (E, ...w) => { let k = e(E); try { if (Q1(m, E)) { if (!ES(E)) throw new Error("atom not writable"); let R = k.n, A = w[0]; o(E, k, A), d(h, E, k), R !== k.n && (ew(h, E, k), l(h, E, k)); return } else return c(h, E, ...w) } finally { x || zs(h) } }; try { return r(m, C, T, ...v) } finally { x = !1 } }, u = (h, ...m) => { let v = Lu(); try { return c(v, h, ...m) } finally { zs(v) } }, d = (h, m, v) => { if (v.m && !CS(v.v)) { for (let x of v.d.keys()) v.m.d.has(x) || (f(h, x, e(x)).t.add(m), v.m.d.add(x)); for (let x of v.m.d || []) if (!v.d.has(x)) { v.m.d.delete(x); let C = p(h, x, e(x)); C?.t.delete(m) } } }, f = (h, m, v) => { if (!v.m) { i(h, m); for (let x of v.d.keys()) f(h, x, e(x)).t.add(m); if (v.m = { l: new Set, d: new Set(v.d.keys()), t: new Set }, TS(m)) { let x = v.m, C, T = (E, w) => { let k = !0; C = (...R) => { try { return c(E, m, ...R) } finally { k || zs(E) } }; try { return w() } finally { k = !1 } }; Du(h, "L", () => { let E = T(h, () => n(m, (...w) => C(...w))); E && (x.u = w => T(w, E)) }) } } return v.m }, p = (h, m, v) => { if (v.m && !v.m.l.size && !Array.from(v.m.t).some(x => { var C; return (C = e(x).m) == null ? void 0 : C.d.has(m) })) { let x = v.m.u; x && Du(h, "L", () => x(h)), delete v.m; for (let C of v.d.keys()) { let T = p(h, C, e(C)); T?.t.delete(m) } return } return v.m }; return { get: s, set: u, sub: (h, m) => { let v = Lu(), x = e(h), T = f(v, h, x).l; return T.add(m), zs(v), () => { T.delete(m); let E = Lu(); p(E, h, x), zs(E) } }, unstable_derive: h => rw(...h(e, t, r, n)) } }, pB = e => { let t = new WeakMap, r = new Set, n, o = 0, i = e.unstable_derive((l, c, u, d) => (n = l, [f => { let p = t.get(f); if (!p) { let y = l(f); p = new Proxy(y, { set(g, S, h) { return S === "m" && r.add(f), Reflect.set(g, S, h) }, deleteProperty(g, S) { return S === "m" && r.delete(f), Reflect.deleteProperty(g, S) } }), t.set(f, p) } return p }, c, (f, p, y, ...g) => o ? y(f, ...g) : u(f, p, y, ...g), d])), s = i.set; return Object.assign(i, { dev4_get_internal_weak_map: () => ({ get: l => { let c = n(l); if (c.n !== 0) return c } }), dev4_get_mounted_atoms: () => r, dev4_restore_atoms: l => { s({ read: () => null, write: (u, d) => { ++o; try { for (let [f, p] of l) ES(f) && d(f, p) } finally { --o } } }) } }) }, nw = () => { let e = new WeakMap, r = rw(n => { if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && !n) throw new Error("Atom is undefined or null"); let o = e.get(n); return o || (o = { d: new Map, p: new Set, n: 0 }, e.set(n, o)), o }, (n, ...o) => n.read(...o), (n, ...o) => n.write(...o), (n, ...o) => { var i; return (i = n.onMount) == null ? void 0 : i.call(n, ...o) }); return (import.meta.env ? import.meta.env.MODE : void 0) !== "production" ? pB(r) : r }, _u, J = () => (_u || (_u = nw(), (import.meta.env ? import.meta.env.MODE : void 0) !== "production" && (globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = _u), globalThis.__JOTAI_DEFAULT_STORE__ !== _u && console.warn("Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044"))), _u); var Ft = I(P(), 1); var mB = (0, Ft.createContext)(void 0), gp = e => { let t = (0, Ft.useContext)(mB); return e?.store || t || J() }; var IS = e => typeof e?.then == "function", iw = e => { e.status = "pending", e.then(t => { e.status = "fulfilled", e.value = t }, t => { e.status = "rejected", e.reason = t }) }, hB = Ft.default.use || (e => { if (e.status === "pending") throw e; if (e.status === "fulfilled") return e.value; throw e.status === "rejected" ? e.reason : (iw(e), e) }), wS = new WeakMap, ow = e => { let t = wS.get(e); return t || (t = new Promise((r, n) => { let o = e, i = l => c => { o === l && r(c) }, s = l => c => { o === l && n(c) }, a = l => { "onCancel" in l && typeof l.onCancel == "function" && l.onCancel(c => { if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && c === l) throw new Error("[Bug] p is not updated even after cancelation"); IS(c) ? (wS.set(c, t), o = c, c.then(i(c), s(c)), a(c)) : r(c) }) }; e.then(i(e), s(e)), a(e) }), wS.set(e, t)), t }; function ge(e, t) { let r = gp(t), [[n, o, i], s] = (0, Ft.useReducer)(c => { let u = r.get(e); return Object.is(c[0], u) && c[1] === r && c[2] === e ? c : [u, r, e] }, void 0, () => [r.get(e), r, e]), a = n; (o !== r || i !== e) && (s(), a = r.get(e)); let l = t?.delay; if ((0, Ft.useEffect)(() => { let c = r.sub(e, () => { if (typeof l == "number") { let u = r.get(e); IS(u) && iw(ow(u)), setTimeout(s, l); return } s() }); return s(), c }, [r, e, l]), (0, Ft.useDebugValue)(a), IS(a)) { let c = ow(a); return hB(c) } return a } function sw(e, t) { let r = gp(t); return (0, Ft.useCallback)((...o) => { if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && !("write" in e)) throw new Error("not writable atom"); return r.set(e, ...o) }, [r, e]) } var Pt = I(W()), ai = I(P()); var Zw = I(W()), pl = I(P()); var $w = I(P()); var Ye; (function (e) { e.Appear = "appear", e.Hover = "hover", e.Press = "press", e.Focus = "focus", e.ScrollParallax = "scrollParallax", e.ScrollTransform = "scrollTransform", e.Cursor = "cursor", e.Marquee = "marquee", e.Code = "code" })(Ye || (Ye = {})); var St; (function (e) { e.IN_CUBIC = "IN_CUBIC", e.OUT_CUBIC = "OUT_CUBIC", e.INOUT_CUBIC = "INOUT_CUBIC", e.LINEAR = "LINEAR", e.IN_BACK_CUBIC = "IN_BACK_CUBIC", e.OUT_BACK_CUBIC = "OUT_BACK_CUBIC", e.INOUT_BACK_CUBIC = "INOUT_BACK_CUBIC", e.CUSTOM_CUBIC = "CUSTOM_CUBIC", e.GENTLE_SPRING = "GENTLE_SPRING", e.SPRING_PRESET_ONE = "SPRING_PRESET_ONE", e.SPRING_PRESET_TWO = "SPRING_PRESET_TWO", e.SPRING_PRESET_THREE = "SPRING_PRESET_THREE", e.CUSTOM_SPRING = "CUSTOM_SPRING", e.SPRING = "SPRING" })(St || (St = {})); var ze; (function (e) { e.PASS_THROUGH = "PASS_THROUGH", e.NORMAL = "NORMAL", e.DARKEN = "DARKEN", e.MULTIPLY = "MULTIPLY", e.LINEAR_BURN = "LINEAR_BURN", e.COLOR_BURN = "COLOR_BURN", e.LIGHTEN = "LIGHTEN", e.SCREEN = "SCREEN", e.LINEAR_DODGE = "LINEAR_DODGE", e.COLOR_DODGE = "COLOR_DODGE", e.OVERLAY = "OVERLAY", e.SOFT_LIGHT = "SOFT_LIGHT", e.HARD_LIGHT = "HARD_LIGHT", e.DIFFERENCE = "DIFFERENCE", e.EXCLUSION = "EXCLUSION", e.HUE = "HUE", e.SATURATION = "SATURATION", e.COLOR = "COLOR", e.LUMINOSITY = "LUMINOSITY" })(ze || (ze = {})); var Pn; (function (e) { e.LEFT = "LEFT", e.RIGHT = "RIGHT", e.CENTER = "CENTER", e.LEFT_RIGHT = "LEFT_RIGHT", e.SCALE = "SCALE" })(Pn || (Pn = {})); var Ln; (function (e) { e.TOP = "TOP", e.BOTTOM = "BOTTOM", e.CENTER = "CENTER", e.TOP_BOTTOM = "TOP_BOTTOM", e.SCALE = "SCALE" })(Ln || (Ln = {})); var uw; (function (e) { e.SUPER = "SUPER", e.SUB = "SUB", e.NORMAL = "NORMAL" })(uw || (uw = {})); var vp; (function (e) { e.NONE = "NONE", e.STRIKETHROUGH = "STRIKETHROUGH", e.UNDERLINE = "UNDERLINE" })(vp || (vp = {})); var Li; (function (e) { e.ORDERED = "ORDERED", e.UNORDERED = "UNORDERED", e.NONE = "NONE" })(Li || (Li = {})); var sl = { visible: !0, locked: !1, isFixed: !1, scrollBehavior: "SCROLLS" }, Mu = { blendMode: ze.NORMAL, opacity: 1 }, Sp = { constraints: { vertical: Ln.TOP, horizontal: Pn.LEFT }, layoutGrow: 0, layoutAlign: "INHERIT", layoutPositioning: "AUTO", gridColumnAnchorIndex: 0, gridRowAnchorIndex: 0 }, xp = { fills: [], strokes: [], strokeWeight: 1 }, EB = { effects: [] }, fw = { isMask: !1 }, dw = { isBreakpointFrame: !1 }, g4 = { interactions: [] }, CB = { clipsContent: !1, overflowDirection: "NONE", layoutMode: "NONE", primaryAxisSizingMode: "AUTO", counterAxisSizingMode: "AUTO", primaryAxisAlignItems: "MIN", counterAxisAlignItems: "MIN", paddingLeft: 0, paddingRight: 0, paddingTop: 0, paddingBottom: 0, itemSpacing: 0, itemReverseZIndex: !1, strokesIncludedInLayout: !1, counterAxisAlignContent: "AUTO", layoutWrap: "NO_WRAP", counterAxisSpacing: 0 }, RS = { cornerRadius: 0, rectangleCornerRadii: [0, 0, 0, 0], rectangleCornerRadiiIndependent: !1 }, bB = { isInAnimateTree: !1 }, Qr = { ...sl, ...Mu, ...Sp, ...CB, ...RS, ...xp, ...EB, ...fw, ...dw, ...dw, ...bB }, Bu = { ...sl, ...Mu, ...Sp, ...xp, ...fw }, y4 = { ...Bu, ...RS }, pw = { ...Bu, ...RS }, mw = { listSpacing: 0, textAutoResize: "NONE", paragraphIndent: 0, paragraphSpacing: 0, textAlignHorizontal: "LEFT", textAlignVertical: "TOP" }, Vu = { code: void 0, sourceCodeHash: void 0, codeExportName: "default" }; var hw = { ...Qr }, gw = { ...Qr }, yw = { ...Bu }, vw = { ...sl, ...Mu, ...Sp, ...xp }, Sw = { ...Qr }, xw = { ...Qr }, Tw = { ...Qr }, Ew = { ...Qr, type: "REPEATER" }, Cw = { ...Qr, type: "CMS_RICH_TEXT" }, bw = { ...Qr }, ww = { ...pw }, Iw = { ...Bu, ...mw }, Rw = { ...sl, ...Mu }, kw = { ...Qr, type: "WEBPAGE" }, Aw = { ...Qr, type: "CODE_INSTANCE", ...Vu, componentProperties: {} }, Nw = { ...Qr, type: "CODE_LAYER", ...Vu, componentProperties: {} }, Ow = { ...sl, type: "CODE_COMPONENT", ...Vu, componentProperties: {} }, Pw = { type: "CODE_FILE", ...Vu }; function Tp(e) { switch (e.type) { case "COMPONENT": return Object.assign(Object.create(hw), e); case "COMPONENT_SET": return Object.assign(Object.create(gw), e); case "FRAME": return Object.assign(Object.create(Sw), e); case "SLOT": return Object.assign(Object.create(xw), e); case "GROUP": return Object.assign(Object.create(Tw), e); case "IMAGE": return Object.assign(Object.create(vw), e); case "INSTANCE": return Object.assign(Object.create(bw), e); case "RECTANGLE": return Object.assign(Object.create(ww), e); case "SVG": return Object.assign(Object.create(yw), e); case "TEXT": return Object.assign(Object.create(Iw), e); case "VARIABLE": return e; case "VARIABLE_COLLECTION": return e; case "STYLE": return e; case "WIDGET": return Object.assign(Object.create(Rw), e); case "WEBPAGE": return Object.assign(Object.create(kw), e); case "CODE_INSTANCE": return Object.assign(Object.create(Aw), e); case "CODE_LAYER": return Object.assign(Object.create(Nw), e); case "CODE_COMPONENT": return Object.assign(Object.create(Ow), e); case "CODE_FILE": return Object.assign(Object.create(Pw), e); case "REPEATER": return Object.assign(Object.create(Ew), e); case "CMS_RICH_TEXT": return Object.assign(Object.create(Cw), e); default: throw new Error("Unknown node type provided to applyDefaults") } } var Lw; (function (e) { e.MAILCHIMP = "MAILCHIMP", e.GOOGLE_MAP = "GOOGLE_MAP", e.YOUTUBE = "YOUTUBE", e.UNKNOWN = "UNKNOWN", e.GENERIC = "GENERIC" })(Lw || (Lw = {})); var Re; (function (e) { e[e.ADDITION = 0] = "ADDITION", e[e.SUBTRACTION = 1] = "SUBTRACTION", e[e.RESOLVE_VARIANT = 2] = "RESOLVE_VARIANT", e[e.MULTIPLY = 3] = "MULTIPLY", e[e.DIVIDE = 4] = "DIVIDE", e[e.EQUALS = 5] = "EQUALS", e[e.NOT_EQUAL = 6] = "NOT_EQUAL", e[e.LESS_THAN = 7] = "LESS_THAN", e[e.LESS_THAN_OR_EQUAL = 8] = "LESS_THAN_OR_EQUAL", e[e.GREATER_THAN = 9] = "GREATER_THAN", e[e.GREATER_THAN_OR_EQUAL = 10] = "GREATER_THAN_OR_EQUAL", e[e.AND = 11] = "AND", e[e.OR = 12] = "OR", e[e.NOT = 13] = "NOT", e[e.STRINGIFY = 14] = "STRINGIFY", e[e.TERNARY = 15] = "TERNARY", e[e.VAR_MODE_LOOKUP = 16] = "VAR_MODE_LOOKUP", e[e.NEGATE = 17] = "NEGATE", e[e.IS_TRUTHY = 18] = "IS_TRUTHY" })(Re || (Re = {})); function Ep(e) { return e.type === "GRADIENT_LINEAR" || e.type === "GRADIENT_RADIAL" || e.type === "GRADIENT_ANGULAR" || e.type === "GRADIENT_DIAMOND" } function w4(e, t, r) {
  let n = e, o = t.safeParse(e); if (o.success && (n = o.data), !o.success) {
    t.description || console.info("Zod schema provided to parseData has no description. Add a description via .describe for better error messages."); let i = `${t.description || "Zod"} schema error issues`, s = r ? `Debug info:
${JSON.stringify(r, null, 2)}
`: "", a = typeof window > "u"; if (a || !1) {
      if (a) for (let c of o.error.issues) console.error(`[SchemaErrorIssue] ${JSON.stringify({ schemaDescription: t.description, issue: c })}`); throw new Error(`${i}
${s}Issues: ${JSON.stringify(o.error.issues, null, 2)}`)
    } else console.error(i, { issues: o.error.issues, debugInfo: r, data: e })
  } return n
} function _i(e) { return e } var al = _i, _w = _i, Dw = _i; var No = _i, Mw = _i, Cp = _i; var kS = _i, Bw = _i; var te = class extends Error { severity = "high"; errorDetail; constructor(t, r) { super(t), Object.setPrototypeOf(this, te.prototype), r && r instanceof Error && (this.cause = r) } }, Rt = class extends te { constructor(t, r) { super(t, r), this.severity = "low" } }; var AS = "snapshot", NS = "sandbox"; function ye(e, t) { throw new te(t ?? `Uncaught type ${JSON.stringify(e)}`) } function me(e, t) { if (!e) throw new te(`Assertion failure${t ? `: ${t}` : ""}`) } var Vw = new Set(["vectorNetworkBlob", "version"]); function we(e, t, r = !1, n = !1, o = !1) { if (e === t || n && (e instanceof Array && e.length === 0 && t === void 0 || t instanceof Array && t.length === 0 && e === void 0 || !e && !t)) return !0; let i = typeof e; if (typeof t !== i) return !1; if (i === "number") return Number.isNaN(e) || Number.isNaN(t) ? n : r ? !0 : n ? e - t < .01 && e - t > -.01 : e === t; if (i !== "object") return e === t; if (e === null != (t === null)) return !1; if (e === null) return !0; if (e instanceof Array != t instanceof Array) return !1; if (e instanceof Array) return e.length === t.length && e.every((l, c) => we(l, t[c], r, n, o)); let s = Object.keys(e), a = Object.keys(t); return o && (s = s.filter(l => e[l] !== void 0), a = a.filter(l => t[l] !== void 0)), s.length !== a.length || (n && (s = s.filter(l => !Vw.has(l)), a = a.filter(l => !Vw.has(l))), s.sort(), a.sort(), !s.every((l, c) => l === a[c])) ? !1 : s.every(l => we(e[l], t[l], r, n, o)) } var _n = class { map; fallback; disableErrors; constructor(t, r) { this.map = new Map, this.fallback = t, this.disableErrors = r ?? !1 } get(t, r = !1) { return this.map.has(t) ? this.map.get(t) : (r === !1 && this.disableErrors === !1 && (this.map.has(t), `${JSON.stringify(t)}`, void 0), this.fallback) } set(t, r) { if (this.map.has(t)) { this.disableErrors === !1 && (we(this.map.get(t), r), `${JSON.stringify(t)}`, void 0); return } this.map.set(t, r) } _has(t) { return this.map.has(t) } }; var bp = I(P()); var V = class { x; y; constructor(t = 0, r = 0) { this.x = t, this.y = r } clone() { return new V(this.x, this.y) } equals(t) { return this.x === t.x && this.y === t.y } toString() { return `(${this.x}, ${this.y})` } add(t) { return new V(this.x + t.x, this.y + t.y) } static add(...t) { return t.filter(o => o != null).reduce((o, i) => (o.x += i.x, o.y += i.y, o), { x: 0, y: 0 }) } subtract(t) { return new V(this.x - t.x, this.y - t.y) } static subtract(t, r) { return { x: t.x - r.x, y: t.y - r.y } } static scale(t, r) { return { x: t * r.x, y: t * r.y } } static abs(t) { return { x: Math.abs(t.x), y: Math.abs(t.y) } } scale(t) { return new V(this.x * t, this.y * t) } multiply(t) { return new V(this.x * t.x, this.y * t.y) } divide(t) { return new V(this.x / t.x, this.y / t.y) } dot(t) { return V.dot(this, t) } toAngle() { return Math.atan2(this.y, this.x) } static bound(t, r) { return r ? { x: Math.max(Math.min(t.x, r.max.x), r.min.x), y: Math.max(Math.min(t.y, r.max.y), r.min.y) } : t } static dot(t, r) { return t.x * r.x + t.y * r.y } static interpolate(t, r, n) { return { x: t.x + (r.x - t.x) * n, y: t.y + (r.y - t.y) * n } } rounded() { return new V(Math.round(this.x), Math.round(this.y)) } static rounded(t) { return { x: Math.round(t.x), y: Math.round(t.y) } } static size(t) { return Math.sqrt(V.dot(t, t)) } size() { return V.size(this) } unit() { let t = this.size(); return this.scale(t === 0 ? 0 : 1 / t) } distanceTo(t) { return V.size(this.subtract(t)) } static distance(t, r) { return V.size(V.subtract(t, r)) } clamp(t) { return new V(Math.max(t.x, Math.min(t.x + t.width, this.x)), Math.max(t.y, Math.min(t.y + t.height, this.y))) } clampX(t) { return new V(Math.max(t.x, Math.min(t.x + t.width, this.x)), this.y) } clampY(t) { return new V(this.x, Math.max(t.y, Math.min(t.y + t.height, this.y))) } rotate90() { return new V(-this.y, this.x) } hasNaN() { return Number.isNaN(this.x) || Number.isNaN(this.y) } isInvalid() { return this.hasNaN() } static max(t, r) { return new V(Math.max(t.x, r.x), Math.max(t.y, r.y)) } static min(t, r) { return new V(Math.min(t.x, r.x), Math.min(t.y, r.y)) } static infinity() { return new V(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY) } static invalid() { return new V(Number.NaN, Number.NaN) } plus(t) { return new V(this.x + t.x, this.y + t.y) } minus(t) { return new V(this.x - t.x, this.y - t.y) } multiplyBy(t) { return new V(this.x * t, this.y * t) } divideBy(t) { return new V(this.x / t, this.y / t) } transpose() { return new V(this.y, this.x) } }; var $e = class { origin; size; constructor(t = new V, r = new V) { this.origin = t, this.size = r } clone() { return new $e(this.origin.clone(), this.size.clone()) } equals(t) { return this.origin.equals(t.origin) && this.size.equals(t.size) } left() { return this.origin.x } top() { return this.origin.y } right() { return this.size.x === Number.POSITIVE_INFINITY ? Number.POSITIVE_INFINITY : this.origin.x + this.width() } bottom() { return this.size.y === Number.POSITIVE_INFINITY ? Number.POSITIVE_INFINITY : this.origin.y + this.height() } bottomRight() { return new V(this.right(), this.bottom()) } bottomLeft() { return new V(this.left(), this.bottom()) } topLeft() { return new V(this.left(), this.top()) } topRight() { return new V(this.right(), this.top()) } topCenter() { return new V(this.center().x, this.top()) } bottomCenter() { return new V(this.center().x, this.bottom()) } centerLeft() { return new V(this.left(), this.center().y) } centerRight() { return new V(this.right(), this.center().y) } center() { return new V(this.origin.x + this.size.x / 2, this.origin.y + this.size.y / 2) } width() { return this.size.x } height() { return this.size.y } transpose() { return new $e(this.origin.transpose(), this.size.transpose()) } offsetBy(t) { return new $e(this.origin.plus(t), this.size) } scaledBy(t) { return new $e(this.origin.multiplyBy(t), this.size.multiplyBy(t)) } isInvalid() { return this.size.x < 0 || this.size.y < 0 || this.origin.hasNaN() || this.size.hasNaN() } isValid() { return !this.isInvalid() } isEmpty() { return this.isInvalid() ? !0 : this.size.x <= 0 || this.size.y <= 0 } unionWith(t) { let r = V.min(this.origin, t.origin), n = V.max(this.bottomRight(), t.bottomRight()); return r.equals(n) ? this : new $e(r, n.minus(r)) } containsIncludingBoundary(t) { return !this.isEmpty() && !t.isInvalid() && this.left() <= t.left() && this.right() >= t.right() && this.top() <= t.top() && this.bottom() >= t.bottom() } containsPointIncludingBoundary(t) { return !this.isEmpty() && this.left() <= t.x && t.x <= this.right() && this.origin.y <= t.y && t.y <= this.bottom() } intersectWith(t) { if (this.isInvalid() || t.isInvalid()) return $e.invalidRect(); let r = V.max(this.origin, t.origin), n = V.min(this.bottomRight(), t.bottomRight()), o = new $e(r, n.minus(r)); if (o.origin.hasNaN() || o.size.hasNaN()) throw new te("Rect.intersectWith produced a result with NaN"); return o.isInvalid() && (o = $e.invalidRect()), o } hasIntersectionWith(t) { return !this.intersectWith(t).isEmpty() } expand(t) { return this.isInvalid() ? $e.invalidRect() : typeof t == "number" ? $e.fromOriginAndSize(this.origin.x - t, this.origin.y - t, this.size.x + 2 * t, this.size.y + 2 * t) : new $e(this.origin.minus(t), this.size.plus(t.multiplyBy(2))) } static invalidRect() { return new $e(new V(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY), new V(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY)) } static infinite() { return new $e(V.infinity().multiplyBy(-1), V.infinity()) } static fromOriginAndSize(t, r, n, o) { return new $e(new V(t, r), new V(n, o)) } static fromCenterSize(t, r) { let n = r.divideBy(2); return new $e(t.minus(n), r) } static computeBounds(t, r) { let n = V.min(t, r), o = V.max(t, r); return new $e(n, o.minus(n)) } static computeBoundsFromPointArray(t) { let r = V.infinity(), n = V.infinity().multiplyBy(-1); for (let o of t) r = V.min(r, o), n = V.max(n, o); return new $e(r, n.minus(r)) } }; var Oo; (function (e) { e[e.SVG = 0] = "SVG", e[e.CSS = 1] = "CSS" })(Oo || (Oo = {})); var Fw; (function (e) { e[e.SRGB = 0] = "SRGB", e[e.DISPLAY_P3 = 1] = "DISPLAY_P3" })(Fw || (Fw = {})); var zw; (function (e) { e[e.NO_CONVERSION = 0] = "NO_CONVERSION", e[e.SRGB_TO_DISPLAY_P3 = 1] = "SRGB_TO_DISPLAY_P3", e[e.DISPLAY_P3_TO_SRGB = 2] = "DISPLAY_P3_TO_SRGB" })(zw || (zw = {})); var ct = { colorProfile: 0, colorspaceConversion: 0 }; function Te(e) { return String(+e.toPrecision(5)) } var Qn = class { m00; m01; m02; m10; m11; m12; constructor() { this.m00 = this.m01 = this.m02 = this.m10 = this.m11 = this.m12 = 0 } static identity() { return this.fromNumbers(1, 0, 0, 0, 1, 0) } static fromNumbers(t, r, n, o, i, s) { let a = new Qn; return a.m00 = t, a.m01 = r, a.m02 = n, a.m10 = o, a.m11 = i, a.m12 = s, a } static copy(t) { let r = new Qn; return r.m00 = t.m00, r.m01 = t.m01, r.m02 = t.m02, r.m10 = t.m10, r.m11 = t.m11, r.m12 = t.m12, r } static fromArray(t) { let r = new Qn; return r.m00 = t[0][0], r.m01 = t[0][1], r.m02 = t[0][2], r.m10 = t[1][0], r.m11 = t[1][1], r.m12 = t[1][2], r } static fromVectors(t, r, n) { let o = new Qn; return o.m00 = r.x, o.m01 = n.x, o.m02 = t.x, o.m10 = r.y, o.m11 = n.y, o.m12 = t.y, o } axisX() { return new V(this.m00, this.m10) } axisY() { return new V(this.m01, this.m11) } offset() { return new V(this.m02, this.m12) } toDegrees() { return Math.atan2(this.m10, this.m00) * 180 / Math.PI } toScale() { let { m00: t, m01: r, m10: n, m11: o } = this; return new V(Math.sqrt(t * t + n * n), Math.sqrt(r * r + o * o)) } hasNaN() { return this.m00 !== this.m00 && this.m01 !== this.m01 && this.m02 !== this.m02 && this.m10 !== this.m10 && this.m11 !== this.m11 && this.m12 !== this.m12 } translate(t, r) { this.m02 = t * this.m00 + r * this.m01 + this.m02, this.m12 = t * this.m10 + r * this.m11 + this.m12 } rotate(t) { if (t === 0) return; let r = Math.sin(t), n = Math.cos(t), o = n * this.m00 + r * this.m01, i = n * this.m01 - r * this.m00, s = n * this.m10 + r * this.m11, a = n * this.m11 - r * this.m10; this.m00 = o, this.m01 = i, this.m10 = s, this.m11 = a } scale(t, r) { this.m00 *= t, this.m01 *= r, this.m10 *= t, this.m11 *= r } multiply(t) { let r = this.m00 * t.m00 + this.m01 * t.m10, n = this.m00 * t.m01 + this.m01 * t.m11, o = this.m00 * t.m02 + this.m01 * t.m12 + this.m02, i = this.m10 * t.m00 + this.m11 * t.m10, s = this.m10 * t.m01 + this.m11 * t.m11, a = this.m10 * t.m02 + this.m11 * t.m12 + this.m12; this.m00 = r, this.m01 = n, this.m02 = o, this.m10 = i, this.m11 = s, this.m12 = a } determinant() { return this.m00 * this.m11 - this.m01 * this.m10 } invert() { let t = 1 / this.determinant(); if (!isFinite(t)) return !1; let r = Qn.fromNumbers(this.m11 * t, -this.m01 * t, (this.m01 * this.m12 - this.m11 * this.m02) * t, -this.m10 * t, this.m00 * t, (this.m10 * this.m02 - this.m00 * this.m12) * t); return r.hasNaN() ? !1 : (this.m00 = r.m00, this.m01 = r.m01, this.m02 = r.m02, this.m10 = r.m10, this.m11 = r.m11, this.m12 = r.m12, !0) } transformRect(t) { if (t.isInvalid()) return t; if (this.axisX().y === 0 && this.axisY().x === 0) return $e.computeBounds(this.transformPoint(t.topLeft()), this.transformPoint(t.bottomRight())); let r = [this.transformPoint(t.topLeft()), this.transformPoint(t.topRight()), this.transformPoint(t.bottomLeft()), this.transformPoint(t.bottomRight())]; return $e.computeBoundsFromPointArray(r) } transformPoint(t) { return new V(this.m00 * t.x + this.m01 * t.y + this.m02, this.m10 * t.x + this.m11 * t.y + this.m12) } toSvgTransform() { return `matrix(${Te(this.m00)} ${Te(this.m10)} ${Te(this.m01)} ${Te(this.m11)} ${Te(this.m02)} ${Te(this.m12)})` } toMatrix() { return [[this.m00, this.m01, this.m02], [this.m10, this.m11, this.m12]] } transformDirection(t) { return new V(this.m00 * t.x + this.m01 * t.y, this.m10 * t.x + this.m11 * t.y) } inverseTransformPoint(t) { let r = 1 / this.determinant(); if (!isFinite(r)) return V.invalid(); let n = new V((this.m11 * t.x - this.m01 * t.y + this.m01 * this.m12 - this.m11 * this.m02) * r, (this.m00 * t.y - this.m10 * t.x + this.m10 * this.m02 - this.m00 * this.m12) * r); return n.hasNaN() ? V.invalid() : n } static fromTransform(t) { return Qn.fromNumbers(t[0][0], t[0][1], t[0][2], t[1][0], t[1][1], t[1][2]) } toTransform() { return [[this.m00, this.m01, this.m02], [this.m10, this.m11, this.m12]] } }, qe = Qn; Ir(qe, "kEpsilon", 1e-6), Ir(qe, "kEpsilonSqr", Qn.kEpsilon * Qn.kEpsilon); function L(e, t = 3) { return e === void 0 ? e : parseFloat(e.toFixed(t)) } function Ke(e, t = 10 ** -3) { return Math.abs(e) < t ? 0 : e } var Lr = 1e-4; function Po(e) { return typeof structuredClone == "function" ? structuredClone(e) : JSON.parse(JSON.stringify(e)) } function rt(e, t, r = 1e-6) { return Math.abs(e - t) < r } function Hw(e, t) { return ge((0, bp.useMemo)(() => q(e), t)) } function wp(e) { return Object.freeze(e) } function PS(e) { return e.type === "WEBPAGE" } function Zr(e, t) { if (e === void 0) return t; let r = qe.fromTransform(t), n = qe.fromTransform(e); return n.multiply(r), _r(n.toTransform()) } function _r(e) { return [[Ke(e[0][0]), Ke(e[0][1]), Ke(e[0][2])], [Ke(e[1][0]), Ke(e[1][1]), Ke(e[1][2])]] } function ut(e) { return `${L(e * 100, 2)}%` } var OS = [[1, 0, 0], [0, 1, 0]]; function Jr(e) { if (!e) return OS; let r = /matrix\((.*)\)/.exec(e); if (!r) return OS; let n = r[1].split(",").map(o => parseFloat(o)); return n.length !== 6 ? OS : [[n[0], n[2], n[4]], [n[1], n[3], n[5]]] } function Fu(e) { let t = L(e.value, 2); return t === 0 ? "0" : `${t}${e.unit === "PERCENT" ? "%" : "px"}` } function zu() { } var Ww = () => Promise.resolve(); function Ip(e, t, r) { let n = e(t.roots).map(i => e(t.nodeById.get(i))), o = []; return r && (o = n.filter(i => i.name === r)), o.length > 0 ? o : n } function ll(e, t) { let r = (0, bp.useRef)(e); return t(r.current, e) || (r.current = e), r.current } var jw, Rp = e => { jw = e }, Uw = () => jw; var Kw = { title: "" }, Hu = q(!1), Wu = q(null), dl = q(void 0), Gw = q(void 0), fl = q(e => ({ width: e(dl), height: e(Gw) }), (e, t, r) => { t(dl, r.width), t(Gw, r.height) }), IB = { type: "GENERATED_ASSET", url: "", size: { x: 0, y: 0 }, format: "PNG", offsets: { top: { value: 0, unit: "PERCENT" }, right: { value: 0, unit: "PERCENT" }, bottom: { value: 0, unit: "PERCENT" }, left: { value: 0, unit: "PERCENT" } } }, LS = Tp({ type: "FRAME", id: "missing", name: "missing", visible: !1, absoluteBoundingBox: { x: 0, y: 0, width: 0, height: 0 }, size: { x: 0, y: 0 }, relativeTransform: [[1, 0, 1], [0, 1, 1]], children: [] }); function Xw() { let e = { collectionById: new _n(void 0), slugByItemId: new _n(void 0) }; return wp(e), e } function Yw(e, t) { ul(e.collectionById, t.collectionById), ul(e.slugByItemId, t.slugByItemId) } function kp() { let e = { siteSettings: q(Kw), roots: q([]), nodeById: new _n(q(LS)), fonts: new _n(void 0, !0), assets: new _n(q(IB)), assetIdToGuid: new _n(void 0), guidToUrl: new _n(void 0), animateRootIds: new Set, stablePathToAssetHash: new _n(void 0, !0), compiledCode: q(""), globalStyles: q(""), sourceCodeHash: q("") }; return wp(e), wp(e.assets), e } function ju(e, t) { cl(e.siteSettings, t.siteSettings ?? Kw), qw(e.nodeById, t.nodeById, r => kS(r, { nodeId: r?.id })), cl(e.roots, t.roots), ul(e.fonts, t.fonts), ul(e.assetIdToGuid, t.assetIdToGuid), ul(e.guidToUrl, t.guidToUrl), _S(e, t.assets), ul(e.stablePathToAssetHash, t.stablePathToAssetHash), RB(e.animateRootIds, t.animateRootIds), cl(e.compiledCode, t.compiledCode), cl(e.globalStyles, t.globalStyles), cl(e.sourceCodeHash, t.sourceCodeHash) } function _S(e, t) { qw(e.assets, t) } function RB(e, t) { e.clear(), t.forEach(r => { e.add(r) }) } function ul(e, t) { for (let [r, n] of Object.entries(t)) e.set(r, n) } function qw(e, t, r) { for (let [n, o] of Object.entries(t)) { let i = e._has(n) ? e.get(n) : void 0, s = r ? r(o) : o; i === void 0 ? e.set(n, q(s)) : cl(i, s) } } function cl(e, t) { let r = J(); we(r.get(e), t) || r.set(e, t) } function Qw(e, t) { let r = (0, $w.useMemo)(() => q(e), [e]); return ge(t || r) } var Jw = (0, pl.createContext)(null), re = () => (0, pl.useContext)(Jw); function kB() { return re()?.websiteData.siteSettings } function Di() { let e = kB(); return Qw(void 0, e) } function ml() { return re().labs } function Zn() { return re().websiteData.fonts } function eI() { return re().websiteData.sourceCodeHash } function ue() { return re().env } function Ee() { return re().renderOptions } function Jn() { return re().addHeadTag } function tI() { return re().addBodyScript } function Ap() { return re().isFigmake } function AB() { return re().websiteData.globalStyles } function rI() { return ge(AB()) } function DS({ websiteData: e, cmsBundleData: t, getCodeComponentURL: r, history: n, getAssetURL: o, getFontURL: i, getVideoURL: s, children: a, env: l = "preview", transitionAtom: c, setLocation: u, preloadLocation: d, renderOptions: f, withBaseStyles: p = !0, addHeadTag: y, addBodyScript: g, loadComponentsOverNetwork: S = !1, isFigmake: h = !1 }) { let m = ge(e.siteSettings).labs, v = (0, pl.useMemo)(() => ({ websiteData: e, cmsBundleData: t, history: n, getAssetURL: o, getFontURL: i, getVideoURL: s, getCodeComponentURL: r, env: l, transitionAtom: c, setLocation: u, preloadLocation: d, withBaseStyles: p, addHeadTag: y, addBodyScript: g, loadComponentsOverNetwork: S, labs: m, isFigmake: h, renderOptions: f }), [e, t, n, o, i, s, r, l, c, u, d, p, y, g, S, m, h, f]); return ee.state = v, (0, Zw.jsx)(Jw.Provider, { value: v, children: a }) } var ee = { state: null }; var Hs = "-1:-1"; function nI(e) { return e ? (e.localID | 0) >= 0 && (e.sessionID | 0) >= 0 : !1 } function Je(e) { return e ? `${e.sessionID | 0}:${e.localID | 0}` : null } var iI = I(MS()); var NB = "api/figment-proxy/monitor", OB = "sites.runtime_error", PB = "figweb", LB = 100, _B = new Set(["preview", "published"]), DB = async (e, t, r, n) => { if (!e || e === "") return; let o = `${e}/${NB}`; try { await fetch(o, { method: "POST", body: JSON.stringify(t), priority: "low", keepalive: n?.sendAsBeacon, headers: { "Content-Type": "application/json", ...r }, credentials: "omit" }) } catch (i) { console.error(i) } }, MB = () => /iPad/.test(navigator.userAgent) || /Mac/.test(navigator.userAgent) && !/iPhone/.test(navigator.userAgent) && navigator.maxTouchPoints && navigator.maxTouchPoints > 2 || !1, Op; function BS() { if (Op === void 0) try { Op = { ...iI.default.detect(navigator.userAgent), isIpad: MB() } } catch { Op = null } return Op || null } var hl = class { env; rateLimiter; _shouldReportErrors; reportingDomain; analyticsHeaders; userId; bundleId; bundleCreationDate; _cachedInfo; constructor({ env: t, reportingDomain: r, rateLimiter: n, analyticsHeaders: o, bundleId: i, bundleCreationDate: s, userId: a }) { this.reportingDomain = r, this.env = t, this.rateLimiter = n, this.analyticsHeaders = o, this._shouldReportErrors = this.shouldReportErrors(), this.bundleId = i, this.bundleCreationDate = s, this.userId = a } shouldReportErrors = () => { if (!_B.has(this.env)) return !1; try { new URL(this.reportingDomain) } catch { return !1 } return !0 }; getContext = () => ({ page: { path: window.location.pathname, referrer: document.referrer, search: window.location.search, title: document.title, url: window.location.toString() }, userAgent: window.navigator.userAgent, forwardToDatadog: !0 }); reportError = (t, r) => { if (!this._shouldReportErrors || !(t instanceof te) || !this.rateLimiter.tryAdd(1)) return; let n = new Date().toISOString(), o = { event: OB, properties: { errorType: t.name, errorMessage: r ? `[${r}]: ${t.message}` : t.message, stackTrace: t.stack || "", environment: this.env, bundleId: this.bundleId, bundleCreationDate: this.bundleCreationDate, severity: t.severity, errorDetail: t.errorDetail, ...this.getBrowserInfoProps() }, timestamp: n, sentAt: n, context: this.getContext() }, i = { namespace: PB, batched: "1" }; this.userId && (o.userId = this.userId); let s = [{ data: o, figment_metadata: i }]; DB(this.reportingDomain, s, this.analyticsHeaders) }; getBrowserInfoProps = () => { if (!this._cachedInfo) try { let t = BS(); t && (this._cachedInfo = { browser_name: t.name, browser_version: +t.version, os_name: t?.isIpad ? "iPadOS" : t.osname, os_version: t?.isIpad ? 0 : t.osversion }) } catch { this._cachedInfo = {} } return this._cachedInfo }; static init(t) { if (!this._ErrorReporter) for (this._ErrorReporter = new hl(t); this._errorQueue.length;)this.reportError(hl._errorQueue.pop()) } static reset() { this._ErrorReporter = void 0, this._errorQueue = [] } static reportError(t, r) { this._ErrorReporter ? this.enabled && this._ErrorReporter.reportError(t, r) : this._errorQueue.length < LB && this._errorQueue.push(t) } }, ke = hl; Ir(ke, "enabled", !0), Ir(ke, "_ErrorReporter"), Ir(ke, "_errorQueue", []), Ir(ke, "enable", () => hl.enabled = !0), Ir(ke, "disable", () => hl.enabled = !1); var Ws = (e, t) => r => { try { e(r) } catch (n) { throw ke.reportError(n, t), n instanceof te ? new Error(n.message, n) : n } }, gl = (e, t) => r => { try { e(r) } catch (n) { throw ke.reportError(n, t), n instanceof te ? new Error(n.message, n) : n } }; var Hi = I(P()); function X(e, t, r) { let n; if (e) { let o = e.match(/^var\((--[^),\s]+)\)$/); o ? n = o[1] : n = `--${e.replaceAll(" ", "")}` } else t && (n = `--${FB(t)}`); return n ? `var(${n},${r})` : null } function BB(e) { return e.split(" ").map(t => t.toLowerCase()).join("-") } function VB(e) { return e.replace(/./g, t => { let r = t.charCodeAt(0); return /[a-zA-Z0-9_-]/.test(t) || r >= 160 ? t : "\\" + t }) } function FB(e) { return e = BB(e), e = VB(e), e } function zB(e) { return e != null } function VS(e) { return Math.round(e * 255) } function HB(e) { return e.toFixed(2) } function WB(e) { return `${js(e.r)}${js(e.g)}${js(e.b)}` } function jB(e, t = 1) { let { r, g: n, b: o, a: i = 1 } = e; return `${js(r)}${js(n)}${js(o)}${js(i * t)}` } function UB(e, t = 1) { let { r, g: n, b: o, a: i = 1 } = e; return `rgba(${VS(r)}, ${VS(n)}, ${VS(o)}, ${HB(i * t)})` } function sI(e) { let t = e.a; return zB(t) && t !== 1 } function js(e) { return ("00" + Math.round(e * 255).toString(16).toUpperCase()).slice(-2) } function GB(e, t = 1) { if (!sI(e) && t === 1) { let r = WB(e); return r[0] === r[1] && r[2] === r[3] && r[4] === r[5] ? `#${r[0]}${r[2]}${r[4]}` : `#${r}` } else { let r = jB(e, t); return r[0] === r[1] && r[2] === r[3] && r[4] === r[5] && r[6] === r[7] ? `#${r[0]}${r[2]}${r[4]}${r[6]}` : `#${r}` } } var dt = class FS { color; opacity; colorManagement; shouldOutputVariables; variableName; codeSyntax; constructor(t, r = 1, n = ct, o = !1, i, s) { if (this.color = t, this.opacity = r, this.colorManagement = n, this.shouldOutputVariables = o, this.variableName = i, this.codeSyntax = s, t.r > 1 || t.g > 1 || t.b > 1) throw new te(`Expected normalised color values (between 0 and 1) but got (${t.r}, ${t.g}, ${t.b})`) } static fromRGBA(t, r, n, o) { return new FS(t, 1, ct, r, n, o) } get rawColor() { return new FS(this.color, this.opacity, this.colorManagement, this.shouldOutputVariables, this.variableName, this.codeSyntax) } get value() { let t = sI(this.color) || this.opacity !== 1 ? UB(this.color, this.opacity) : GB(this.color); if (this.shouldOutputVariables) { let r = X(this.codeSyntax, this.variableName, t); if (r) return r } return t } equals(t) { return this.value === t.value } }; function lI(e, t, r) { return e + (t - e) * r } function aI(e) { let { a: t, ...r } = e; return { alpha: t, color: r } } function jS(e, t, r) { return Object.keys(e).reduce((n, o) => (n[o] = lI(e[o], t[o], r), n), {}) } function $B(e, t) { return Math.sqrt(((e.r - t.r) ** 2 + (e.b - t.b) ** 2 + (e.g - t.g) ** 2) / 3) } function Uu(e, t) { return Object.keys(e).reduce((r, n) => (r[n] = e[n] * t, r), {}) } function zS(e) { return e ** 2.2 } function HS(e) { return e ** (1 / 2.2) } function Pp(e) { return { r: zS(e.r), g: zS(e.g), b: zS(e.b), a: e.a } } function cI(e) { return { r: HS(e.r), g: HS(e.g), b: HS(e.b), a: e.a } } function Lp(e, t, r) { let n = Pp(e), o = Pp(t), { alpha: i, color: s } = aI(n), { alpha: a, color: l } = aI(o), c = Uu(s, i), u = Uu(l, a), d = lI(i, a, r), f = Uu(jS(c, u, r), 1 / (d || 1)), p = { r: f.r, g: f.g, b: f.b, a: d }; return cI(p) } function yl(e, t, r) { let n = Pp(e), o = Pp(t), i = jS(n, o, r); return cI(i) } function Lo(e, t, r) { return jS(e, t, r) } function WS(e) { let { stop1: t, stop2: r, ...n } = e, o = n.targetInterpolation(t.color, r.color, .5), { a: i, ...s } = o, { a, ...l } = n.actualInterpolation(t.color, r.color, .5); if (n.recursionLimit === 0 || $B(Uu(s, i), Uu(l, a)) <= n.epsilon) return [t, r]; let c = (t.position + r.position) / 2, u = { color: o, position: c }, d = WS({ ...n, stop1: t, stop2: u, recursionLimit: n.recursionLimit - 1 }), f = WS({ ...n, stop1: u, stop2: r, recursionLimit: n.recursionLimit - 1 }); return [...d, ...f.slice(1)] } function _o(e) { let { stops: t, epsilon: r, recursionLimit: n, targetInterpolation: o, actualInterpolation: i } = e, s = []; for (let a = 0; a < t.length - 1; a++) { let l = t[a], c = t[a + 1], u = Math.abs(l.position - c.position) < 1e-8 ? [l, c] : WS({ stop1: l, stop2: c, epsilon: r, recursionLimit: n, targetInterpolation: o, actualInterpolation: i }); a !== 0 && u.shift(), s.push(...u) } return s } function Mi(e) { return `url("data:image/svg+xml;utf8,${e.replace(/#/g, "%23").replace(/"/g, "'").replace(/\n\s*/g, " ").replace(/'[^']*'/g, r => `'${r.slice(1, -1).trim()}'`).replace(/\(\s*/g, "(").replace(/\s*\)/g, ")").replace(/\s*<\s*/g, "<").replace(/\s*\/?>\s*/g, r => r.includes("/") ? "/>" : ">")}")` } function vl(e) {
  return e.map(t => {
    let { color: { r, g: n, b: o, a: i }, position: s } = t, a = Math.round(r * 255), l = Math.round(n * 255), c = Math.round(o * 255), u = Te(i), d = Te(s); return `
    <stop stop-color="rgba(${a},${l},${c},${u})" offset="${d}" />
    `}).join("")
} function KB(e, t, r) { let { color: { r: n, g: o, b: i, a: s } } = e, a = Math.round(n * 255), l = Math.round(o * 255), c = Math.round(i * 255), u = Te(s), d = Te(e.position * 100), f = `rgba(${a}, ${l}, ${c}, ${u})`, p = `${d}%`; if (t) { let y = X(r && e.boundVariables?.color?.resolvedCodeSyntax?.[r], e.boundVariables?.color?.resolvedName, f); if (y) return `${y} ${p}` } return `${f} ${p}` } function _p(e, t = !1, r) { return e.map(n => KB(n, t, r)).join(", ") } var xt = 10; function Do(e) { let { size: t, gradientTransform: r } = e, n = qe.identity(); n.scale(xt, xt), n.scale(2, 2), n.translate(-.5, -.5); let o = qe.copy(n); o.invert(); let i = qe.fromArray(r); i.invert(); let s = qe.copy(i); s.multiply(o); let a = qe.copy(s); a.invert(); let l = qe.identity(); return l.scale(t.width, t.height), l.multiply(s), { uvToUnitGradient: a, unitGradientToShape: l } } function Dp(e) { return [new V(0, 0), new V(xt, 0), new V(xt, xt), new V(0, xt)].map(n => e.transformPoint(n)).reduce((n, o) => (n.x = Math.max(n.x, Math.abs(o.x)), n.y = Math.max(n.y, Math.abs(o.y)), n), { x: -1 / 0, y: -1 / 0 }) } function uI(e, t) { let r = t[1].minus(t[0]), n = e.minus(t[0]); return r.multiplyBy(n.dot(r) / r.dot(r)).plus(t[0]) } var Gu = class dI {
  paint; size; serializationFormat; shouldExpandGradient; shouldOutputVariables; codeSyntaxLanguage; static fromColor({ color: t, opacity: r, shouldOutputVariables: n, codeSyntax: o }) { let i = { r: t.r, g: t.g, b: t.b, a: r * ("a" in t ? t.a : 1) }; return new dI({ gradientTransform: qe.identity().toMatrix(), gradientStops: [{ color: i, position: 0 }, { color: i, position: 1 }] }, ct, { width: 1, height: 1 }, Oo.CSS, n, o) } constructor(t, r, n, o, i, s, a = !0) { this.paint = t, this.size = n, this.serializationFormat = o, this.shouldExpandGradient = a, this.shouldOutputVariables = i, this.codeSyntaxLanguage = s } get valueAsCss() { let { unitGradientToShape: t } = Do({ size: this.size, gradientTransform: this.paint.gradientTransform }), r = { origin: t.transformPoint(new V(-xt, 0)), primary: t.transformPoint(new V(xt, 0)), secondary: t.transformPoint(new V(-xt, xt)) }, n = r.secondary.minus(r.origin), o = new V(-n.y, n.x); o.dot(r.primary.minus(r.origin)) < 0 && (o = o.multiplyBy(-1)); let i = { start: new V(0, 0), end: o }; if (i.end.x < 0) { let u = new V(this.size.width, 0); i.start = i.start.plus(u), i.end = i.end.plus(u) } if (i.end.y < 0) { let u = new V(0, this.size.height); i.start = i.start.plus(u), i.end = i.end.plus(u) } let s = new V(o.x < 0 ? 0 : this.size.width, o.y < 0 ? 0 : this.size.height); i.end = uI(s, [i.start, i.end]); let a = i.end.minus(i.start).toAngle() * (180 / Math.PI), l = this.paint.gradientStops.map(u => { let d = r.origin.add(r.primary.minus(r.origin).multiplyBy(u.position)), p = uI(d, [i.start, i.end]).minus(i.start).size() / i.end.minus(i.start).size(), y = { ...u.color, a: u.color.a * (this.paint.opacity ?? 1) }; return { ...u, color: y, position: Ke(p) } }), c = l; return this.shouldExpandGradient && (c = _o({ stops: l.map(u => ({ ...u })), epsilon: .01, recursionLimit: 5, targetInterpolation: Lo, actualInterpolation: Lp }).map(u => ({ ...u, position: Ke(u.position) }))), `linear-gradient(${a + 90}deg, ${_p(c, this.shouldOutputVariables, this.codeSyntaxLanguage)})` } get valueAsSvg() {
    let { unitGradientToShape: t } = Do({ size: this.size, gradientTransform: this.paint.gradientTransform }), r = _o({ stops: this.paint.gradientStops.map(o => ({ ...o })), epsilon: .01, recursionLimit: 5, targetInterpolation: Lo, actualInterpolation: yl }).map(o => ({ ...o, position: Ke(o.position) })), n = `
    <svg viewBox='0 0 ${Te(this.size.width)} ${Te(this.size.height)}' xmlns='http://www.w3.org/2000/svg' preserveAspectRatio='none'>
      <rect x='0' y='0' height='100%' width='100%' fill='url(#grad)' opacity='${this.paint.opacity ?? 1}' />
      <defs>
        <linearGradient id='grad' gradientUnits='userSpaceOnUse' x1='${-xt}' x2='${xt}' y1='0' y2='0' gradientTransform='${t.toSvgTransform()}'>
          ${vl(r)}
        </linearGradient>
      </defs>
    </svg>
    `; return Mi(n)
  } get value() { return this.serializationFormat === Oo.SVG ? this.valueAsSvg : this.valueAsCss } equals(t) { return this.value === t.value }
}; function XB(e) { let t = [...e]; if (!e.length) return t; if (e[0].position !== 0) { let r = { ...e[e.length - 1] }; r.position -= 1, t.unshift(r) } if (e[e.length - 1].position !== 1) { let r = { ...e[0] }; r.position += 1, t.push(r) } return t } function YB(e) {
  let t = _o({ stops: XB(e.gradientStops), epsilon: .01, recursionLimit: 5, targetInterpolation: Lo, actualInterpolation: Lp }); return `
    <div
      xmlns='http://www.w3.org/1999/xhtml'
      style='
        background-image: conic-gradient(
          from 90deg,
          ${_p(t)}
        );
        opacity:${e.opacity ?? 1};
        height: 100%;
        width: 100%;
      '></div>
  `} function qB(e) {
  let { size: t, paint: r } = e, { uvToUnitGradient: n, unitGradientToShape: o } = Do({ size: t, gradientTransform: r.gradientTransform }), i = Dp(n), s = Math.max(i.x, i.y); return `
    <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 ${Te(t.width)} ${Te(t.height)}' preserveAspectRatio='none'>
      <g transform='${o.toSvgTransform()}'>
        <foreignObject x='${Te(-s)}' y='${Te(-s)}' width='${Te(2 * s)}' height='${Te(2 * s)}'>
          ${YB(r)}
        </foreignObject>
      </g>
    </svg>
    `} var Mp = class { paint; size; constructor(t, r = ct, n) { this.paint = t, this.size = n } get value() { let t = qB({ size: this.size, paint: this.paint }); return Mi(t) } equals(t) { return this.value === t.value } }; var Bp = class {
  paint; size; constructor(t, r = ct, n) { this.paint = t, this.size = n } get value() {
    let t = _o({ stops: this.paint.gradientStops.map(o => ({ ...o })), epsilon: .01, recursionLimit: 5, targetInterpolation: Lo, actualInterpolation: yl }), { unitGradientToShape: r } = Do({ size: this.size, gradientTransform: this.paint.gradientTransform }), n = `
    <svg viewBox='0 0 ${Te(this.size.width)} ${Te(this.size.height)}' xmlns='http://www.w3.org/2000/svg' preserveAspectRatio='none'>
      <rect x='0' y='0' height='100%' width='100%' fill='url(#grad)' opacity='${this.paint.opacity ?? 1}' />
      <defs>
        <radialGradient id='grad' gradientUnits='userSpaceOnUse' cx='0' cy='0' r='${xt}' gradientTransform='${r.toSvgTransform()}'>
          ${vl(t)}
        </radialGradient>
      </defs>
    </svg>
    `; return Mi(n)
  } equals(t) { return this.value === t.value }
}; function QB(e) {
  let { size: t, paint: r } = e, n = _o({ stops: r.gradientStops.map(a => ({ ...a })), epsilon: .01, recursionLimit: 5, targetInterpolation: Lo, actualInterpolation: yl }), { uvToUnitGradient: o, unitGradientToShape: i } = Do({ size: t, gradientTransform: r.gradientTransform }), s = Dp(o); return `
    <svg viewBox='0 0 ${Te(t.width)} ${Te(t.height)}' xmlns='http://www.w3.org/2000/svg' preserveAspectRatio='none'>
      <g transform='${i.toSvgTransform()}' opacity='${r.opacity ?? 1}'>
        <rect height='${Te(s.y)}' width='${Te(s.x)}' fill='url(#grad)' id='quad' shape-rendering='crispEdges' />
        <use href='#quad' transform='scale(1 -1)' />
        <use href='#quad' transform='scale(-1 1)' />
        <use href='#quad' transform='scale(-1 -1)' />
      </g>
      <defs>
        <linearGradient id='grad' gradientUnits='userSpaceOnUse' x2='${.5 * xt}' y2='${.5 * xt}'>
          ${vl(n)}
        </linearGradient>
      </defs>
    </svg>
    `} var Vp = class { paint; size; constructor(t, r = ct, n) { this.size = n, this.paint = t } get value() { let t = QB({ size: this.size, paint: this.paint }); return Mi(t) } equals(t) { return this.value === t.value } }; function $u(e) { return e.length === 1 ? e[0] : e.reduceRight((t, r) => { let n = r.color, o = t.color, i = r.opacity, s = t.opacity, a = i * (1 - s), l = a + s, c = a / l, u = s / l; return new dt({ r: n.r * c + o.r * u, g: n.g * c + o.g * u, b: n.b * c + o.b * u }, l) }) } var US = { [ze.NORMAL]: void 0, [ze.PASS_THROUGH]: void 0, [ze.DARKEN]: "darken", [ze.MULTIPLY]: "multiply", [ze.LINEAR_BURN]: void 0, [ze.COLOR_BURN]: "color-burn", [ze.LIGHTEN]: "lighten", [ze.SCREEN]: "screen", [ze.LINEAR_DODGE]: "plus-lighter", [ze.COLOR_DODGE]: "color-dodge", [ze.OVERLAY]: "overlay", [ze.SOFT_LIGHT]: "soft-light", [ze.HARD_LIGHT]: "hard-light", [ze.DIFFERENCE]: "difference", [ze.EXCLUSION]: "exclusion", [ze.HUE]: "hue", [ze.SATURATION]: "saturation", [ze.COLOR]: "color", [ze.LUMINOSITY]: "luminosity" }; function Sl(e) { if (e) return US[e] } var ZB = e => { let t = ["backgroundImage", "backgroundSize", "backgroundPosition", "backgroundRepeat"], r = { backgroundImage: "none", backgroundSize: "auto auto", backgroundPosition: "0% 0%", backgroundRepeat: "repeat" }, n = {}; t.forEach(i => { let s = e.map(a => a[i]); if (s.some(a => a !== void 0)) { let a = s.map(c => c ?? r[i]), l = a.every(c => c === a[0]); n[i] = l ? a[0] : a.join(", ") } }); let o = e.find(i => i.backgroundColor)?.backgroundColor; return o !== void 0 && (n.backgroundColor = o), n }, JB = (e, t) => { if (e.hasBlendMode || t.hasBlendMode || e.useImageTag || t.useImageTag) return !1; let r = e.uniqueTypes.has("IMAGE"), n = t.uniqueTypes.has("IMAGE"); if (r !== n && (e.opacity !== void 0 || t.opacity !== void 0)) return !1; let o = e.uniqueTypes.size === 1 && r, i = t.uniqueTypes.size === 1 && n; return !(o && i && e.opacity !== t.opacity) }; function Fp(e = [], t, r, n, o) { if (!e.length) return []; let i = []; return e.filter(a => a.visible !== !1).forEach(a => { let l = t2(a, t, r, n, o); if (!l) return; let c = a.blendMode && US[a.blendMode], u = e2(a), d = { hasBlendMode: !!c, useImageTag: fI(l), uniqueTypes: new Set([a.type]), opacity: u }, f = i[i.length - 1], p = f?.comparator; !!f && p && JB(p, d) ? (f.backgrounds.push(l), p.uniqueTypes.add(a.type)) : i.push({ backgrounds: [l], blendMode: c, opacity: u, comparator: d }) }), i.map(({ backgrounds: a, blendMode: l, opacity: c }) => { let u = a.length === 1 && fI(a[0]), d, f, p, y = a.find(S => S instanceof pI); if (y) { a.length > 1 && console.warn("Multiple video fills found in background group. Only the first video fill will be used."); let S = y.value; d = S.styles, p = S.videoProps } else if (u) { let S = a[0].value; d = S.styles, f = S.imageProps } else { let S = a.reverse().map((h, m) => { if (h instanceof dt && a.length > 1 && (n.optimizeForTailwindConversion || m !== a.length - 1) && (h = Gu.fromColor(h)), h instanceof GS) return h.value.styles; if (h instanceof Gu || h instanceof Bp || h instanceof Mp || h instanceof Vp) return { backgroundImage: h.value }; if (h instanceof dt) return { backgroundColor: h.value }; throw new te("Unsupported background type") }); d = ZB(S) } let g = !!f || !!p || c !== void 0; return l !== void 0 && (d.mixBlendMode = l), c !== void 0 && (d.opacity = c), { backgroundStyles: d, imageProps: f, videoProps: p, needsBackgroundDiv: g } }) } function e2(e) { if ((e.type === "VIDEO" || e.type === "IMAGE") && e.opacity !== void 0 && e.opacity !== 1) return L(e.opacity) } function t2(e, t, r, { shouldOutputVariables: n, codeSyntaxLanguage: o, disableImageOptimization: i }, s) { let { type: a } = e, l = ct; if (a === "PATTERN") return null; if (a === "SOLID") return e.color ? new dt(e.color, e.opacity, l, n, e.boundVariables?.color?.resolvedName, o && e.boundVariables?.color?.resolvedCodeSyntax?.[o]) : null; if (a === "VIDEO") return n2(e, t, s); if (a === "IMAGE") return r2(e, t, i, s.disableImageTag); if (Ep(e)) { let { gradientStops: c, transform: u, opacity: d } = e, f = c[0]?.color, p = c[0]?.boundVariables?.color?.resolvedName; if (f && c.every(S => new dt(S.color).equals(new dt(f))) && (!n || c.every(S => S.boundVariables?.color?.resolvedName === p))) return new dt(f, d, l, n, o && c[0]?.boundVariables?.color?.resolvedCodeSyntax?.[o]); let y = { gradientTransform: u, gradientStops: c, opacity: d }, g = ee.state?.renderOptions.preferCssGradients ?? !1; switch (a) { case "GRADIENT_LINEAR": return new Gu(y, l, r, g ? Oo.CSS : Oo.SVG, n, o, !g); case "GRADIENT_RADIAL": return new Bp(y, l, r); case "GRADIENT_ANGULAR": return new Mp(y, l, r); case "GRADIENT_DIAMOND": return new Vp(y, l, r); default: ye(a) } } throw new te(`Unknown paint type: ${a}`) } var GS = class { paint; image; disableImageOptimization; disableImageTag; constructor(t, r, n, o) { this.paint = t, this.image = r, this.disableImageOptimization = n, this.disableImageTag = o } useImageTag() { return this.paint.scaleMode !== "TILE" && !this.disableImageTag } get value() { let { paint: t, image: r, disableImageOptimization: n } = this, o = ee.state.getAssetURL, s = { backgroundImage: `url(${o(r.url)})`, backgroundRepeat: "no-repeat" }, a; switch (t.scaleMode) { case "FILL": s.backgroundSize = "cover", s.backgroundPosition = "50% 50%"; break; case "FIT": s.backgroundSize = "contain", s.backgroundPosition = "50% 50%"; break; case "STRETCH": { let { imageTransform: l } = t; if (!l) s.backgroundSize = "100% 100%", s.backgroundPosition = "bottom"; else { let u = mI(l), { widthPercent: d, heightPercent: f } = u; if (this.useImageTag()) a = u; else { s.backgroundSize = `${ut(d)} ${ut(f)}`; let p = l[0][0] === 1 ? 0 : -l[0][2] / (l[0][0] - 1), y = l[1][1] === 1 ? 0 : -l[1][2] / (l[1][1] - 1); s.backgroundPosition = `${ut(p)} ${ut(y)}` } } break } case "TILE": { let l = t.scalingFactor || 1, c = { width: r.size.x || 100, height: r.size.y || 100 }, u = c.width * l, d = c.height * l, f = `${u}px`, p = `${d}px`; if (!n) { let y = Math.min(c.width, u * 3), g = `url(${o(r.url, { width: u })}) 1x`; for (let S = 2; u * S <= y; S++)g += `, url(${o(r.url, { width: u * S })}) ${S}x`; s.backgroundImage = `image-set(${g})` } s.backgroundSize = t.rotation % 360 === 0 || t.rotation % 360 === 180 ? `${f} ${p}` : `${p} ${f}`, s.backgroundPosition = "0% 0%", s.backgroundRepeat = "repeat"; break } default: ye(t.scaleMode) }if (this.useImageTag()) { let l = { url: r.url, size: r.size, cropDivInfo: a }, { backgroundImage: c, backgroundRepeat: u, backgroundSize: d, backgroundPosition: f, ...p } = s; return { styles: { objectFit: d, objectPosition: f, ...p }, imageProps: l } } return { styles: s } } }; function zp(e) { return e.gifRef || e.imageRef } var r2 = (e, t, r, n) => { let o = t?.[zp(e)]; return o.type, new GS(e, o, r, n) }, fI = e => e instanceof GS && e.useImageTag(), pI = class { paint; video; isDecorative; constructor(t, r, n) { this.paint = t, this.video = r, this.isDecorative = n.isDecorativeImage || !1 } get value() { let { paint: t, video: r } = this, n = {}, o; switch (t.scaleMode) { case "FIT": n.objectFit = "contain"; break; case "FILL": n.objectFit = "cover"; break; case "STRETCH": { let { imageTransform: s } = t; s ? o = mI(s) : n.objectFit = "contain"; break } case "TILE": break }let i = { url: r.url, hash: t.videoRef, autoplay: t.autoplay ?? !1, mediaLoop: t.mediaLoop ?? !1, muted: t.muted ?? !1, showControls: t.showControls ?? !1, cropDivInfo: o, isDecorative: this.isDecorative }; return { styles: n, videoProps: i } } }, n2 = (e, t, r) => { let n = t?.[e.videoRef]; return n.type, new pI(e, n, r) }, mI = e => { let t = 1 / (e[0][0] || 1), r = 1 / (e[1][1] || 1), n = -e[0][2] / (e[0][0] || 1), o = -e[1][2] / (e[1][1] || 1); return { widthPercent: t, heightPercent: r, leftPercent: n, topPercent: o } }; function hI(e, t, r) { let { collectionId: n, itemId: o } = r; me(o !== void 0, "itemId is required for CMS binding context"); let i = e.collectionById.get(n); me(i !== void 0, `collection with id ${n} not found in CMS Data State`); let s = i.itemById[o]; me(s !== void 0, `item with id ${o} not found in CMS Collection ${i.id}`); let a = new Map; s.fields.forEach(c => { a.set(c.fieldSchemaId, c) }); let l = i.fieldSchemas.find(c => c.type === "slug")?.id; return me(l !== void 0, `slug field for item id ${o} not found in CMS Collection ${i.id}`), { item: s, fieldsBySchemaId: a, slugFieldSchemaId: l, guidToUrl: t, fieldBindingProperties: r } } function xl(e, t) { let r = e.fieldsBySchemaId.get(t.fieldSchemaId); if (r !== void 0) return r.value } function gI(e, t) { return e.slugFieldSchemaId === t.fieldSchemaId } function yI(e) { let t = new Date(e); return e === "" || isNaN(t.getTime()) ? { formattedValue: e, originalValue: e } : o2(t, e) } function o2(e, t) { return { formattedValue: e.toLocaleDateString("en-US", { year: "numeric", month: "long", day: "numeric", hour12: !0, timeZone: "UTC" }), originalValue: t } } function i2(e, t) { me(e !== null, "GUID should not be null"); let r = Je(e), n = t.get(r); return me(n !== void 0, `url not in map for GUID ${r}`), me(n?.length > 0, `url empty for GUID ${r}`), n } function vI(e, t) { let r = JSON.parse(e), n = r.guid ? i2(r.guid, t) : r.url; me(n !== void 0, "url is undefined"); let o = r.guid ? "NODE" : "URL"; return { url: n, type: o } } function SI(e, t) { let r = `/${e}`; return { url: t.endsWith(r) && t !== r ? t : `${t}${r}`, type: "NODE" } } function $S(e) { let t = { type: e.type }; return e.type === "NODE" ? t.nodeID = e.url : t.url = e.url, t } function xI(e) { let t = { connectionURL: e.url, connectionType: e.type === "NODE" ? "INTERNAL_NODE" : "URL" }; return t.connectionType === "INTERNAL_NODE" && (t.navigationType = "NAVIGATE"), t } function KS(e, t, r) { let n = xl(e, t); if (n !== void 0) return gI(e, t) ? (me(r !== void 0, `baseUrl is undefined for slug field binding on item ${e.item.id}`), SI(n, r)) : vI(n, e.guidToUrl) } function s2(e, t, r) { if (r.characters) { if (e.type === "TEXT") return e.characters = xl(t, r.characters) ?? "", !0; console.warn(`text binding unsupported for ${e.type} node ${e.id}`) } return !1 } function a2(e, t, r) { if (r.date) if (e.type === "TEXT") { let n = xl(t, r.date); if (n === void 0) return e.characters = "", !0; let o = yI(n); return e.characters = o.formattedValue, !0 } else console.warn(`date in text binding unsupported for ${e.type} node ${e.id}`); return !1 } function l2(e, t, r) { if (r.hyperlink) if (e.type === "TEXT") { let n = KS(t, r.hyperlink, e.style.hyperlink?.nodeID); return n === void 0 ? (e.style.hyperlink = void 0, !1) : (e.style.hyperlink || (e.style.hyperlink = {}), Object.assign(e.style.hyperlink, $S(n)), !0) } else console.warn(`hyperlink binding unsupported for ${e.type} node ${e.id}`); return !1 } function c2(e, t, r) { if (r.richText) if (e.type === "CMS_RICH_TEXT") { let n = xl(t, r.richText); return e.richText = n === void 0 ? "" : n, !0 } else console.warn(`rich text binding unsupported for ${e.type} node ${e.id}`); return !1 } function u2(e, t) { let r = t.fieldBindingProperties.boundCmsVariables; if (!r) return !1; let n = [s2, a2, l2, c2], o = !1; for (let i of n) try { i(e, t, r) && (o = !0) } catch (s) { console.error(`Error applying binding function ${i.name} to node ${e.id}:`, s); continue } return o } function d2(e, t) { let r = t.fieldBindingProperties.styleOverrideTableBoundCmsVariables; if (!r || Object.keys(r).length === 0) return !1; if (e.type !== "TEXT") return console.warn(`styleOverrideTable hyperlink binding unsupported for ${e.type} node ${e.id}`), !1; let n = !1; for (let [o, i] of Object.entries(r)) { let s = e.styleOverrideTable[o]; if (i?.hyperlink && s) { let a = KS(t, i.hyperlink, s.hyperlink?.nodeID); if (a === void 0) { s.hyperlink = void 0, n = !0; continue } s.hyperlink || (s.hyperlink = {}), Object.assign(s.hyperlink, $S(a)), n = !0 } } return n } function f2(e, t) { let r = t.fieldBindingProperties.interactionsBoundCmsVariables; if (!r || Object.entries(r).length === 0) return !1; if (!("interactions" in e)) return console.warn(`interactions not defined for hyperlink prototype interaction binding on node ${e.id}`), !1; let n = !1, o = e.interactions ?? []; for (let i of o) for (let s of i.actions || []) { let a = s.linkParam?.value, l; if (a && "fieldSchemaId" in a ? l = a.fieldSchemaId : s.cmsTarget?.fieldSchemaId && (l = s.cmsTarget?.fieldSchemaId), !!l) { for (let c of r) if (l === c.hyperlink?.fieldSchemaId) { let u = KS(t, c.hyperlink, s.connectionURL); if (u === void 0) { e.interactions?.splice(e.interactions.indexOf(i), 1), n = !0; continue } Object.assign(s, xI(u)), n = !0 } } } return n } function p2(e, t) { let r = t.fieldBindingProperties.fillPaintsBoundCmsVariables; if (!r || Object.entries(r).length === 0) return !1; if (!("fills" in e)) return console.warn(`fills not defined for image fill binding on node ${e.id}`), !1; let n = !1; for (let o of r) { if (!o.boundVariables.image) continue; let i = o.boundVariables.image.fieldSchemaId, s = -1; if (e.fills) { for (let u = 0; u < e.fills.length; u++)if (e.fills[u]?.imageVar?.value?.fieldSchemaId === i) { s = u; break } } if (s === -1) { console.warn(`No fill found with fieldSchemaId ${i} for node ${e.id}`); continue } let a = xl(t, o.boundVariables.image); if (a === void 0) { s !== -1 && (e.fills?.splice(s, 1), n = !0); continue } let c = e.fills[s]; if (c) { let u = JSON.parse(a); c.imageRef = u.image, e.accessibleLabel = u.altText, n = !0 } } return n } function m2(e) { return ["FRAME", "INSTANCE", "RECTANGLE", "TEXT", "CMS_RICH_TEXT"].includes(e) } function TI(e, t, r) { if (!m2(e.type) || !t || !("cmsItemFieldBindingProperties" in e) || !e.cmsItemFieldBindingProperties) return !1; if (!e.cmsItemFieldBindingProperties.itemId) return console.error("Missing itemId for bound node", e.id), !1; let n = hI(t, r, e.cmsItemFieldBindingProperties), o = [u2, d2, f2, p2], i = !1; for (let s of o) try { s(e, n) && (i = !0) } catch (a) { console.error(`Error applying binding function ${s.name} to node ${e.id}:`, a); continue } return i } function EI(e) { let t = Po(e); return t.type = "CMS_RICH_TEXT", t } var bI = I(W()), eo = I(P()); var XS = () => Promise.resolve(), CI = e => { XS = e }, Bi = (e, t) => XS ? XS(e, t) : Promise.resolve(); var Ku = (0, eo.createContext)({ reportError: zu, setMaterializationError: zu }); function wI({ children: e, reportError: t }) { let r = (0, eo.useRef)({ map: new Map, updatedSinceLastRender: !1 }); (0, eo.useEffect)(() => { let i = setInterval(() => { r.current.updatedSinceLastRender && (Bi("updateMaterializationErrors", { errors: Array.from(r.current.map.values()) }), r.current.updatedSinceLastRender = !1) }, 100); return () => clearInterval(i) }, [r]); let n = (0, eo.useCallback)((i, s) => { let a = r.current; s && s.errorMessage ? (console.error(`New error in ${s.nodeName} (${s.nodeId})`, s.errorMessage), a.map.set(i, s), a.updatedSinceLastRender = !0) : a.map.has(i) && (a.map.delete(i), a.updatedSinceLastRender = !0) }, [r]), o = (0, eo.useMemo)(() => ({ reportError: t, setMaterializationError: n }), [t, n]); return (0, bI.jsx)(Ku.Provider, { value: o, children: e }) } var QS = I(P()); var MU = I(P()), K; (function (e) { e.LAYOUT = "layout", e.INSTANCE_SUBTREE = "instanceSubtree", e.NONE = "none" })(K || (K = {})); var UU = I(P()); var YS = { E5FBBA911B2B7A09E649D4BE6CDF8591EAEFC881: !1, "03413F6F08EB5AE8BAC0FFAF722D852F02A991F4": !1, "7464717929BF125D021BA2EC2CE3DD3FDA32FFCA": !1, "8BAC92FC74DBB0B64807FF095C0895624168FBC0": !1 }; function Hp(e) { return e && e.E5FBBA911B2B7A09E649D4BE6CDF8591EAEFC881 !== void 0 ? e.E5FBBA911B2B7A09E649D4BE6CDF8591EAEFC881 : YS.E5FBBA911B2B7A09E649D4BE6CDF8591EAEFC881 } function II(e) { return e && e["03413F6F08EB5AE8BAC0FFAF722D852F02A991F4"] !== void 0 ? e["03413F6F08EB5AE8BAC0FFAF722D852F02A991F4"] : YS["03413F6F08EB5AE8BAC0FFAF722D852F02A991F4"] } function Wp(e) { return e && e["8BAC92FC74DBB0B64807FF095C0895624168FBC0"] !== void 0 ? e["8BAC92FC74DBB0B64807FF095C0895624168FBC0"] : YS["8BAC92FC74DBB0B64807FF095C0895624168FBC0"] } var RI = {}, kI = e => { RI = e }, Tl = () => RI; var h2 = !1, qS = () => !1, Xu = () => { if (qS()) return { ease: () => .5, onAnimationComplete: () => { } } }, g2 = ["transitionToVisible", "transitionToExit", "transitionToAndFromHover", "transitionToAndFromPress", "transitionToAndFromFocus", "transitionBasedOnScrollDirection", "scrollTransformTransition"], AI = e => { let t = Xu(); if (!t) return; let r = { ease: t.ease, duration: 1e4 }; g2.forEach(n => { n in e && e[n] !== void 0 && (e[n] = r) }) }; var y2 = { motion: "easeInOut", css: "ease-in-out" }, v2 = [1, 100, 15], S2 = St.OUT_CUBIC, NI = .3, le; (function (e) { e.VISIBLE = "visible", e.INITIAL = "initial", e.EXIT = "exit", e.SCROLL_DIRECTION = "scrollDirection", e.HOVER = "hover", e.PRESS = "press", e.FOCUS = "focus", e.VISIBLE_SMART_ANIMATE = "visibleSmartAnimate", e.HIDDEN_SMART_ANIMATE = "hiddenSmartAnimate" })(le || (le = {})); function OI(e) { let t = Xu(); if (t) return { ease: t.ease }; let r = e.easingType ?? S2, [n, o, i] = e.easingFunction && e.easingFunction.length >= 3 ? e.easingFunction : v2; switch (r) { case St.LINEAR: return { ease: "linear" }; case St.IN_CUBIC: return { ease: "easeIn" }; case St.OUT_CUBIC: return { ease: "easeOut" }; case St.INOUT_CUBIC: return { ease: "easeInOut" }; case St.IN_BACK_CUBIC: return { ease: "backIn" }; case St.OUT_BACK_CUBIC: return { ease: "backOut" }; case St.INOUT_BACK_CUBIC: return { ease: "backInOut" }; case St.CUSTOM_CUBIC: return { ease: e.easingFunction ? e.easingFunction : y2.motion }; case St.SPRING: case St.CUSTOM_SPRING: case St.GENTLE_SPRING: case St.SPRING_PRESET_ONE: case St.SPRING_PRESET_TWO: case St.SPRING_PRESET_THREE: return { type: "spring", stiffness: o, damping: i, mass: n } } } function El(e) { return (t, r) => e ? `${e} ${r}` : r } var x2 = new Set(Object.values(le)); function T2(e) { let t = [], r = e.filter(o => o !== void 0), n = r.reduce((o, i) => o = { ...o, ...i }); for (let o of r) for (let [i, s] of Dn(o)) if (i === "variants") for (let a in s) x2.has(a) ? we(n.variants?.[a], s[a]) || t.push(`variants: ${a} has been overwritten`) : t.push(`variants: ${a} is not a valid variant`); else we(n[i], s) || t.push(`prop "${i}" has been overwritten`); return t } function PI(e) { if (Hp(ee.state.labs)) return; let t = T2(e); t.length, `${t.join(", ")}` } function LI(e) { let { background: t, backgroundColor: r, backgroundImage: n, backgroundPosition: o, backgroundSize: i, border: s, borderBottom: a, borderBottomColor: l, borderBottomLeftRadius: c, borderBottomRightRadius: u, borderBottomWidth: d, borderColor: f, borderEndEndRadius: p, borderEndStartRadius: y, borderLeft: g, borderLeftColor: S, borderLeftWidth: h, borderRadius: m, borderRight: v, borderRightColor: x, borderRightWidth: C, borderStartEndRadius: T, borderStartStartRadius: E, borderStyle: w, borderTop: k, borderTopColor: R, borderTopLeftRadius: A, borderTopRightRadius: N, borderTopWidth: O, borderWidth: D, boxShadow: b, caretColor: H, clipPath: B, color: z, filter: Q, font: se, fontSize: he, fontSizeAdjust: xe, fontStretch: Oe, fontWeight: Y, fontVariationSettings: $, letterSpacing: oe, lineHeight: ve, opacity: ie, outline: Se, outlineColor: Yt, outlineWidth: li, textDecoration: yn, textDecorationColor: Er, textDecorationThickness: vo, textEmphasis: vn, textEmphasisColor: sr, textShadow: Cr, visibility: Sn, wordSpacing: Lt, ...Ie } = e; return { motionStyles: { background: t, backgroundColor: r, backgroundImage: n, backgroundPosition: o, backgroundSize: i, border: s, borderBottom: a, borderBottomColor: l, borderBottomLeftRadius: c, borderBottomRightRadius: u, borderBottomWidth: d, borderColor: f, borderEndEndRadius: p, borderEndStartRadius: y, borderLeft: g, borderLeftColor: S, borderLeftWidth: h, borderRadius: m, borderRight: v, borderRightColor: x, borderRightWidth: C, borderStartEndRadius: T, borderStartStartRadius: E, borderStyle: w, borderTop: k, borderTopColor: R, borderTopLeftRadius: A, borderTopRightRadius: N, borderTopWidth: O, borderWidth: D, boxShadow: b, caretColor: H, clipPath: B, color: z, filter: Q, font: se, fontSize: he, fontSizeAdjust: xe, fontStretch: Oe, fontWeight: Y, fontVariationSettings: $, letterSpacing: oe, lineHeight: ve, opacity: ie, outline: Se, outlineColor: Yt, outlineWidth: li, textDecoration: yn, textDecorationColor: Er, textDecorationThickness: vo, textEmphasis: vn, textEmphasisColor: sr, textShadow: Cr, visibility: Sn, wordSpacing: Lt }, cssStyles: Ie } } var ZS = -1, bl = (e, t, r, n, o, i) => { if (e === K.NONE) return { motionTransitionProps: void 0, cssStyles: r }; let s = e === K.INSTANCE_SUBTREE, { motionStyles: a, cssStyles: l } = s ? LI(r) : { motionStyles: {}, cssStyles: r }, c = _I(a), { correctlyTypedStyles: u, incorrectlyTypedStyles: d } = DI(c), f = s ? { [le.VISIBLE_SMART_ANIMATE]: y => Cl(u, t, y, o), [le.HIDDEN_SMART_ANIMATE]: y => Cl(u, 0, y, o), ...n } : n; return { motionTransitionProps: { ...s ? { animate: le.VISIBLE_SMART_ANIMATE, exit: le.HIDDEN_SMART_ANIMATE, variants: f } : {}, ...o ? { ...s ? { initial: le.HIDDEN_SMART_ANIMATE, onAnimationComplete: i } : {}, onLayoutAnimationComplete: i, transition: { duration: o.durationSeconds, ...o.motionAnimationData } } : { transition: { layout: { duration: 0 } } } }, cssStyles: { ...l, ...d } } }; function Cl(e, t, r, n) { let o = r?.durationSeconds ?? n?.durationSeconds ?? 0, i = r?.motionAnimationData ?? n?.motionAnimationData ?? {}; return { ...e, opacity: t, transition: { duration: o, ...i } } } function _I(e) { let t, r = { ...e }; for (t in r) { let n = r[t]; n == null && delete r[t] } return r } function DI(e) { let { mask: t, alignmentBaseline: r, fillRule: n, strokeLinecap: o, strokeLinejoin: i, ...s } = e; return { correctlyTypedStyles: s, incorrectlyTypedStyles: { mask: t, alignmentBaseline: r, fillRule: n, strokeLinecap: o, strokeLinejoin: i } } } function Mo(e, t, r, n) { return e !== K.NONE ? { layout: n ? "position" : !0, layoutDependency: t?.id ?? ZS, transformTemplate: r ? El(r) : void 0 } : void 0 } function MI(e, t) { return { mode: "popLayout", custom: e, onExitComplete: t } } function kt(e) { return QS.default.useCallback(() => { e?.layout || e?.onTransitionEnd(e?.id) }, [e]) } function BI(e, t, r, n) { if (r) return K.NONE; let o = n?.smartAnimateType ?? K.NONE; return e ? K.INSTANCE_SUBTREE : o !== K.NONE ? o : t ? K.LAYOUT : K.NONE } var Bo = (e, t) => Boolean(e === K.INSTANCE_SUBTREE && t), VI = (e, t, r, n) => { let o = _I(e), { correctlyTypedStyles: i } = DI(o), s = { [le.VISIBLE_SMART_ANIMATE]: l => Cl(i, 1, l, r), [le.HIDDEN_SMART_ANIMATE]: l => Cl({}, 0, l, r) }; return { motionTransitionProps: { animate: t ? le.VISIBLE_SMART_ANIMATE : "", exit: le.HIDDEN_SMART_ANIMATE, variants: s, ...r ? { initial: le.HIDDEN_SMART_ANIMATE, onAnimationComplete: n, onLayoutAnimationComplete: n, transition: { duration: r.durationSeconds, ...r.motionAnimationData } } : { transition: { duration: 0 } } }, cssStyles: {} } }, FI = (e, t, r) => { if (e === K.NONE) return { motionTransitionProps: void 0, cssStyles: {} }; let n = e === K.INSTANCE_SUBTREE, o = { [le.VISIBLE_SMART_ANIMATE]: s => Cl({}, 1, s, t), [le.HIDDEN_SMART_ANIMATE]: s => Cl({}, 0, s, t) }; return { motionTransitionProps: { ...n ? { animate: le.VISIBLE_SMART_ANIMATE, exit: le.HIDDEN_SMART_ANIMATE, variants: o } : {}, ...t ? { ...n ? { initial: le.HIDDEN_SMART_ANIMATE, onAnimationComplete: r } : {}, onLayoutAnimationComplete: r, transition: { duration: t.durationSeconds, ...t.motionAnimationData } } : { transition: { duration: 0 } } }, cssStyles: {} } }; function wl() { return QS.default.useRef(0) } var Gs = I(P()); function jp(e, ...t) { let r = ""; return e.forEach((n, o) => { r += n + (t[o] || "") }), r } var Rl = I(P()); var U = [""], JS = { transparent: U }, E2 = { "-webkit-text-fill-color": { partialSupportOk: !0, values: { ...JS } }, "-ms-overflow-style": { partialSupportOk: !0, values: { none: !0 } }, "-webkit-box-orient": { alternateName: "box-orient", partialSupportOk: !0, values: { vertical: U } } }, zI = { properties: { "align-items": { values: { "flex-start": ["flex_context"], "flex-end": ["flex_context"], center: U, baseline: ["flex_context.baseline"], start: ["grid_context.start_end"], end: ["grid_context.start_end"] }, except: ["flex_context.last_baseline", "flex_context.safe_unsafe", "flex_context.start_end"] }, "align-self": { values: { "flex-start": ["flex_context"], "flex-end": ["flex_context"], stretch: ["flex_context.stretch"], center: U }, except: ["flex_context.last_baseline", "flex_context.safe_unsafe", "position_absolute_context"] }, "align-content": { values: { "flex-start": ["flex_context"], "flex-end": ["flex_context"], center: U, "space-between": ["flex_context"], baseline: ["flex_context.baseline"], stretch: ["flex_context.stretch"] }, except: ["flex_context.last_baseline", "flex_context.safe_unsafe", "flex_context.start_end", "multicol_context", "block_context"] }, animation: { values: { scroll: U, linear: U, none: U }, except: ["animation-timeline_included"] }, "animation-play-state": {}, "animation-delay": {}, "animation-direction": {}, "animation-timing-function": {}, "aspect-ratio": { values: { auto: !0 } }, "backdrop-filter": {}, background: { values: { none: U } }, "background-clip": { values: { "padding-box": !0, text: !0 } }, "background-color": {}, "background-image": { values: { none: !0 } }, "background-position": { values: { bottom: !0 } }, "background-repeat": { values: { repeat: !0, "no-repeat": !0 } }, "background-size": { values: { auto: !0, contain: !0, cover: !0 } }, border: { values: { none: U, solid: U } }, "border-bottom-left-radius": {}, "border-bottom-right-radius": {}, "border-bottom-width": {}, "border-bottom-style": { values: { solid: U, dashed: U, none: U } }, "border-bottom-color": {}, "border-color": { values: { ...JS } }, "border-left-width": {}, "border-radius": {}, "border-right-width": {}, "border-style": { values: { solid: !0, dashed: !0, none: !0 } }, "border-top-left-radius": {}, "border-top-right-radius": {}, "border-top-width": {}, bottom: { values: { auto: !0 } }, "box-shadow": { values: { inset: !0 } }, "box-sizing": { values: { "border-box": !0 } }, color: { values: { revert: U } }, "column-gap": {}, content: { except: ["none_applies_to_elements", "alt_text"] }, cursor: { values: { pointer: !0, none: !0 }, except: ["url_positioning_syntax"] }, direction: { values: { ltr: !0, rtl: !0 }, except: ["vertical_slider_direction"] }, display: { values: { block: !0, "inline-block": !0, grid: !0, flex: !0, contents: !0, none: !0, "inline-grid": !0, "-webkit-box": !0 }, except: ["contents.contents_unusual", "contents.focusable_elements", "none.option_is_hidden", "is_transitionable", "keyframe_animatable", "multi-keyword_values"] }, filter: {}, flex: { values: { auto: U } }, "flex-direction": { values: { column: !0, "column-reverse": !0, row: !0, "row-reverse": !0 } }, "flex-shrink": {}, "flex-wrap": { values: { wrap: !0 } }, "font-family": { values: { serif: U, "sans-serif": U } }, "font-feature-settings": {}, "font-size": {}, "font-style": { values: { italic: !0, normal: !0 } }, "font-synthesis": { values: { none: !0 }, partialSupportOk: !0 }, "font-variant-caps": { values: { normal: !0, "small-caps": !0, "all-small-caps": !0 } }, "font-variation-settings": { values: { normal: U } }, "font-weight": { values: { normal: !0, bold: !0 } }, gap: {}, "grid-column": { values: { span: U } }, "grid-row": { values: { span: U } }, "grid-template-columns": { values: { "max-content": !0 } }, "grid-template-rows": { values: { "max-content": !0 } }, height: { values: { auto: !0 }, except: ["fit-content_function"] }, inset: {}, isolation: { values: { isolate: U } }, "justify-content": { values: { "flex-start": ["flex_context"], "flex-end": ["flex_context"], center: U, "space-between": ["flex_context"] }, except: ["flex_context.safe_unsafe", "flex_context.start_end"] }, "justify-items": { values: { "flex-start": ["flex_context"], "flex-end": ["flex_context"], center: U, baseline: ["flex_context"], start: ["grid_context", "flex_context"], end: ["grid_context", "flex_context"] } }, "justify-self": { values: { "flex-start": ["grid_context"], "flex-end": ["grid_context"], center: U, baseline: ["grid_context"], start: ["grid_context"], end: ["grid_context"] }, except: ["position_absolute_context"] }, left: { values: { auto: !0 } }, "letter-spacing": {}, "line-height": { values: { normal: !0 } }, "list-style": { values: { none: U } }, "list-style-position": { values: { inside: !0 } }, "list-style-type": { values: { "lower-alpha": !0, "lower-roman": !0, decimal: !0, circle: !0 } }, margin: { values: { auto: !0 } }, "margin-bottom": { values: { auto: !0 } }, "margin-inline-start": {}, "margin-left": { values: { auto: !0 } }, "margin-right": { values: { auto: !0 } }, "margin-top": { values: { auto: !0 } }, "mask-image": { needsPrefix: "-webkit-" }, "mask-mode": { values: { alpha: !0, luminance: !0 } }, "mask-size": { needsPrefix: "-webkit-" }, "mask-position": { needsPrefix: "-webkit-", values: { auto: U } }, "mask-repeat": { needsPrefix: "-webkit-", values: { "no-repeat": U } }, "mask-clip": { needsPrefix: "-webkit-", values: { "no-clip": U } }, "mask-origin": { needsPrefix: "-webkit-" }, "mask-composite": { values: { intersect: !0 } }, "mask-type": { values: { alpha: !0, luminance: !0 } }, "max-width": { values: { none: !0 }, except: ["fit-content_function"] }, "max-height": { except: ["fit-content_function"] }, "min-width": { values: { auto: !0 }, except: ["fit-content_function"] }, "min-height": { except: ["fit-content_function"] }, "mix-blend-mode": { values: { darken: U, multiply: U, "plus-lighter": !0, "color-burn": U, lighten: U, screen: U, "color-dodge": U, overlay: U, "soft-light": U, "hard-light": U, difference: U, exclusion: U, huge: U, saturation: U, color: U, luminosity: U } }, "object-fit": { values: { contain: !0, cover: !0 } }, "object-position": { values: { bottom: U } }, opacity: {}, order: {}, overflow: { values: { auto: !0, hidden: !0, clip: !0, scroll: !0, visible: !0 } }, "overflow-x": { values: { auto: !0, hidden: !0, clip: !0, scroll: !0, visible: !0 } }, "overflow-y": { values: { auto: !0, hidden: !0, clip: !0, scroll: !0, visible: !0 } }, padding: {}, "padding-bottom": {}, "padding-inline-start": {}, "padding-left": {}, "padding-top": {}, "padding-right": {}, "pointer-events": { values: { none: U, auto: U } }, position: { values: { absolute: !0, sticky: !0, relative: !0, fixed: !0 } }, right: { values: { auto: !0 } }, "row-gap": {}, "scrollbar-width": { values: { none: !0 } }, "text-align": { values: { left: !0, right: !0, center: !0, justify: !0, start: !0, end: !0 } }, "text-box-edge": { values: { cap: U, alphabetic: U } }, "text-box-trim": { values: {} }, "text-decoration": { except: ["includes_thickness", "includes_color-and-style"], values: { none: U } }, "text-decoration-color": {}, "text-decoration-line": { values: { none: !0, underline: !0, "line-through": !0 } }, "text-decoration-skip-ink": { values: { none: !0 } }, "text-decoration-style": { values: { solid: U, wavy: U, dotted: U } }, "text-decoration-thickness": { values: { "from-font": !0 } }, "text-indent": {}, "text-overflow": { values: { ellipsis: !0 }, except: ["two_value_syntax"] }, "text-shadow": {}, "text-transform": { values: { none: !0, uppercase: !0, lowercase: !0, capitalize: !0 }, except: ["greek_accented_characters", "dutch_ij_digraph"] }, "text-underline-offset": {}, top: { values: { auto: !0 } }, "text-underline-position": { values: { "from-font": !0 } }, transform: {}, "transform-origin": { values: { top: !0, left: !0 } }, "transition-duration": {}, "transition-property": { values: { all: !0, transform: U } }, "transition-timing-function": { values: { "ease-in-out": U } }, "transition-delay": {}, "vertical-align": { values: { super: !0 } }, "white-space": { values: { pre: !0, "pre-wrap": !0, nowrap: !0 }, except: ["svg_elements", "shorthand_values"] }, width: { values: { auto: !0, "min-content": !0 }, except: ["fit-content_function"] }, "word-break": { values: { "break-word": !0 } }, "z-index": {}, "-webkit-text-size-adjust": { alternateName: "text-size-adjust", partialSupportOk: !0 }, "-webkit-tap-highlight-color": { partialSupportOk: !0, values: { ...JS } }, "-webkit-font-smoothing": { alternateName: "font-smooth", partialSupportOk: !0, values: { antialiased: U } }, "-webkit-line-clamp": { alternateName: "line-clamp" }, ...E2 }, functionTypes: { calc: { key: "types.calc", except: ["calc.color_component"] }, var: { key: "types.var" }, min: { key: "types.min" }, max: { key: "types.max" }, matrix: { key: "types.transform-function.matrix" }, rotate: { key: "types.transform-function.rotate" }, rotateX: { key: "types.transform-function.rotateX" }, rotateY: { key: "types.transform-function.rotateY" }, rotateZ: { key: "types.transform-function.rotateZ" }, rotate3d: { key: "types.transform-function.rotate3d" }, translate: { key: "types.transform-function.translate" }, translateX: { key: "types.transform-function.translateX" }, translateY: { key: "types.transform-function.translateY" }, translateZ: { key: "types.transform-function.translateZ" }, translate3d: { key: "types.transform-function.translate3d" }, skew: { key: "types.transform-function.skew" }, skewX: { key: "types.transform-function.skewX" }, skewY: { key: "types.transform-function.skewY" }, scale: { key: "types.transform-function.scale" }, scaleX: { key: "types.transform-function.scaleX" }, scaleY: { key: "types.transform-function.scaleY" }, scale3d: { key: "types.transform-function.scale3d" }, rgba: { key: "types.color" }, clamp: { key: "types.clamp" }, blur: { key: "types.filter-function.blur" }, "linear-gradient": { key: "types.gradient.linear-gradient", except: ["gradient.linear-gradient.hue_interpolation_method", "gradient.linear-gradient.interpolation_color_space", "gradient.linear-gradient.single_color_stop"] }, "image-set": { key: "types.image.image-set" }, repeat: { key: "properties.grid-template-rows.repeat" }, minmax: { key: "properties.grid-template-rows.minmax" }, "fit-content": { key: "properties.grid-template-rows.fit-content" } }, units: { px: { key: "types.length", except: ["length.container_query_length_units", "length.viewport_percentage_units_dynamic", "length.viewport_percentage_units_large", "length.viewport_percentage_units_small"] }, em: { key: "types.length.em" }, vw: { key: "types.length.vw" }, vh: { key: "types.length.vh" }, dvw: { key: "types.length.viewport_percentage_units_dynamic" }, deg: { key: "types.angle.deg" }, x: { key: "types.resolution.x" }, fr: { key: "types.flex" }, s: { key: "types.time" } } }; var C2 = new Map, b2 = new Map; for (let [e, t] of Object.entries(zI.properties)) if (t.needsPrefix) { let r = `${t.needsPrefix}${e}`; C2.set(r, e), b2.set(e, r) } function Us({ str: e, hashPrefix: t, isUniqueKey: r }) { let n = (l, c) => { let u = `${t}${Math.abs(l).toString(36)}`; return c ? `${u}_${c}` : u }, o = 0, i = 0, s = "", a = 0; for (; o < 5;) { i = 0; for (let l = 0; l < e.length; l++) { let c = e.charCodeAt(l); i = (i << 5) - i + c + o, i = i & i } if (s = n(i), r(s)) return s; o++ } for (; ;)if (a++, s = n(i, a), r(s)) return s } var HI = typeof window < "u" && window.requestIdleCallback ? window.requestIdleCallback : function (e) { let t = Date.now(); return setTimeout(() => { e({ didTimeout: !1, timeRemaining: () => Math.max(0, 50 - (Date.now() - t)) }) }, 1) }; var UI = "#container", w2 = "css-", ex = new Set, tx = new Map; var Yu = new Map, Up = 0, I2 = 1024, rx = null, Il = new Map, Mn, R2 = new Set(["opacity", "zIndex", "fontWeight", "flex", "flexGrow", "flexShrink", "flexBasis", "order", "lineHeight", "gridRow", "gridColumn", "gridRowStart", "gridRowEnd", "gridColumnStart", "gridColumnEnd", "WebkitLineClamp"]), k2 = new Set(["font", "fontFamily", "fontSize", "fontStyle", "fontVariant", "fontWeight", "letterSpacing", "lineHeight", "textAlign", "textDecoration", "textIndent", "textOverflow", "textTransform", "whiteSpace", "wordBreak", "wordSpacing"]), A2 = new Set(["top", "right", "bottom", "left", "width", "height", "maxWidth", "maxHeight", "minWidth", "minHeight"]), N2 = new Set(["alignItems", "alignSelf", "border", "borderBottom", "borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderColor", "borderLeft", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRadius", "borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius", "borderRight", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderStyle", "borderTop", "borderTopColor", "borderTopStyle", "borderTopWidth", "borderWidth", "boxSizing", "display", "flex", "flexBasis", "flexDirection", "flexGrow", "flexShrink", "flexWrap", "gap", "gridArea", "gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridColumn", "gridRow", "gridTemplate", "justifyContent", "justifyItems", "justifySelf", "margin", "marginBottom", "marginLeft", "marginRight", "marginTop", "order", "padding", "paddingBottom", "paddingLeft", "paddingRight", "paddingTop", "position"]); function O2(e) { let t = { ...e }; if ("top" in e && "right" in e && "bottom" in e && "left" in e) { let r = { top: e.top, right: e.right, bottom: e.bottom, left: e.left }; Object.values(r).every(i => i !== void 0) && new Set(Object.values(r)).size === 1 && (t = { ...t, inset: e.top, top: void 0, right: void 0, bottom: void 0, left: void 0 }) } if ("borderTopStyle" in e && "borderRightStyle" in e && "borderBottomStyle" in e && "borderLeftStyle" in e) { let r = { top: e.borderTopStyle, right: e.borderRightStyle, bottom: e.borderBottomStyle, left: e.borderLeftStyle }; new Set(Object.values(r)).size === 1 && r.top && (t = { ...t, borderStyle: r.top, borderTopStyle: void 0, borderRightStyle: void 0, borderBottomStyle: void 0, borderLeftStyle: void 0 }) } if ("borderTopLeftRadius" in e && "borderTopRightRadius" in e && "borderBottomRightRadius" in e && "borderBottomLeftRadius" in e) { let r = { topLeft: e.borderTopLeftRadius, topRight: e.borderTopRightRadius, bottomRight: e.borderBottomRightRadius, bottomLeft: e.borderBottomLeftRadius }; new Set(Object.values(r)).size === 1 && r.topLeft !== void 0 && (t = { ...t, borderRadius: r.topLeft, borderTopLeftRadius: void 0, borderTopRightRadius: void 0, borderBottomRightRadius: void 0, borderBottomLeftRadius: void 0 }) } if ("marginTop" in e && "marginRight" in e && "marginBottom" in e && "marginLeft" in e) { let r = { top: e.marginTop, right: e.marginRight, bottom: e.marginBottom, left: e.marginLeft }; new Set(Object.values(r)).size === 1 && r.top !== void 0 && (t = { ...t, margin: r.top, marginTop: void 0, marginRight: void 0, marginBottom: void 0, marginLeft: void 0 }) } if ("paddingTop" in e && "paddingRight" in e && "paddingBottom" in e && "paddingLeft" in e) { let r = typeof e.paddingTop == "number" ? e.paddingTop + "px" : e.paddingTop, n = typeof e.paddingRight == "number" ? e.paddingRight + "px" : e.paddingRight, o = typeof e.paddingBottom == "number" ? e.paddingBottom + "px" : e.paddingBottom, i = typeof e.paddingLeft == "number" ? e.paddingLeft + "px" : e.paddingLeft, s; new Set([r, n, o, i]).size === 1 && r !== void 0 ? s = r : r === o && r && i === n && n ? s = `${r} ${i}` : r && o && i === n && n && (s = `${r} ${i} ${o}`), s !== void 0 && (t = { ...t, padding: s, paddingTop: void 0, paddingRight: void 0, paddingBottom: void 0, paddingLeft: void 0 }) } if ("overflowX" in e && "overflowY" in e) { let r = e.overflowX, n = e.overflowY; r === n && r !== void 0 && (t = { ...t, overflow: r, overflowX: void 0, overflowY: void 0 }) } return t } function WI(e) { return k2.has(e) ? "font" : A2.has(e) ? "dimension" : N2.has(e) ? "layout" : "other" } function jI(e, t, r = UI) { let n = o => { let i = O2(o); return Object.entries(i).filter(([s, a]) => a !== void 0).map(([s, a]) => { let l = s.replace(/([A-Z])/g, "-$1").toLowerCase(); s === "cssFloat" && (l = "float"); let c = a; return typeof a == "number" && !R2.has(s) && (c = `${a}px`), `${l}: ${c};` }).join(" ") }; return `${r ? `${r} ` : ""}.${e} {${n(t)}}` } var nx = new Map; P2(); function P2() { typeof window < "u" && "__serverRenderedCSSClassNames" in window && typeof window.__serverRenderedCSSClassNames == "object" && Object.entries(window.__serverRenderedCSSClassNames || {}).forEach(([e, t]) => { nx.set(e, t) }) } function L2(e) { if (Object.keys(e).length === 0) return ""; let t = JSON.stringify(e); if (t === "{}") return ""; let r = Us({ str: t, hashPrefix: w2, isUniqueKey: n => { let o = tx.get(n); if (o) return o === t; if (nx.has(n)) { let i = nx.get(n); return t === i } return !0 } }); return tx.set(r, t), r } var _2 = "font-faces-"; function GI(e) { let t = Jn(), r = ue(), n = Us({ str: e, hashPrefix: _2, isUniqueKey: o => { let i = Yu.get(o), s = !i || i === e; if (r === "server") return s; let a = document.getElementById(o), l = !a || a?.textContent === e; return s && l } }); r === "server" && !Yu.has(n) && (t({ type: "global-style", styleElId: n, styleSheet: e }), Yu.set(n, e)), (0, Rl.useInsertionEffect)(() => { if (!e) return; let o = document.getElementById(n); if (o && o.textContent === e) return; let i = document.createElement("style"); return i.textContent = e, i.id = n, document.head.appendChild(i), Yu.set(n, e), () => { document.head.removeChild(i), Yu.delete(n) } }, [e]) } function M(e, t) { let r = ll(e, we), n = (0, Rl.useMemo)(() => { let s = {}; for (let [l, c] of Object.entries(r)) if (!(c === void 0 || c === "")) if (l === "media") for (let [u, d] of Object.entries(c)) for (let [f, p] of Object.entries(d)) { let y = WI(f); s[y] || (s[y] = {}), s[y].media || (s[y].media = {}), s[y].media[u] || (s[y].media[u] = {}), s[y].media[u][f] = p } else { let u = WI(l); s[u] || (s[u] = {}), s[u][l] = c } let a = []; for (let l of Object.values(s)) a.push({ className: L2(l), styles: l }); return a }, [r]); (0, Rl.useInsertionEffect)(() => { let s = ee.state?.renderOptions.disableHighSpecificityContainer || t ? "" : UI; return n.forEach(({ className: a, styles: l }) => { if (!a) return; let c = Il.get(a); c === 0 && Up--, Il.set(a, (c ?? 0) + 1), ex.has(a) || (ex.add(a), M2(a, l, s).forEach(d => { Mn || (Mn = new CSSStyleSheet, document.adoptedStyleSheets.push(Mn)), d.toString(), t ? Mn.insertRule(`@layer figoverridable { ${d} }`, Mn.cssRules.length) : Mn.insertRule(d, Mn.cssRules.length) })) }), () => { n.forEach(({ className: a }) => { if (!a) return; let c = (Il.get(a) || 0) - 1; Il.set(a, c), c === 0 && (Up++, Mn && Up > I2 && !rx && (rx = HI(D2))) }) } }, [n]); let o = Jn(), i = ue(); return i === "server" && n.forEach(({ className: s, styles: a }) => { o({ type: "class-style", className: s, cssProperties: a, classNameSourceStr: JSON.stringify(a) }) }), n.map(({ className: s }) => s).join(" ") } function D2() {
  if (Mn) {
    try {
      let t = Array.from(Mn.cssRules).filter(r => { let n = r.selectorText.substring(1), o = Il.get(n) === 0; return o && (ex.delete(n), Il.delete(n), tx.delete(n)), !o }); Mn.replace(t.map(r => r.cssText).join(`
`))
    } catch (e) { ke.reportError(new te("Error cleaning up styles", e)), console.error("Error cleaning CSS rules:", e) } Up = 0, rx = null
  }
} var ox = "global-css-"; function kl({ cssString: e, styleElId: t, deleteElsWithPrefix: r, skipValidation: n, prepend: o }) { let i = Jn(), s = ue(); s === "server" && e && i({ type: "global-style", styleElId: t, styleSheet: Vi(e) }), (0, Rl.useInsertionEffect)(() => { if (!e || (n || void 0, document.getElementById(t))) return; let l = []; r && (l = Array.from(document.head.querySelectorAll(`style[id^="${r}"]`))); let c = document.createElement("style"); return c.textContent = Vi(e), c.id = t, o ? document.head.insertBefore(c, document.head.firstChild) : document.head.appendChild(c), r && l.forEach(u => { u.remove() }), () => { document.head.removeChild(c) } }, [e, t, o]) } function Vi(e) { return e.replace(/\s+/g, " ").replace(/\/\*.*?\*\//g, "").replace(/;\s*}/g, "}").replace(/\s*{\s*/g, "{").replace(/\s*:\s*/g, ":").replace(/\s*;\s*/g, ";").replace(/\s*,\s*/g, ",").replace(/\s*}\s*/g, "}") } function M2(e, t, r) { let { media: n, ...o } = t, i = [jI(e, o, r)]; if (n) { let s = Object.entries(n).map(([a, l]) => `@media ${a} {${jI(e, l, r)}}`); i.push(...s) } return i } var B2 = "custom-cursor", Al = "customCursor"; function $I() { let e = ge(Wu) !== null; return kl({ cssString: e ? V2 : "", styleElId: B2 }), null } var V2 = jp`  #container .${Al}a,#container .${Al}p,#container .${Al}div{cursor:none}`; function Vo(e, t) { let r = e?.[t]; return me(r !== void 0, `Node asset with hash ${t} not found in used assets`), r } function F2() { let e = BS(); return e ? e.mobile || e.tablet || e.isIpad : !1 } var qI = ({ ref: e, hasCursorBehavior: t, assets: r, behaviors: n }) => { F2() && (t = !1); let o = (0, Gs.useMemo)(() => z2(t), [t]), i = (0, Gs.useCallback)((s, a) => { let { imageUrl: l, imageSize: c } = YI(n, r); s.style.backgroundImage = `url("${l}")`, c && (s.style.width = `${c.x}px`, s.style.height = `${c.y}px`), s.style.visibility = "visible", a.style.cursor = "none", a.classList.add(Al) }, [n, r]); (0, Gs.useEffect)(() => { e.current && KI(e.current.id) && o && i(o, e.current) }, [e, o, i]), (0, Gs.useEffect)(() => { if (!e.current || !o || !t || !n?.cursor) return; let { imageUrl: s, imageSize: a } = YI(n, r); if (!s || !a) return; let l = e.current, c = n.cursor.hotspotX, u = n.cursor.hotspotY, d = gl(g => { l && (XI(l.id), i(o, l), o.style.transform = `translate(${g.clientX - c}px, ${g.clientY - u}px)`) }, "showCursor"), f = gl(g => { l && (ix() === null && d(g), KI(l.id) && (o.style.transform = `translate(${g.clientX - c}px, ${g.clientY - u}px)`)) }, "moveCursor"), p = gl(() => { o && (XI(null), requestAnimationFrame(y)) }, "hideCursor"), y = () => { o && ix() === null && (o.style.visibility = "hidden", l.style.cursor = "auto", l.classList.remove(Al)) }; return l.addEventListener("pointerenter", d), l.addEventListener("pointermove", f), l.addEventListener("pointerleave", p), () => { l.removeEventListener("pointerenter", d), l.removeEventListener("pointermove", f), l.removeEventListener("pointerleave", p), p(new PointerEvent("pointerleave")) } }, [t, n?.cursor, o, e, i, n, r]) }, QI = "sites-cursor-element", z2 = e => { if (!e || typeof document > "u") return null; let t = document.getElementById(QI); return t || H2() }, H2 = () => { let e = document.createElement("div"); return document.body.appendChild(e), e.id = QI, e.style.position = "fixed", e.style.top = "0", e.style.left = "0", e.style.visibility = "hidden", e.style.pointerEvents = "none", e.style.willChange = "transform", e.style.zIndex = "9999", e.ariaHidden = "true", e.style.backgroundRepeat = "no-repeat", e.style.backgroundSize = "contain", e }, KI = e => ix() === e, XI = e => { J().set(Wu, e) }, ix = () => J().get(Wu); function YI(e, t) { let r = sx(e); if (r) { let n = Vo(t, r); return { imageUrl: ee.state?.getAssetURL(n.url), imageSize: n.size } } return { imageUrl: void 0, imageSize: void 0 } } function sx(e) { return e?.cursor?.cursorFileName?.split(".")[0] } var ZI = e => { let { interactionHandlers: t, materializedChildNodeProps: r, ...n } = e; "variableState" in n && delete n.variableState; try { Bi("nodeDebugInformation", { materializedNode: n }) } catch { } }; function JI(e, t, r, n) { let o = t, i = !1, s = (u, d) => (i = !0, r.evaluateVariable(e, u.id, n) ?? d), a = u => r.getVariableName(e, u), l = u => r.getVariableCodeSyntax(e, u); if (W2(o, s, a, l), !("boundVariables" in t && t.boundVariables)) return i; let c = t.boundVariables; return c.opacity && (o.opacity = s(c.opacity, o.opacity) / 100, c.opacity.resolvedName = a(c.opacity.id), c.opacity.resolvedCodeSyntax = l(c.opacity.id)), c.size && o.size && (c.size.x && (o.size.x = s(c.size.x, o.size.x), c.size.x.resolvedName = a(c.size.x.id), c.size.x.resolvedCodeSyntax = l(c.size.x.id)), c.size.y && (o.size.y = s(c.size.y, o.size.y), c.size.y.resolvedName = a(c.size.y.id), c.size.y.resolvedCodeSyntax = l(c.size.y.id))), c.visible && (o.visible = s(c.visible, o.visible), c.visible.resolvedName = a(c.visible.id), c.visible.resolvedCodeSyntax = l(c.visible.id)), o.rectangleCornerRadii === void 0 && (o.cornerRadius !== void 0 ? o.rectangleCornerRadii = [o.cornerRadius, o.cornerRadius, o.cornerRadius, o.cornerRadius] : o.rectangleCornerRadii = [0, 0, 0, 0]), c.rectangleCornerRadii && (c.rectangleCornerRadii.RECTANGLE_TOP_LEFT_CORNER_RADIUS && (o.rectangleCornerRadii[0] = s(c.rectangleCornerRadii.RECTANGLE_TOP_LEFT_CORNER_RADIUS, o.rectangleCornerRadii[0]), c.rectangleCornerRadii.RECTANGLE_TOP_LEFT_CORNER_RADIUS.resolvedName = a(c.rectangleCornerRadii.RECTANGLE_TOP_LEFT_CORNER_RADIUS.id), c.rectangleCornerRadii.RECTANGLE_TOP_LEFT_CORNER_RADIUS.resolvedCodeSyntax = l(c.rectangleCornerRadii.RECTANGLE_TOP_LEFT_CORNER_RADIUS.id), o.rectangleCornerRadiiIndependent = !0), c.rectangleCornerRadii.RECTANGLE_TOP_RIGHT_CORNER_RADIUS && (o.rectangleCornerRadii[1] = s(c.rectangleCornerRadii.RECTANGLE_TOP_RIGHT_CORNER_RADIUS, o.rectangleCornerRadii[1]), c.rectangleCornerRadii.RECTANGLE_TOP_RIGHT_CORNER_RADIUS.resolvedName = a(c.rectangleCornerRadii.RECTANGLE_TOP_RIGHT_CORNER_RADIUS.id), c.rectangleCornerRadii.RECTANGLE_TOP_RIGHT_CORNER_RADIUS.resolvedCodeSyntax = l(c.rectangleCornerRadii.RECTANGLE_TOP_RIGHT_CORNER_RADIUS.id), o.rectangleCornerRadiiIndependent = !0), c.rectangleCornerRadii.RECTANGLE_BOTTOM_RIGHT_CORNER_RADIUS && (o.rectangleCornerRadii[2] = s(c.rectangleCornerRadii.RECTANGLE_BOTTOM_RIGHT_CORNER_RADIUS, o.rectangleCornerRadii[2]), c.rectangleCornerRadii.RECTANGLE_BOTTOM_RIGHT_CORNER_RADIUS.resolvedName = a(c.rectangleCornerRadii.RECTANGLE_BOTTOM_RIGHT_CORNER_RADIUS.id) ?? void 0, c.rectangleCornerRadii.RECTANGLE_BOTTOM_RIGHT_CORNER_RADIUS.resolvedCodeSyntax = l(c.rectangleCornerRadii.RECTANGLE_BOTTOM_RIGHT_CORNER_RADIUS.id), o.rectangleCornerRadiiIndependent = !0), c.rectangleCornerRadii.RECTANGLE_BOTTOM_LEFT_CORNER_RADIUS && (o.rectangleCornerRadii[3] = s(c.rectangleCornerRadii.RECTANGLE_BOTTOM_LEFT_CORNER_RADIUS, o.rectangleCornerRadii[3]), c.rectangleCornerRadii.RECTANGLE_BOTTOM_LEFT_CORNER_RADIUS.resolvedName = a(c.rectangleCornerRadii.RECTANGLE_BOTTOM_LEFT_CORNER_RADIUS.id), c.rectangleCornerRadii.RECTANGLE_BOTTOM_LEFT_CORNER_RADIUS.resolvedCodeSyntax = l(c.rectangleCornerRadii.RECTANGLE_BOTTOM_LEFT_CORNER_RADIUS.id), o.rectangleCornerRadiiIndependent = !0)), c.minWidth && (o.minWidth = s(c.minWidth, o.minWidth), c.minWidth.resolvedName = a(c.minWidth.id), c.minWidth.resolvedCodeSyntax = l(c.minWidth.id)), c.maxWidth && (o.maxWidth = s(c.maxWidth, o.maxWidth), c.maxWidth.resolvedName = a(c.maxWidth.id), c.maxWidth.resolvedCodeSyntax = l(c.maxWidth.id)), c.minHeight && (o.minHeight = s(c.minHeight, o.minHeight), c.minHeight.resolvedName = a(c.minHeight.id), c.minHeight.resolvedCodeSyntax = l(c.minHeight.id)), c.maxHeight && (o.maxHeight = s(c.maxHeight, o.maxHeight), c.maxHeight.resolvedName = a(c.maxHeight.id), c.maxHeight.resolvedCodeSyntax = l(c.maxHeight.id)), c.itemSpacing && (o.itemSpacing = s(c.itemSpacing, o.itemSpacing), c.itemSpacing.resolvedName = a(c.itemSpacing.id), c.itemSpacing.resolvedCodeSyntax = l(c.itemSpacing.id)), c.paddingLeft && (o.paddingLeft = s(c.paddingLeft, o.paddingLeft), c.paddingLeft.resolvedName = a(c.paddingLeft.id), c.paddingLeft.resolvedCodeSyntax = l(c.paddingLeft.id)), c.paddingRight && (o.paddingRight = s(c.paddingRight, o.paddingRight), c.paddingRight.resolvedName = a(c.paddingRight.id), c.paddingRight.resolvedCodeSyntax = l(c.paddingRight.id)), c.paddingTop && (o.paddingTop = s(c.paddingTop, o.paddingTop), c.paddingTop.resolvedName = a(c.paddingTop.id), c.paddingTop.resolvedCodeSyntax = l(c.paddingTop.id)), c.paddingBottom && (o.paddingBottom = s(c.paddingBottom, o.paddingBottom), c.paddingBottom.resolvedName = a(c.paddingBottom.id), c.paddingBottom.resolvedCodeSyntax = l(c.paddingBottom.id)), c.counterAxisSpacing && (o.counterAxisSpacing = s(c.counterAxisSpacing, o.counterAxisSpacing), c.counterAxisSpacing.resolvedName = a(c.counterAxisSpacing.id), c.counterAxisSpacing.resolvedCodeSyntax = l(c.counterAxisSpacing.id)), c.characters && (o.characters = s(c.characters, o.characters)?.toString(), c.characters.resolvedName = a(c.characters.id), c.characters.resolvedCodeSyntax = l(c.characters.id)), c.individualStrokeWeights && (o.individualStrokeWeights === void 0 && (o.individualStrokeWeights = { top: 0, right: 0, bottom: 0, left: 0 }), c.individualStrokeWeights.BORDER_BOTTOM_WEIGHT && (o.individualStrokeWeights.bottom = s(c.individualStrokeWeights.BORDER_BOTTOM_WEIGHT, o.individualStrokeWeights.bottom), c.individualStrokeWeights.BORDER_BOTTOM_WEIGHT.resolvedName = a(c.individualStrokeWeights.BORDER_BOTTOM_WEIGHT.id), c.individualStrokeWeights.BORDER_BOTTOM_WEIGHT.resolvedCodeSyntax = l(c.individualStrokeWeights.BORDER_BOTTOM_WEIGHT.id)), c.individualStrokeWeights.BORDER_LEFT_WEIGHT && (o.individualStrokeWeights.left = s(c.individualStrokeWeights.BORDER_LEFT_WEIGHT, o.individualStrokeWeights.left), c.individualStrokeWeights.BORDER_LEFT_WEIGHT.resolvedName = a(c.individualStrokeWeights.BORDER_LEFT_WEIGHT.id), c.individualStrokeWeights.BORDER_LEFT_WEIGHT.resolvedCodeSyntax = l(c.individualStrokeWeights.BORDER_LEFT_WEIGHT.id)), c.individualStrokeWeights.BORDER_RIGHT_WEIGHT && (o.individualStrokeWeights.right = s(c.individualStrokeWeights.BORDER_RIGHT_WEIGHT, o.individualStrokeWeights.right), c.individualStrokeWeights.BORDER_RIGHT_WEIGHT.resolvedName = a(c.individualStrokeWeights.BORDER_RIGHT_WEIGHT.id), c.individualStrokeWeights.BORDER_RIGHT_WEIGHT.resolvedCodeSyntax = l(c.individualStrokeWeights.BORDER_RIGHT_WEIGHT.id)), c.individualStrokeWeights.BORDER_TOP_WEIGHT && (o.individualStrokeWeights.top = s(c.individualStrokeWeights.BORDER_TOP_WEIGHT, o.individualStrokeWeights.top), c.individualStrokeWeights.BORDER_TOP_WEIGHT.resolvedName = a(c.individualStrokeWeights.BORDER_TOP_WEIGHT.id), c.individualStrokeWeights.BORDER_TOP_WEIGHT.resolvedCodeSyntax = l(c.individualStrokeWeights.BORDER_TOP_WEIGHT.id))), i } function W2(e, t, r, n) { if (e.fills) { for (let o of e.fills) if (o.type === "SOLID") { if (o.boundVariables?.color) { let i = t(o.boundVariables.color, o.color); o.color = { r: i.r, g: i.g, b: i.b, a: 1 }, o.opacity = i.a, o.boundVariables.color.resolvedName = r(o.boundVariables.color.id), o.boundVariables.color.resolvedCodeSyntax = n(o.boundVariables.color.id) } } else if (o.type === "GRADIENT_RADIAL" || o.type === "GRADIENT_LINEAR" || o.type === "GRADIENT_ANGULAR" || o.type === "GRADIENT_DIAMOND") for (let i of o.gradientStops) i.boundVariables?.color && (i.color = t(i.boundVariables.color, i.color), i.boundVariables.color.resolvedName = r(i.boundVariables.color.id), i.boundVariables.color.resolvedCodeSyntax = n(i.boundVariables.color.id)) } if (e.strokes) { for (let o of e.strokes) if (o.type === "SOLID") { if (o.boundVariables?.color) { let i = t(o.boundVariables.color, o.color); o.color = { r: i.r, g: i.g, b: i.b, a: 1 }, o.opacity = i.a, o.boundVariables.color.resolvedName = r(o.boundVariables.color.id), o.boundVariables.color.resolvedCodeSyntax = n(o.boundVariables.color.id) } } else if (o.type === "GRADIENT_RADIAL" || o.type === "GRADIENT_LINEAR" || o.type === "GRADIENT_ANGULAR" || o.type === "GRADIENT_DIAMOND") for (let i of o.gradientStops) i.boundVariables?.color && (i.color = t(i.boundVariables.color, i.color), i.boundVariables.color.resolvedName = r(i.boundVariables.color.id), i.boundVariables.color.resolvedCodeSyntax = n(i.boundVariables.color.id)) } if (e.effects) for (let o of e.effects) { if (o.type === "DROP_SHADOW" || o.type === "INNER_SHADOW") { o.boundVariables?.color && (o.color = t(o.boundVariables.color, o.color), o.boundVariables.color.resolvedName = r(o.boundVariables.color.id), o.boundVariables.color.resolvedCodeSyntax = n(o.boundVariables.color.id)), o.boundVariables?.radius && (o.radius = t(o.boundVariables.radius, o.radius), o.boundVariables.radius.resolvedName = r(o.boundVariables.radius.id), o.boundVariables.radius.resolvedCodeSyntax = n(o.boundVariables.radius.id)), o.boundVariables?.spread && (o.spread = t(o.boundVariables.spread, o.spread), o.boundVariables.spread.resolvedName = r(o.boundVariables.spread.id), o.boundVariables.spread.resolvedCodeSyntax = n(o.boundVariables.spread.id)); let i = o.offset.x, s = o.offset.y; o.boundVariables?.offsetX && (i = t(o.boundVariables.offsetX, o.offset.x), o.boundVariables.offsetX.resolvedName = r(o.boundVariables.offsetX.id), o.boundVariables.offsetX.resolvedCodeSyntax = n(o.boundVariables.offsetX.id)), o.boundVariables?.offsetY && (s = t(o.boundVariables.offsetY, o.offset.x), o.boundVariables.offsetY.resolvedName = r(o.boundVariables.offsetY.id), o.boundVariables.offsetY.resolvedCodeSyntax = n(o.boundVariables.offsetY.id)), o.offset = { x: i, y: s } } (o.type === "LAYER_BLUR" || o.type === "BACKGROUND_BLUR") && o.boundVariables?.radius && (o.radius = t(o.boundVariables.radius, o.radius), o.boundVariables.radius.resolvedName = r(o.boundVariables.radius.id), o.boundVariables.radius.resolvedCodeSyntax = n(o.boundVariables.radius.id)) } if (e.boundVariables?.fontFamily && e.boundVariables.fontFamily.forEach(o => { o.resolvedName = r(o.id), o.resolvedCodeSyntax = n(o.id) }), e.boundVariables?.fontSize && e.boundVariables.fontSize.forEach(o => { o.resolvedName = r(o.id), o.resolvedCodeSyntax = n(o.id) }), e.boundVariables?.fontWeight && e.boundVariables.fontWeight.forEach(o => { o.resolvedName = r(o.id), o.resolvedCodeSyntax = n(o.id) }), e.boundVariables?.fontStyle && e.boundVariables.fontStyle.forEach(o => { o.resolvedName = r(o.id), o.resolvedCodeSyntax = n(o.id) }), e.boundVariables?.lineHeight && e.boundVariables.lineHeight.forEach(o => { o.resolvedName = r(o.id), o.resolvedCodeSyntax = n(o.id) }), e.boundVariables?.letterSpacing && e.boundVariables.letterSpacing.forEach(o => { o.resolvedName = r(o.id), o.resolvedCodeSyntax = n(o.id) }), e.boundVariables?.paragraphSpacing && e.boundVariables.paragraphSpacing.forEach(o => { o.resolvedName = r(o.id), o.resolvedCodeSyntax = n(o.id) }), e.boundVariables?.paragraphIndent && e.boundVariables.paragraphIndent.forEach(o => { o.resolvedName = r(o.id), o.resolvedCodeSyntax = n(o.id) }), e.style?.boundVariables && (e.style.boundVariables.fontFamily && (e.style.fontFamily = t(e.style.boundVariables.fontFamily, e.style.fontFamily), e.style.boundVariables.fontFamily.resolvedName = r(e.style.boundVariables.fontFamily.id), e.style.boundVariables.fontFamily.resolvedCodeSyntax = n(e.style.boundVariables.fontFamily.id)), e.style.boundVariables.fontSize && (e.style.fontSize = t(e.style.boundVariables.fontSize, e.style.fontSize), e.style.boundVariables.fontSize.resolvedName = r(e.style.boundVariables.fontSize.id), e.style.boundVariables.fontSize.resolvedCodeSyntax = n(e.style.boundVariables.fontSize.id)), e.style.boundVariables.fontWeight && e.style.fontVariations?.Weight && (e.style.fontVariations.Weight = t(e.style.boundVariables.fontWeight, e.style.fontVariations.Weight), e.style.boundVariables.fontWeight.resolvedName = r(e.style.boundVariables.fontWeight.id), e.style.boundVariables.fontWeight.resolvedCodeSyntax = n(e.style.boundVariables.fontWeight.id)), e.style.boundVariables.fontStyle && (e.style.fontStyle = t(e.style.boundVariables.fontStyle, e.style.fontStyle), e.style.boundVariables.fontStyle.resolvedName = r(e.style.boundVariables.fontStyle.id), e.style.boundVariables.fontStyle.resolvedCodeSyntax = n(e.style.boundVariables.fontStyle.id)), e.style.boundVariables.lineHeight && (e.style.lineHeightPx = t(e.style.boundVariables.lineHeight, e.style.lineHeightPx), e.style.lineHeightUnit = "PIXELS", e.style.boundVariables.lineHeight.resolvedName = r(e.style.boundVariables.lineHeight.id), e.style.boundVariables.lineHeight.resolvedCodeSyntax = n(e.style.boundVariables.lineHeight.id)), e.style.boundVariables.letterSpacing && (e.style.letterSpacingValue = t(e.style.boundVariables.letterSpacing, e.style.letterSpacingValue), e.style.letterSpacingUnit = "PIXELS", e.style.boundVariables.letterSpacing.resolvedName = r(e.style.boundVariables.letterSpacing.id), e.style.boundVariables.letterSpacing.resolvedCodeSyntax = n(e.style.boundVariables.letterSpacing.id)), e.style.boundVariables.paragraphSpacing && (e.style.paragraphSpacing = t(e.style.boundVariables.paragraphSpacing, e.style.paragraphSpacing), e.style.boundVariables.paragraphSpacing.resolvedName = r(e.style.boundVariables.paragraphSpacing.id), e.style.boundVariables.paragraphSpacing.resolvedCodeSyntax = n(e.style.boundVariables.paragraphSpacing.id)), e.style.boundVariables.paragraphIndent && (e.style.paragraphIndent = t(e.style.boundVariables.paragraphIndent, e.style.paragraphIndent), e.style.boundVariables.paragraphIndent.resolvedName = r(e.style.boundVariables.paragraphIndent.id), e.style.boundVariables.paragraphIndent.resolvedCodeSyntax = n(e.style.boundVariables.paragraphIndent.id))), e.style?.responsiveTextStyleVariants) for (let o of e.style.responsiveTextStyleVariants) o.boundVariables && (o.boundVariables.fontSize && (o.style.fontSize = t(o.boundVariables.fontSize, o.style.fontSize)), o.boundVariables.letterSpacing && (o.style.letterSpacing = t(o.boundVariables.letterSpacing, o.style.letterSpacing)), o.boundVariables.lineHeight && (o.style.lineHeightPx = t(o.boundVariables.lineHeight, o.style.lineHeightPx)), o.boundVariables.paragraphSpacing && (o.style.paragraphSpacing = t(o.boundVariables.paragraphSpacing, o.style.paragraphSpacing))) } function Fi(e) { return e.strokes !== void 0 && e.strokes.length > 0 } function eR(e, t) { if (!(t && "strokesIncludedInLayout" in t && t.strokesIncludedInLayout)) return {}; let { top: r, right: n, bottom: o, left: i } = qu(e); return { borderLeftWidth: L(i), borderRightWidth: L(n), borderTopWidth: L(r), borderBottomWidth: L(o), borderColor: "transparent", borderStyle: "solid", boxSizing: "border-box", backgroundClip: "padding-box" } } function Gp(e, t) { if (!(e.type === "FRAME" || e.type === "SLOT" || e.type === "RECTANGLE") || !(t && "strokesIncludedInLayout" in t && t.strokesIncludedInLayout)) return 0; let n = qu(e); return L(n.left + n.right) } function $p(e, t) { if (!(e.type === "FRAME" || e.type === "SLOT" || e.type === "RECTANGLE") || !(t && "strokesIncludedInLayout" in t && t.strokesIncludedInLayout)) return 0; let n = qu(e); return L(n.top + n.bottom) } function qu(e) { let t = { top: 0, right: 0, bottom: 0, left: 0 }, r = ax(e); if (!Fi(e)) return t; switch (e.strokeAlign) { case "CENTER": return { top: L(r.top / 2), right: L(r.right / 2), bottom: L(r.bottom / 2), left: L(r.left / 2) }; case "OUTSIDE": return r; case "INSIDE": default: return t } } function tR(e) { let t = { top: 0, right: 0, bottom: 0, left: 0 }; if (!Fi(e)) return t; let r = ax(e); switch (e.strokeAlign) { case "CENTER": return { top: r.top / 2, right: r.right / 2, bottom: r.bottom / 2, left: r.left / 2 }; case "OUTSIDE": return t; case "INSIDE": default: return r } } function Kp(e = [], t = !1, r) { let n = e.map(o => { if (o.visible !== !1 && o.type !== "IMAGE" && o.type !== "VIDEO" && o.type !== "PATTERN") { if (o.type === "SOLID") return o; if (Ep(o) && o.gradientStops[0]) return o.gradientStops[0] } }).filter(Boolean); if (n.length !== 0) return $u(n.map(o => new dt("color" in o ? o.color : o, "opacity" in o ? o.opacity : 1, ct, t, "boundVariables" in o ? o.boundVariables?.color?.resolvedName : void 0, r && ("boundVariables" in o ? o.boundVariables?.color?.resolvedCodeSyntax?.[r] : void 0)))).value } var rR = ["border", "borderStyle", "borderColor", "borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius", "borderTopWidth", "borderBottomWidth", "borderLeftWidth", "borderRightWidth"]; function lx(e) { if (e.rectangleCornerRadiiIndependent) return { topLeft: e.rectangleCornerRadii[0] ? L(e.rectangleCornerRadii[0]) : void 0, topRight: e.rectangleCornerRadii[1] ? L(e.rectangleCornerRadii[1]) : void 0, bottomRight: e.rectangleCornerRadii[2] ? L(e.rectangleCornerRadii[2]) : void 0, bottomLeft: e.rectangleCornerRadii[3] ? L(e.rectangleCornerRadii[3]) : void 0 }; let t = e.cornerRadius ? L(e.cornerRadius) : void 0; return { topLeft: t, topRight: t, bottomRight: t, bottomLeft: t } } function cx(e, t, r) { let n = { ...e }; return n.borderTopLeftRadius && (n.borderTopLeftRadius = X(r && t.boundVariables?.rectangleCornerRadii?.RECTANGLE_TOP_LEFT_CORNER_RADIUS?.resolvedCodeSyntax?.[r], t.boundVariables?.rectangleCornerRadii?.RECTANGLE_TOP_LEFT_CORNER_RADIUS?.resolvedName, `${n.borderTopLeftRadius}px`) ?? n.borderTopLeftRadius), n.borderTopRightRadius && (n.borderTopRightRadius = X(r && t.boundVariables?.rectangleCornerRadii?.RECTANGLE_TOP_RIGHT_CORNER_RADIUS?.resolvedCodeSyntax?.[r], t.boundVariables?.rectangleCornerRadii?.RECTANGLE_TOP_RIGHT_CORNER_RADIUS?.resolvedName, `${n.borderTopRightRadius}px`) ?? n.borderTopRightRadius), n.borderBottomRightRadius && (n.borderBottomRightRadius = X(r && t.boundVariables?.rectangleCornerRadii?.RECTANGLE_BOTTOM_RIGHT_CORNER_RADIUS?.resolvedCodeSyntax?.[r], t.boundVariables?.rectangleCornerRadii?.RECTANGLE_BOTTOM_RIGHT_CORNER_RADIUS?.resolvedName, `${n.borderBottomRightRadius}px`) ?? n.borderBottomRightRadius), n.borderBottomLeftRadius && (n.borderBottomLeftRadius = X(r && t.boundVariables?.rectangleCornerRadii?.RECTANGLE_BOTTOM_LEFT_CORNER_RADIUS?.resolvedCodeSyntax?.[r], t.boundVariables?.rectangleCornerRadii?.RECTANGLE_BOTTOM_LEFT_CORNER_RADIUS?.resolvedName, `${n.borderBottomLeftRadius}px`) ?? n.borderBottomLeftRadius), n } function Xp(e, t, r, n, o) { let i = lx(e), s = qu(e), a = { borderTopLeftRadius: i.topLeft ? i.topLeft + Math.min(s.top, s.left) : void 0, borderTopRightRadius: i.topRight ? i.topRight + Math.min(s.top, s.right) : void 0, borderBottomRightRadius: i.bottomRight ? i.bottomRight + Math.min(s.bottom, s.right) : void 0, borderBottomLeftRadius: i.bottomLeft ? i.bottomLeft + Math.min(s.bottom, s.left) : void 0 }, l = n ? cx(a, e, o) : a, c = Kp(e.strokes, n, o), u = j2(e, n, o), d = t && "strokesIncludedInLayout" in t && t.strokesIncludedInLayout; return { position: "absolute", ...l, borderStyle: e.strokeDashes ? "dashed" : "solid", borderColor: r && c === void 0 ? "rgba(0, 0, 0, 0)" : c, borderTopWidth: u.top, borderBottomWidth: u.bottom, borderLeftWidth: u.left, borderRightWidth: u.right, top: d ? 0 : -1 * L(s.top, 2), left: d ? 0 : -1 * L(s.left, 2), right: d ? 0 : -1 * L(s.right, 2), bottom: d ? 0 : -1 * L(s.bottom, 2), overflow: "visible" } } function j2(e, t, r) { if (e.individualStrokeWeights) { let o = L(e.individualStrokeWeights.top), i = L(e.individualStrokeWeights.right), s = L(e.individualStrokeWeights.bottom), a = L(e.individualStrokeWeights.left); if (t) { let l = X(r && e.boundVariables?.individualStrokeWeights?.BORDER_TOP_WEIGHT?.resolvedCodeSyntax?.[r], e.boundVariables?.individualStrokeWeights?.BORDER_TOP_WEIGHT?.resolvedName, `${o}px`), c = X(r && e.boundVariables?.individualStrokeWeights?.BORDER_RIGHT_WEIGHT?.resolvedCodeSyntax?.[r], e.boundVariables?.individualStrokeWeights?.BORDER_RIGHT_WEIGHT?.resolvedName, `${i}px`), u = X(r && e.boundVariables?.individualStrokeWeights?.BORDER_BOTTOM_WEIGHT?.resolvedCodeSyntax?.[r], e.boundVariables?.individualStrokeWeights?.BORDER_BOTTOM_WEIGHT?.resolvedName, `${s}px`), d = X(r && e.boundVariables?.individualStrokeWeights?.BORDER_LEFT_WEIGHT?.resolvedCodeSyntax?.[r], e.boundVariables?.individualStrokeWeights?.BORDER_LEFT_WEIGHT?.resolvedName, `${a}px`); return { top: l ?? o, right: c ?? i, bottom: u ?? s, left: d ?? a } } return { top: o, right: i, bottom: s, left: a } } let n = L(e.strokeWeight); return { top: n, right: n, bottom: n, left: n } } function ax(e) { if (e.individualStrokeWeights) return { top: L(e.individualStrokeWeights.top), right: L(e.individualStrokeWeights.right), bottom: L(e.individualStrokeWeights.bottom), left: L(e.individualStrokeWeights.left) }; let t = Ke(e.strokeWeight); return { top: t, right: t, bottom: t, left: t } } var U2 = ["ON_CLICK", "ON_PRESS", "MOUSE_DOWN", "MOUSE_UP"]; function zi(e, t) { let r = e.interactions ?? []; if (t?.onClick) return { cursor: "pointer" }; for (let n of r) if (U2.find(o => o === n.event?.interactionType)) return { cursor: "pointer" }; return {} } var Yp = e => Object.entries(e).every(([t, r]) => r === void 0 ? !0 : ["top", "left", "right", "bottom"].includes(t) ? r === "0" : t === "position" ? r === "absolute" : t === "display" ? r === "block" : !1); var ux = "data-breakpoint", dx = "breakpoint-css", qp = "data-breakpoint-id"; function G2(e, t, r) { return t.map(n => r.get(n)).filter(Boolean).map(n => e(n)).filter(n => n && n.visible !== !1) } function nR(e, t, r, n) { let o = e(dl), i = G2(e, t, r); if (n === "server") return i.sort((u, d) => u.size.x - d.size.x).map(u => u.id); let a = i.filter(u => u.type === "FRAME"), l = fx(a), c = $2(l, o); return c ? [c.nodeId] : [] } function fx(e) { let t = { breakpoints: [] }; for (let r of e) { let n = "white"; r.fills.every(s => s.type === "SOLID") && (n = Kp(r.fills) ?? n); let i = r.name; t.breakpoints.push({ nodeId: r.id, pageId: "", name: i, width: r.size.x, background: n }) } return t.breakpoints.sort((r, n) => n.width - r.width), t } function $2(e, t) { let { breakpoints: r } = e; return t ? r.find(n => n.width <= t) ?? r[r.length - 1] : r[0] } function oR() { let e = document.querySelectorAll(`[${ux}]`); e.length === 0 && console.error("No breakpoints elements found during hydration."), e.forEach(r => { window.getComputedStyle(r).display === "none" && r.remove() }); let t = document.querySelector(`#${dx}`); if (e.length > 1 && !t) { console.error("No breakpoint css style tag found during hydration."); return } t && t.remove() } function iR(e, t, r) { let n = { ...Po(t), type: "INSTANCE", id: e.id, name: r?.name ?? t.name, mainComponentId: t.id, componentProperties: e.componentProperties, componentPropertyReferences: e.componentPropertyReferences, componentSetId: e.componentSetId, overrides: [] }; for (let o of K2) o in e ? n[o] = e[o] : delete n[o]; return n } var K2 = ["constraints", "constraintValues", "layoutAlign", "layoutGrow", "gridColumnAnchorIndex", "gridRowAnchorIndex", "gridColumnSpan", "gridRowSpan", "layoutPositioning", "relativeTransform", "overrides", "absoluteBoundingBox", "isolatedAbsoluteRenderBounds", "visible", "scrollBehavior", "maybeAnimateRotation"]; function sR(e, t, r, n, o, i) { let s = t.mainComponentId, a, l = t.componentPropertyReferences?.mainComponent; if (l && i?.[l]) s = i[l].value; else if (t.componentSetId) { a = e(r.get(t.componentSetId)); let d = o.instanceState.backingComponentId.get(e, n); if (d) s = d; else if (t.componentProperties && a.type === "COMPONENT_SET") { let f = a.children.map(g => e(r.get(g))), p = Object.entries(a.componentPropertyDefinitions ?? {}).map(([g, S]) => { if (S.type !== "VARIANT") return; let h = t.componentProperties[g]; if (!h) { console.warn("missing component property on instance"); return } if (h.type === "SLOT") return; let m = h.type === "TEXT" ? h.value.characters : h.value, v = "boundVariables" in h ? h.boundVariables : void 0, x = m; if (v?.value && (x = o.variableState.evaluateVariable(e, v.value.id, n)), typeof x == "boolean" && S.variantOptions) { let C = S.variantOptions.map(T => T.toLowerCase()); if (x === !0) { let T = S.variantOptions.find((E, w) => C[w] === "true"); T && (x = T) } else if (x === !1) { let T = S.variantOptions.find((E, w) => C[w] === "false"); T && (x = T) } } return x = S.variantOptions?.includes(String(x)) ? x : S.defaultValue, `${g}=${String(x)}` }).filter(Boolean).join(", "), y = f.find(g => g.name === p); y && (s = y.id) } } let c = e(r.get(s)); return { componentSet: a, component: c } } function aR(e, t, r, n) { if (t.type === "TEXT" && "styleIdForText" in t.style && t.style.styleIdForText) { let o = t.style.styleIdForText, i = n.get(o); if (i) { let s = r.get(i), a = e(s); a.type === "STYLE" && a.styleType === "TEXT" && Object.assign(t.style, Po(a.style)) } } } function lR(e, t) { if (!t || !("componentPropertyReferences" in e) || !e.componentPropertyReferences) return; let r = e.componentPropertyReferences; for (let [n, o] of Object.entries(r)) { if (t[o] === void 0) { let s = X2(o); for (let [a, l] of Object.entries(t)) if (a.startsWith(s)) { e[n] = l.value; break } continue } let i = t[o]; if (i.type === "IMAGE") { console.warn(`Attempted to apply image prop on node ${e.id}`); continue } if (n === "characters") if (i.type === "TEXT") for (let [s, a] of Object.entries(i.value)) e[s] = a; else e[n] = String(i.value); else e[n] = i.value } } function X2(e) { let t = e.lastIndexOf("#"); return e.slice(0, t + 1) } function px(e, t, r, n) { let o = { ...e(n.modeContextState), ...t }; if (!("explicitVariableModes" in r) || !r.explicitVariableModes) return o; let i = {}; for (let [s, a] of Object.entries(r.explicitVariableModes)) { let l = cR(e, s, n) || s, c = n.variableState.getAssetKeyOrLocalGuid(l); i[l] = a, i[c] = a } for (let [s, a] of Object.entries(o)) { let l = cR(e, s, n) || s; if (!l) continue; i[l] === void 0 && (i[l] = a); let c = n.variableState.getAssetKeyOrLocalGuid(l); i[c] === void 0 && (i[c] = a) } return i } function cR(e, t, r) { try { if (!r.variableState.hasAssetId(t)) return; let n = r.variableState.getCollectionInfo(e, t); return n ? n.baseCollectionId : void 0 } catch { return } } var Y2 = ["minWidth", "maxWidth", "minHeight", "maxHeight", "itemSpacing", "paddingLeft", "paddingTop", "paddingRight", "paddingBottom", "counterAxisSpacing", "strokeWeight"]; function Qu(e, t, r) { if (t === 1) return; let n = e; for (let o of Y2) n[o] !== void 0 && (n[o] *= t); if (n.size) { let { x: o, y: i } = n.size; n.size = { x: o * t, y: i * t } } if (n.rectangleCornerRadii && (n.rectangleCornerRadii = n.rectangleCornerRadii.map(o => o * t)), n.individualStrokeWeights && (n.individualStrokeWeights = Object.fromEntries(Object.entries(n.individualStrokeWeights).map(([o, i]) => [o, i * t]))), n.effects) for (let o of n.effects) "radius" in o && o.radius && (o.radius *= t), (o.type === "DROP_SHADOW" || o.type === "INNER_SHADOW") && (o.offset.x *= t, o.offset.y *= t); if (n.constraintValues) { let o = t / r; n.constraintValues = Object.fromEntries(Object.entries(n.constraintValues).map(([i, s]) => [i, { ...s, pixelOffset: s.pixelOffset * o }])) } n.style?.fontSize && (n.style.fontSize = Math.round(n.style.fontSize * t * 100) / 100), n.style?.lineHeightPx && (n.style.lineHeightPx *= t), n.absoluteBoundingBox && (n.absoluteBoundingBox.width *= t, n.absoluteBoundingBox.height *= t) } function uR(e, t, r, n) { let o = t.componentPropertyReferences?.slotContentId; if (!o) return null; let i = n[o]; if (!i || i.type !== "SLOT") return ke.reportError("Slot content node not found or not a slot"), null; if (!nI(i.value.guid)) return ke.reportError("Invalid slot content node ID"), null; let s = e(r.get(Je(i.value.guid))); return s.type !== "FRAME" ? (ke.reportError("Expected slot content node to be a frame"), null) : s } function dR(e, t) { return { ...e, size: t.size, relativeTransform: t.relativeTransform, children: t.children } } function Qp(e) { let t = re().env, r = (0, Hi.useContext)(Ku), n = (0, Hi.useRef)(), o = n.current, i = new Map, s = e.map(d => { let f = d.keyWithOverrides ?? d.key, p = o ? o.get(f) : void 0; return (!p || !we(p.args, d)) && (p = { args: d, value: q2(d, t, r) }), i.set(f, p), p.value }), a = ll(s, we), l = (0, Hi.useMemo)(() => q(d => { let f = a.map(d), p = [], y = []; return f.forEach(g => { "errorMessage" in g ? y.push(g) : p.push(g) }), { nodes: p, errors: y } }), [a]), { nodes: c, errors: u } = ge(l); return (0, Hi.useEffect)(() => (u.forEach(d => { r.setMaterializationError(d.nodeId, d) }), () => { u.forEach(d => { r.setMaterializationError(d.nodeId) }) }), [u, r]), n.current = i, c } function q2(e, t, r) {
  return q(n => {
    try { let o = fR(e, n, t); return n(Hu) && ZI(o), o } catch (o) {
      return o instanceof Error ? (r.reportError(o, { "error-boundary-name": e.keyWithOverrides ?? e.key }), {
        nodeName: e.keyWithOverrides ?? e.key, nodeId: e.nodeId, errorMessage: o.message + `
`+ o.stack
      }) : { nodeName: e.keyWithOverrides ?? e.key, nodeId: e.nodeId, errorMessage: String(o) }
    }
  })
} var Q2 = { mainComponentId: !0, overrides: !0, componentProperties: !0, componentPropertyReferences: !0, componentPropertyDefinitions: !0, componentSetId: !0, mainComponent: !0, overrideKey: !0 }; function $s(e, t, r) { return fR(t, e, r) } var Z2 = 600; function fR(e, t, r) { let { key: n, parentState: o, nodeById: i, animateRootIds: s, animateProps: a, assetIdToGuid: l, guidToUrl: c } = e, { autoLayoutTransitionAtom: u, transitionProps: d } = a ?? {}, f = e.overrides, p = t(i.get(e.backingLayerId ?? e.nodeId)); if (p.type === "SLOT" || p.type === "FRAME") { let ie = uR(t, p, i, e.componentProperties ?? {}); ie && (p = dR(p, ie)) } let y = s.has(e.backingLayerId ?? e.nodeId), g = Po(p), S, h, m = !1, v = !1; "isInAnimateTree" in g && g.isInAnimateTree && (v = !0), e.parentPath ? (h = [...e.parentPath, n], g.type === "INSTANCE" ? S = [] : S = h) : g.type === "INSTANCE" && (S = [], h = []); let x = g.type === "INSTANCE" ? g.mainComponentId : void 0; if (m = mx(g, h, f, void 0, e.uniformScaleFactor, "uniformScaleFactor" in g ? g.uniformScaleFactor : void 0) || m, g.type === "INSTANCE" && g.mainComponentId && g.mainComponentId !== x) { let ie = t(i.get(g.mainComponentId)); ie.type === "COMPONENT" && ie.componentSetId && (g.componentSetId = ie.componentSetId) } if (g.type === "INSTANCE") { let ie = g.overrides?.find(Se => Se.key.length === 0); ie && mR(g, ie) } let C = o.getChildState(n, g, i), T = C.instanceState.backingComponentId, { parentStates: E } = e; g.type === "INSTANCE" && (E === null && (E = new Map), "componentSetId" in g && g.componentSetId && (E = new Map(E), E.set(g.componentSetId, { backingComponentIdState: T, transitionAtom: C.transitionAtom, parentAutoLayoutTransitionAtom: u, stateResetHandlers: C.stateResetHandlers }))); let w = {}, k, R = !1; try { if (g.type === "INSTANCE") { let ie = px(t, e.modeContext, g, C), Se = sR(t, g, i, ie, C, e.componentProperties); if (k = Se.component, k.isUnreachable) { let Yt = new Rt("Component node was incorrectly marked for pruning"); Yt.errorDetail = `instanceId: ${g.id}, componentId: ${k.id}`, ke.reportError(Yt) } g.componentSetId && s.has(g.componentSetId) && (R = !0), k = gR(g, { component: Se.component, componentSet: Se.componentSet }, t, i), g = iR(g, k, Se.componentSet?.type === "COMPONENT_SET" ? Se.componentSet : void 0), m = mx(g, S, No(g.overrides, { nodeId: g.id }), { backingComponent: k, get: t, nodeById: i }, e.uniformScaleFactor, "uniformScaleFactor" in p && p.uniformScaleFactor || 1) || m } g.type === "TEXT" && g.cmsItemFieldBindingProperties?.boundCmsVariables?.richText && (g = EI(g)), aR(t, g, i, l), w = px(t, e.modeContext, g, C), lR(g, e.componentProperties), m = JI(t, g, C.variableState, w) || m, e.uniformScaleFactor && Qu(g, e.uniformScaleFactor, "uniformScaleFactor" in p && p.uniformScaleFactor || 1), J2(t, g, e.nodeId, e.stablePathToAssetHash), TI(g, C.cmsDataState, c), m && g.type === "SVG" && (g.isDynamic = !0) } catch (ie) { throw console.error("Materialization error", ie), new te("Materialization error", ie) } SR(g); let A = { node: g, sourceStablePath: tV(g), variableState: C.variableState, backingComponentIdState: T, parentStates: E, transitionAtom: C.transitionAtom, nodeById: i, modeContext: w }, N = hx(t, A), O = N?.length ? yR(t, A, N) : void 0, D = vR(t, C.transitionAtom, C.autoLayoutTransitionAtom), b = ee.state?.renderOptions.disableBehaviors ?? !1, H = ee.state?.renderOptions.disableImageOptimization ?? !1, B = ee.state?.renderOptions.renderComponentSetNodes ?? !1, z = BI(R, y, b, d), Q = { transitionData: D ?? d?.transitionData, smartAnimateType: z }, se = y || v ? u ?? C.autoLayoutTransitionAtom : void 0, he = e.rootOffset ?? ("absoluteBoundingBox" in g ? { x: g.absoluteBoundingBox.x, y: g.absoluteBoundingBox.y } : void 0), xe = []; if ("children" in g && Array.isArray(g.children)) { let ie = g.children, Se; PS(p) && (ie = nR(t, ie, i, r), Se = ie); let Yt = g.type === "INSTANCE" ? pR(g, { backingComponent: k, get: t, nodeById: i }, No(g.overrides, { nodeId: g.id })) : f, li = Yt?.filter(sr => sr.value.name !== void 0), yn = eV(e.stablePathPrefix, g), Er = new Map, vo = new Map, vn = []; for (let sr = 0; sr < ie.length; sr++) { let Cr = ie[sr], Sn = Se ? Se[sr] : void 0, Lt = t(i.get(Cr)), Ie = Lt.name, Ra = Lt.overrideKey, ci = PS(p) && Lt.type === "FRAME", ui = ci ? Lt.size.x : void 0, br = he; if (ci) br = { x: Lt.absoluteBoundingBox.x, y: Lt.absoluteBoundingBox.y }; else if (g.type === "INSTANCE") { let Cn = { x: he.x - g.absoluteBoundingBox.x, y: he.y - g.absoluteBoundingBox.y }; br = { x: k.absoluteBoundingBox.x + Cn.x, y: k.absoluteBoundingBox.y + Cn.y } } let xn = Er.get(Ie) ?? 0; Er.set(Ie, xn + 1); let Tn = Nl(Ie, xn, g), So = li ? hR([...S ?? [], Tn], li) ?? Ie : Ie, bs = vo.get(So) ?? 0; vo.set(So, bs + 1); let di = yn ? yn.concat(";", Ra ?? Cr) : Cr; vn.push(di || Cr); let En = (e.uniformScaleFactor || 1) * ("uniformScaleFactor" in Lt && Lt.uniformScaleFactor ? Lt.uniformScaleFactor : 1); xe.push({ key: Tn, keyWithOverrides: Nl(So, bs, g), parentState: C, nodeId: di, stablePathPrefix: yn, backingLayerId: Cr, modeContext: w, parentPath: S, preexpandedNodeId: Sn, nodeById: i, assets: e.assets, assetIdToGuid: l, guidToUrl: c, animateRootIds: s, stablePathToAssetHash: e.stablePathToAssetHash, overrides: Yt, componentProperties: g.type === "INSTANCE" || g.type === "CODE_INSTANCE" || g.type === "CODE_LAYER" ? g.componentProperties : e.componentProperties, parentStates: E, animateProps: { transitionProps: Q, autoLayoutTransitionAtom: se }, uniformScaleFactor: En, breakpointWidth: ui ?? e.breakpointWidth, rootOffset: br }) } g.children = vn } let Oe = nV(t, e.assets, g), Y = rV(g, Q2), $ = Y.type === "COMPONENT"; (Y.type === "INSTANCE" || $) && (Y.type = "FRAME"); let oe = Tp(Y), ve = oe.type; return `${ve}`, Object.assign(oe, { materializedChildNodeProps: xe, transitionProps: Q, interactions: N, interactionHandlers: O, key: e.keyWithOverrides ?? e.key, variableState: C.variableState, modeContext: w, assets: Oe }), (g.type === "CODE_INSTANCE" || g.type === "CODE_LAYER") && Object.assign(oe, { componentProperties: g.componentProperties }), (oe.type === "RECTANGLE" || oe.type === "IMAGE" || oe.type === "FRAME" || oe.type === "SVG") && !H && Oe && Object.values(Oe).length && (e.breakpointWidth, oe.lazyLoad = oe.absoluteBoundingBox.x > he.x + e.breakpointWidth || oe.absoluteBoundingBox.y > he.y + Z2), $ && Object.assign(oe, { isComponentDefinition: !0 }), oe } function Nl(e, t, r) { return r?.type === "WEBPAGE" ? "" : e + t } function J2(e, t, r, n) { if (r.includes("I") && (t.id = r, t.type === "SVG" || t.type === "IMAGE")) { let o = n.get(r); if (o) { let i = ee.state?.websiteData.assets.get(o); if (i) { let s = e(i); s && s.type === "GENERATED_ASSET" && (t.hash = o, t.type = s?.format === "SVG" ? "SVG" : "IMAGE") } } } } function eV(e, t) { if (e) return t.type === "INSTANCE" ? t.id : e; if (t.type === "INSTANCE") return `I${t.id}` } function tV(e) { return e.type === "INSTANCE" && !e.id.startsWith("I") ? `I${e.id}` : e.id } function rV(e, t) { let r = { ...e }; for (let n in t) delete r[n]; return r } function nV(e, t, r) { let n, o = i => { let s = t.get(i), a = e(s); n = n ?? {}, n[i] = a }; if ("fills" in r) for (let i of r.fills) i.visible !== !1 && (i.type === "IMAGE" && o(zp(i)), i.type === "VIDEO" && o(i.videoRef)); if ("hash" in r && o(r.hash), "behaviors" in r) { let i = sx(r.behaviors); if (i && o(i), r?.behaviors?.code !== void 0) for (let s of r.behaviors.code) for (let [a, l] of Object.entries(s.assignments)) typeof l == "object" && l.image !== null && (o(l.image), l.animatedImage !== null && o(l.animatedImage)) } if ("componentProperties" in r) for (let i of Object.values(r.componentProperties)) i.type === "IMAGE" && i.value.image && (o(i.value.image), i.value.animatedImage !== null && o(i.value.animatedImage)); if ("styleOverrideTable" in r) { for (let i of Object.values(r.styleOverrideTable)) if (i.fills) for (let s of i.fills) s.visible !== !1 && s.type === "IMAGE" && o(zp(s)) } return n } function pR(e, t, r) { if (!r) return; let n = { get: t.get, nodeById: t.nodeById }, o = CR(e, t), i = []; for (let s of r) { if (s.key.length === 0) continue; let a = xR(s.key, e, n), l = s.key, c = !1; if (!a) { let f = s.key[s.key.length - 1]; let p = iV(f, e, n); p && (a = p.node, l = p.key, c = !0) } if (!a) continue; let u = { key: l, value: s.value }; if (o) { u.value = {}; let f = xR(s.key, o, n); if (f === void 0) { let p = new Rt("No node in variant for override"); p.errorDetail = JSON.stringify({ overrideKey: s.key, nodeId: e.id, nodeName: e.name, variantId: o.id, variantName: o.name }), ke.reportError(p); continue } for (let [p, y] of Dn(s.value)) { let g = vx(p, y, a, f); g !== void 0 && (u.value[p] = g) } } let d = i.findIndex(f => we(f.key, l)); if (d > -1) { let f = i[d]; c ? u.value = yx(u, f) : u.value = yx(f, u), i[d] = u } else i.push(u) } return i } function gx(e, t) { if (!(!t || !e)) return t.find(r => we(r.key, e)) } var Dn = e => Object.entries(e); function TR(e, t) { let r = e.filter(o => Je(o.id) !== Hs), n = t.filter(o => o.isDeleted).map(o => Je(o.id)); return r = r.filter(o => !n.includes(Je(o.id))), t.forEach(o => { if (o.isDeleted) return; let i = r.findIndex(s => Je(s.id) === Je(o.id)); i === -1 ? r.push(o) : r[i] = o }), r } function mx(e, t, r, n, o, i) { if (!t || !r) return !1; let s = gx(t, r); if (s?.value === void 0) return !1; if ("size" in s.value && s.value.size?.isDefault) { let { size: l, ...c } = s.value; Qu(c, 1 / (o || 1), 1 / (i || 1)), s.value = { ...c, size: l } } else Qu(s.value, 1 / (o || 1), 1 / (i || 1)); let a = CR(e, n); for (let [l, c] of Dn(s.value)) e.type === "INSTANCE" && l === "overrides" ? c = ER(No(e.overrides, { nodeId: e.id }), No(c, { nodePath: t })) : l === "interactions" && "interactions" in e && (c = TR(e.interactions ?? [], c)), !(e.type === "INSTANCE" && a && (c = vx(l, c, n.backingComponent, a), c === void 0)) && (c === null ? delete e[l] : e[l] = c); return !0 } function mR(e, t) { if (t.value.explicitVariableModes === null ? delete e.explicitVariableModes : e.explicitVariableModes = t.value.explicitVariableModes, t.value.boundVariables === null || t.value.boundVariables?.componentProperties === null) for (let r in e.componentProperties) { let n = e.componentProperties[r]; n && "boundVariables" in n && n?.boundVariables && delete n.boundVariables } else if (t.value.boundVariables?.componentProperties) for (let r in e.componentProperties) { let n = e.componentProperties[r]; let i = t.value.boundVariables.componentProperties[r]; i && "boundVariables" in n && (n.boundVariables = { value: i }) } } function yx(e, t) { let r = e.value, n = t?.value || {}, o = { ...r, ...n }; return "overrides" in r && "overrides" in n && (o.overrides = ER(No(r.overrides, { overrideId: r.id, overrideKey: r.overrideKey }), No(n.overrides, { overrideId: n.id, overrideKey: n.overrideKey }))), "interactions" in r && "interactions" in n && (o.interactions = TR(r.interactions ?? [], n.interactions ?? [])), o } function ER(e, t) { if (!e) return t; if (!t) return e; if (e && t) { let r = []; for (let n of e) { let o = gx(n.key, t); r.push({ key: n.key, value: yx(n, o) }) } for (let n of t) gx(n.key, r) || r.push(n); return r } } var oV = new Set(["characters", "characterStyleOverrides", "styleOverrideTable", "lineTypes", "lineIndentations", "fontSize", "letterSpacing", "lineHeight", "fontStyle", "fontVariations", "inheritTextStyleId", "lineStyleOverrides"]); function vx(e, t, r, n) { if (e === "name") return t; if (e === "interactions") { let o = e in n ? n.interactions ?? [] : [], i = new Set(o.map(a => Je(a.id) ?? Hs)); return i.add(Hs), t.filter(a => !i.has(Je(a.id) ?? Hs)) } else if (e === "size" && e in r && e in n) { let o = t; return { x: r.size.x === n.size.x ? o.x : r.size.x, y: r.size.y === n.size.y ? o.y : r.size.y } } else { if (e === "componentProperties") return t; if (e === "overrides" && e in r && e in n) { let o = []; for (let i of No(t, { newNodeId: r.id, origNodeId: n.id })) { let s = r.overrides.find(u => we(u.key, i.key)), a = n.overrides.find(u => we(u.key, i.key)); if (!s || !a) { o.push(i); continue } let l = { key: i.key, value: {} }, c = !1; for (let [u, d] of Dn(i.value)) d = vx(u, d, s.value, a.value), d !== void 0 && (l.value[u] = d, c = !0); c && o.push(l) } return o } else if (oV.has(e)) return t } if (we(r[e], n[e])) return t } function CR(e, t) { if (!(e.type === "INSTANCE" && t && e.componentSetId)) return; let r = t.get(t.nodeById.get(e.componentSetId)); r !== void 0 && r.type; let n = Dn(e.componentProperties).map(([o, i]) => i.type !== "VARIANT" ? void 0 : `${o}=${String(i.value)}`).filter(Boolean).join(", "); if (n && t.backingComponent.name !== n) { for (let o of r.children) { let i = t.get(t.nodeById.get(o)); if (i.name === n) return i } console.warn("Could not find initial variant for instance", e.id) } } function bR(e, t) { return e.type === "FRAME" || e.type === "SLOT" || e.type === "GROUP" || e.type === "INSTANCE" && t.id === e.id || e.type === "COMPONENT" && t.id === e.id || e.type === "REPEATER" } function xR(e, t, r) { let { get: n, nodeById: o } = r, i = t; for (let s of e) { if (!i || !bR(i, t)) return; let a = i.children.map(c => n(o.get(c))); i = void 0; let l = new Map; for (let c = 0; c < a.length; ++c) { let u = a[c]; let d = l.get(u.name) ?? 0; l.set(u.name, d + 1); let f = Nl(u.name, d); if (s === f) { i = u; break } } } return i } function iV(e, t, r) { let { get: n, nodeById: o } = r, i = [{ key: [], node: t }], s = new Map; for (; i.length > 0;) { let a = i.pop(); let l = s.get(a.node.name) ?? 0; if (Nl(a.node.name, l) === e) return a; if (s.set(a.node.name, l + 1), !bR(a.node, t)) continue; let c = a.node.children.map(f => n(o.get(f))), u = new Map, d = []; c.forEach(f => { let p = u.get(f.name) ?? 0; u.set(f.name, p + 1), d.push({ key: [...a.key, Nl(f.name, p)], node: f }) }), i.push(...d.reverse()) } } function hR(e, t) { for (let r of t) if (r.value.name !== void 0 && r.value.name !== null && we(r.key, e)) return r.value.name } var RR = new Map, wR = new Set, sV = new Map; function Sx(e) { if (e.startsWith("I") && e.includes(";")) { let t = e.split(";"); if (t.length === 2 && t[1]) return t[1] } return e } function IR(e) { let t = {}, r = e.split(",").map(n => n.trim()); for (let n of r) { let o = n.indexOf("="); if (o > 0) { let i = n.slice(0, o).trim(), s = n.slice(o + 1).trim(); t[i] = s } } return t } function aV(e, t, r) { let n = new Map; if (!e.mainComponentId) return n; for (let o of e.overrides) if ("componentProperties" in o.value && "mainComponentId" in o.value) { let s = t(r.get(o.value.mainComponentId)).componentSetId; if (s) for (let [a, l] of Dn(o.value.componentProperties)) { let c = n.get(s); c ? c.set(a, l.value) : n.set(s, new Map([[a, l.value]])) } } return n } function lV(e) { return "componentProperties" in e && e.componentProperties !== void 0 && "componentSetId" in e && e.componentSetId !== void 0 } function cV(e, t, r, n) { for (let o of r) { let i = n.get(o) || new Map; i.set(e, t), n.set(o, i) } } function uV(e, t, r, n) { let o = t.get(e.componentSetId); if (o) for (let [i, s] of Dn(e.componentProperties)) for (let [a, l] of o) we(s.value, l) && we(i, a) && cV(i, s.value, r, n) } function dV(e, t, r, n, o) { if (!("children" in e) || !e.children || !t.size) return; let i = new Set, s = l => { if (l.type === "INSTANCE" && l.componentSetId && t.has(l.componentSetId)) { i.add(l.id); return } if ("children" in l && l.children) for (let c of l.children) { let u = Sx(c); s(r(n.get(u))) } }; e.componentSetId && s(r(n.get(e.componentSetId))); function a(l) { if (lV(l) && uV(l, t, i, o), "children" in l && l.children) for (let c of l.children) { let u = Sx(c), d = r(n.get(u)); a(d) } } for (let l of e.children) { let c = Sx(l), u = r(n.get(c)); a(u) } } function fV(e, t, r, n, o, i) { if (!("children" in e) || !i.has(t.id)) return; let s = i.get(t.id), a = new Map; for (let [u, d] of Dn(t.componentProperties)) s?.has(u) || a.set(u, d.value); let l = IR(r.name); for (let [u, d] of Dn(l)) a?.has(u) || a.set(u, d); let c = e.children || []; for (let u of c) { let d = n(o.get(u)), f = IR(d.name), p = Object.fromEntries(a); if (we(p, f) && i.has(t.id)) return d } } function kR(e, t, r) { let n = t(r.get(e)), o = t(r.get(n.mainComponentId)); if (!wR.has(n.id)) { let i = aV(n, t, r); dV(o, i, t, r, RR), wR.add(n.id) } } function gR(e, t, r, n) { let { component: o } = t, { componentSet: i } = t; if (!i || !("children" in i)) return o; let s = sV.get(e.id); if (s) return r(n.get(s)); let a = r(n.get(e.mainComponentId)), l = fV(i, e, a, r, n, RR); return l && (o = l), o } var Fo; (function (e) { e[e.BOOLEAN = 0] = "BOOLEAN", e[e.FLOAT = 1] = "FLOAT", e[e.STRING = 2] = "STRING", e[e.ALIAS = 3] = "ALIAS", e[e.COLOR = 4] = "COLOR", e[e.EXPRESSION = 5] = "EXPRESSION", e[e.MAP = 6] = "MAP", e[e.SYMBOL_ID = 7] = "SYMBOL_ID" })(Fo || (Fo = {})); function Bn(e, t) { let r = null; return typeof t != "object" || "r" in t || "image" in t ? r = t : t.type === "VARIABLE_ALIAS" ? r = e.variableState.evaluateVariable(e.get, t.id, e.modeContext) : t.type === "EXPRESSION" && (r = pV(t, e)), r } function pV(e, t) { let r = mV.find(({ expressionFunction: n, resolvedType: o, argTypes: i }) => n === e.value.expressionFunction && o === e.resolvedType && e.value.expressionArguments.every((s, a) => Ex(s) === i[a]))?.implementation; return r ? r(e.value.expressionArguments, t) : (console.warn("expression type not implemented", e.value.expressionFunction), null) } function Be(e, t, r, n) { return { resolvedType: t, argTypes: r, implementation: n, expressionFunction: e } } var mV = [Be(Re.ADDITION, "FLOAT", ["FLOAT", "FLOAT"], hV), Be(Re.SUBTRACTION, "FLOAT", ["FLOAT", "FLOAT"], gV), Be(Re.MULTIPLY, "FLOAT", ["FLOAT", "FLOAT"], yV), Be(Re.DIVIDE, "FLOAT", ["FLOAT", "FLOAT"], vV), Be(Re.AND, "BOOLEAN", ["BOOLEAN", "BOOLEAN"], SV), Be(Re.OR, "BOOLEAN", ["BOOLEAN", "BOOLEAN"], xV), Be(Re.NOT, "BOOLEAN", ["BOOLEAN"], TV), Be(Re.EQUALS, "BOOLEAN", ["FLOAT", "FLOAT"], EV), Be(Re.NOT_EQUAL, "BOOLEAN", ["FLOAT", "FLOAT"], CV), Be(Re.EQUALS, "BOOLEAN", ["BOOLEAN", "BOOLEAN"], bV), Be(Re.NOT_EQUAL, "BOOLEAN", ["BOOLEAN", "BOOLEAN"], wV), Be(Re.EQUALS, "BOOLEAN", ["STRING", "STRING"], IV), Be(Re.NOT_EQUAL, "BOOLEAN", ["STRING", "STRING"], RV), Be(Re.LESS_THAN, "BOOLEAN", ["FLOAT", "FLOAT"], kV), Be(Re.LESS_THAN_OR_EQUAL, "BOOLEAN", ["FLOAT", "FLOAT"], AV), Be(Re.GREATER_THAN, "BOOLEAN", ["FLOAT", "FLOAT"], NV), Be(Re.GREATER_THAN_OR_EQUAL, "BOOLEAN", ["FLOAT", "FLOAT"], OV), Be(Re.STRINGIFY, "STRING", ["FLOAT"], PV), Be(Re.STRINGIFY, "STRING", ["BOOLEAN"], LV), Be(Re.STRINGIFY, "STRING", ["STRING"], _V), Be(Re.ADDITION, "STRING", ["STRING", "STRING"], DV), Be(Re.ADDITION, "STRING", ["FLOAT", "STRING"], MV), Be(Re.ADDITION, "STRING", ["STRING", "FLOAT"], BV), Be(Re.ADDITION, "STRING", ["BOOLEAN", "STRING"], VV), Be(Re.ADDITION, "STRING", ["STRING", "BOOLEAN"], FV)]; function hV(e, t) { return et(e, t, (r, n) => r + n, "number") } function gV(e, t) { return et(e, t, (r, n) => r - n, "number") } function yV(e, t) { return et(e, t, (r, n) => r * n, "number") } function vV(e, t) { return et(e, t, (r, n) => n === 0 ? null : r / n, "number") } function SV(e, t) { return et(e, t, (r, n) => r && n, "boolean") } function xV(e, t) { return et(e, t, (r, n) => r || n, "boolean") } function TV(e, t) { let r = Bn(t, e[0]); return typeof r != "boolean" ? Zp(r, "boolean") : !r } function EV(e, t) { return et(e, t, (r, n) => r === n, "number") } function CV(e, t) { return et(e, t, (r, n) => r !== n, "number") } function bV(e, t) { return et(e, t, (r, n) => r === n, "boolean") } function wV(e, t) { return et(e, t, (r, n) => r !== n, "boolean") } function IV(e, t) { return et(e, t, (r, n) => r === n, "string") } function RV(e, t) { return et(e, t, (r, n) => r !== n, "string") } function kV(e, t) { return et(e, t, (r, n) => r < n, "number") } function AV(e, t) { return et(e, t, (r, n) => r <= n, "number") } function NV(e, t) { return et(e, t, (r, n) => r > n, "number") } function OV(e, t) { return et(e, t, (r, n) => r >= n, "number") } function xx(e) { return Math.ceil(e) === e ? String(e) : e.toFixed(2) } function PV(e, t) { return Tx(e, t, r => xx(r), "number") } function LV(e, t) { return Tx(e, t, r => String(r), "boolean") } function _V(e, t) { return Tx(e, t, r => r, "string") } function DV(e, t) { return et(e, t, (r, n) => r + n, "string") } function MV(e, t) { return et(e, t, (r, n) => xx(r) + n, "number", "string") } function BV(e, t) { return et(e, t, (r, n) => r + xx(n), "string", "number") } function VV(e, t) { return et(e, t, (r, n) => String(r) + n, "boolean", "string") } function FV(e, t) { return et(e, t, (r, n) => r + String(n), "string", "boolean") } function Tx(e, t, r, n) { let o = Bn(t, e[0]); return typeof o !== n ? Zp(o, n) : r(o) } function et(e, t, r, n, o) { let i = Bn(t, e[0]), s = Bn(t, e[1]); return typeof i !== n ? Zp(i, n) : typeof s !== (o ?? n) ? Zp(s, o ?? n) : r(i, s) } function Zp(e, t) { return console.warn(`Expected variable of type ${t}, but got variable ${JSON.stringify(e)} of type ${typeof e}`), null } function Ex(e) { let t = typeof e; if (t === "boolean") return "BOOLEAN"; if (t === "number") return "FLOAT"; if (t === "string") return "STRING"; if (typeof e == "object") { if ("image" in e) return "IMAGE"; if ("r" in e) return "COLOR"; if (e.type === "EXPRESSION" || e.type === "VARIABLE_ALIAS") return e.resolvedType || null } return null } function Ol(e) { switch (e.type) { case Fo.BOOLEAN: case Fo.FLOAT: case Fo.STRING: case Fo.COLOR: return e.value; case Fo.ALIAS: return { type: "VARIABLE_ALIAS", id: e.value, resolvedType: AR(e.resolvedType) }; case Fo.EXPRESSION: return { type: "EXPRESSION", value: { expressionFunction: e.value.expressionFunction, expressionArguments: e.value.expressionArguments.map(t => Ol(t)) }, resolvedType: AR(e.resolvedType) }; default: return null } } function AR(e) { return e === 0 ? "BOOLEAN" : e === 1 ? "FLOAT" : e === 2 ? "STRING" : e === 3 ? "COLOR" : null } var Jp = new Map, em = new Map; function tm(e) { let t = Jp.get(e); if (t) return Promise.resolve(t); let r = em.get(e); if (r) return r.promise; let n = () => { }, o = new Promise(i => n = i); return em.set(e, { resolve: n, promise: o }), o } function Cx(e, t) { if (Jp.has(e)) return; Jp.set(e, t); let r = em.get(e)?.resolve; r && (r(t), em.delete(e)) } function bx(e) { Jp.delete(e) } function NR(e) { if (e.length === 0) return Promise.resolve(null); let t = e.map(r => tm(r)); return Promise.any(t) } function OR() { return typeof window > "u" ? !1 : window.matchMedia("(prefers-reduced-motion: reduce)").matches } function zV(e) { return ee.state?.websiteData.siteSettings ? !!e(ee.state?.websiteData.siteSettings).ignoreReducedMotion : !1 } function Zu() { return !!Di()?.ignoreReducedMotion } function PR(e) { return OR() && !zV(e) } function rm() { let e = Zu(); return OR() && !e } function wx() { return document.documentElement } function Ix() { return document.body } function LR(e) { if (!(e instanceof HTMLElement || e instanceof SVGElement)) return !1; let t = getComputedStyle(e); return ["overflow", "overflow-x", "overflow-y"].some(r => { let n = t.getPropertyValue(r); return n === "auto" || n === "scroll" }) } function _R(e) { if (!(e instanceof HTMLElement || e instanceof SVGElement)) return !1; let t = getComputedStyle(e); return t.overflowX === "auto" || t.overflowX === "scroll" } function DR(e) { if (!(e instanceof HTMLElement || e instanceof SVGElement)) return !1; let t = getComputedStyle(e); return t.overflowY === "auto" || t.overflowY === "scroll" } function MR(e) { let t = e.parentElement; for (; t && t !== document.documentElement;) { if (LR(t)) return t; t = t.parentElement } return Ix() } function Rx(e) { let t = e.parentElement; for (; t && t !== document.body;) { if (LR(t)) return t; t = t.parentElement } return wx() } var BR = I(P()), VR = I(MS()); var kx = q(new Map), Pl = { SHIFT_CODE: 16, CONTROL_CODE: 17, ALT_CODE: 18, META_CODE: 91 }; function FR(e, t) { let r = e.event?.keyTrigger?.triggerDevice === "KEYBOARD", n = e.event?.keyTrigger?.keyCodes; if (!n) return !1; let o = jV(t), i = n.length === t.length; return r && i && n.every(o) } function HV(e) { return e === void 0 ? !1 : (e = e.toUpperCase(), e === "SHIFT" || e === "CONTROL" || e === "ALT" || e === "META") } function WV(e) { let t = []; return t.push(e.keyCode), e.shiftKey && t.push(Pl.SHIFT_CODE), e.ctrlKey && t.push(Pl.CONTROL_CODE), e.altKey && t.push(Pl.ALT_CODE), e.metaKey && t.push(Pl.META_CODE), t } function jV(e) { let t = VR.default.mac; return r => (r = r === Pl.META_CODE && !t ? Pl.CONTROL_CODE : r, e.some(n => n === r)) } function zR() { let e = ge(kx); (0, BR.useEffect)(() => { let t = gl(r => { if (HV(r.key)) return; let n = WV(r); e.forEach(o => { o.keyCallback?.(n) }) }, "handleKeypressInteractions"); return window.addEventListener("keydown", t), () => { window.removeEventListener("keydown", t) } }, [e]) } var nL = I(P()); var Mc = I(W()), ei = I(P()); var ed = I(W(), 1), to = I(P(), 1); var HR = I(P(), 1), Ll = (0, HR.createContext)({}); var WR = I(P(), 1); function Dr(e) { let t = (0, WR.useRef)(null); return t.current === null && (t.current = e()), t.current } var Nx = I(W(), 1), KR = I(P(), 1), Ks = I(P(), 1); var jR = I(P(), 1), Wi = (0, jR.createContext)(null); var GR = I(W(), 1), nm = I(P(), 1), zo = I(P(), 1); var UR = I(P(), 1), Vn = (0, UR.createContext)({ transformPagePoint: e => e, isStatic: !1, reducedMotion: "never" }); var Ax = class extends nm.Component { getSnapshotBeforeUpdate(t) { let r = this.props.childRef.current; if (r && t.isPresent && !this.props.isPresent) { let n = r.offsetParent, o = n instanceof HTMLElement && n.offsetWidth || 0, i = this.props.sizeRef.current; i.height = r.offsetHeight || 0, i.width = r.offsetWidth || 0, i.top = r.offsetTop, i.left = r.offsetLeft, i.right = o - i.width - i.left } return null } componentDidUpdate() { } render() { return this.props.children } }; function $R({ children: e, isPresent: t, anchorX: r }) {
  let n = (0, zo.useId)(), o = (0, zo.useRef)(null), i = (0, zo.useRef)({ width: 0, height: 0, top: 0, left: 0, right: 0 }), { nonce: s } = (0, zo.useContext)(Vn); return (0, zo.useInsertionEffect)(() => {
    let { width: a, height: l, top: c, left: u, right: d } = i.current; if (t || !o.current || !a || !l) return; let f = r === "left" ? `left: ${u}` : `right: ${d}`; o.current.dataset.motionPopId = n; let p = document.createElement("style"); return s && (p.nonce = s), document.head.appendChild(p), p.sheet && p.sheet.insertRule(`
          [data-motion-pop-id="${n}"] {
            position: absolute !important;
            width: ${a}px !important;
            height: ${l}px !important;
            ${f}px !important;
            top: ${c}px !important;
          }
        `), () => { document.head.removeChild(p) }
  }, [t]), (0, GR.jsx)(Ax, { isPresent: t, childRef: o, sizeRef: i, children: nm.cloneElement(e, { ref: o }) })
} var XR = ({ children: e, initial: t, isPresent: r, onExitComplete: n, custom: o, presenceAffectsLayout: i, mode: s, anchorX: a }) => { let l = Dr(UV), c = (0, Ks.useId)(), u = (0, Ks.useCallback)(f => { l.set(f, !0); for (let p of l.values()) if (!p) return; n && n() }, [l, n]), d = (0, Ks.useMemo)(() => ({ id: c, initial: t, isPresent: r, custom: o, onExitComplete: u, register: f => (l.set(f, !1), () => l.delete(f)) }), i ? [Math.random(), u] : [r, u]); return (0, Ks.useMemo)(() => { l.forEach((f, p) => l.set(p, !1)) }, [r]), KR.useEffect(() => { !r && !l.size && n && n() }, [r]), s === "popLayout" && (e = (0, Nx.jsx)($R, { isPresent: r, anchorX: a, children: e })), (0, Nx.jsx)(Wi.Provider, { value: d, children: e }) }; function UV() { return new Map } var ji = I(P(), 1); function om(e = !0) { let t = (0, ji.useContext)(Wi); if (t === null) return [!0, null]; let { isPresent: r, onExitComplete: n, register: o } = t, i = (0, ji.useId)(); (0, ji.useEffect)(() => { if (e) return o(i) }, [e]); let s = (0, ji.useCallback)(() => e && n && n(i), [i, n, e]); return !r && n ? [!1, s] : [!0] } var im = I(P(), 1), Ju = e => e.key || ""; function Ox(e) { let t = []; return im.Children.forEach(e, r => { (0, im.isValidElement)(r) && t.push(r) }), t } var sm = I(P(), 1); var _l = typeof window < "u"; var am = _l ? sm.useLayoutEffect : sm.useEffect; var Px = ({ children: e, custom: t, initial: r = !0, onExitComplete: n, presenceAffectsLayout: o = !0, mode: i = "sync", propagate: s = !1, anchorX: a = "left" }) => { let [l, c] = om(s), u = (0, to.useMemo)(() => Ox(e), [e]), d = s && !l ? [] : u.map(Ju), f = (0, to.useRef)(!0), p = (0, to.useRef)(u), y = Dr(() => new Map), [g, S] = (0, to.useState)(u), [h, m] = (0, to.useState)(u); am(() => { f.current = !1, p.current = u; for (let C = 0; C < h.length; C++) { let T = Ju(h[C]); d.includes(T) ? y.delete(T) : y.get(T) !== !0 && y.set(T, !1) } }, [h, d.length, d.join("-")]); let v = []; if (u !== g) { let C = [...u]; for (let T = 0; T < h.length; T++) { let E = h[T], w = Ju(E); d.includes(w) || (C.splice(T, 0, E), v.push(E)) } return i === "wait" && v.length && (C = v), m(Ox(C)), S(u), null } let { forceRender: x } = (0, to.useContext)(Ll); return (0, ed.jsx)(ed.Fragment, { children: h.map(C => { let T = Ju(C), E = s && !l ? !1 : u === h || d.includes(T), w = () => { if (y.has(T)) y.set(T, !0); else return; let k = !0; y.forEach(R => { R || (k = !1) }), k && (x?.(), m(p.current), s && c?.(), n && n()) }; return (0, ed.jsx)(XR, { isPresent: E, initial: !f.current || r ? void 0 : !1, custom: t, presenceAffectsLayout: o, mode: i, onExitComplete: E ? void 0 : w, anchorX: a, children: C }, T) }) }) }; var He = e => e; var Ui = He, Mr = He; var Xs = { skipAnimations: !1, useManualTiming: !1 }; var td = ["read", "resolveKeyframes", "update", "preRender", "render", "postRender"]; var Br = { value: null, addProjectionMetrics: null }; function YR(e, t) { let r = new Set, n = new Set, o = !1, i = !1, s = new WeakSet, a = { delta: 0, timestamp: 0, isProcessing: !1 }, l = 0; function c(d) { s.has(d) && (u.schedule(d), e()), l++, d(a) } let u = { schedule: (d, f = !1, p = !1) => { let g = p && o ? r : n; return f && s.add(d), g.has(d) || g.add(d), d }, cancel: d => { n.delete(d), s.delete(d) }, process: d => { if (a = d, o) { i = !0; return } o = !0, [r, n] = [n, r], r.forEach(c), t && Br.value && Br.value.frameloop[t].push(l), l = 0, r.clear(), o = !1, i && (i = !1, u.process(d)) } }; return u } var GV = 40; function lm(e, t) { let r = !1, n = !0, o = { delta: 0, timestamp: 0, isProcessing: !1 }, i = () => r = !0, s = td.reduce((h, m) => (h[m] = YR(i, t ? m : void 0), h), {}), { read: a, resolveKeyframes: l, update: c, preRender: u, render: d, postRender: f } = s, p = () => { let h = Xs.useManualTiming ? o.timestamp : performance.now(); r = !1, Xs.useManualTiming || (o.delta = n ? 1e3 / 60 : Math.max(Math.min(h - o.timestamp, GV), 1)), o.timestamp = h, o.isProcessing = !0, a.process(o), l.process(o), c.process(o), u.process(o), d.process(o), f.process(o), o.isProcessing = !1, r && t && (n = !1, e(p)) }, y = () => { r = !0, n = !0, o.isProcessing || e(p) }; return { schedule: td.reduce((h, m) => { let v = s[m]; return h[m] = (x, C = !1, T = !1) => (r || y(), v.schedule(x, C, T)), h }, {}), cancel: h => { for (let m = 0; m < td.length; m++)s[td[m]].cancel(h) }, state: o, steps: s } } var { schedule: Z, cancel: fr, state: Qe, steps: rd } = lm(typeof requestAnimationFrame < "u" ? requestAnimationFrame : He, !0); var qR = I(P(), 1), cm = (0, qR.createContext)({ strict: !1 }); var QR = { animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"], exit: ["exit"], drag: ["drag", "dragControls"], focus: ["whileFocus"], hover: ["whileHover", "onHoverStart", "onHoverEnd"], tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"], pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"], inView: ["whileInView", "onViewportEnter", "onViewportLeave"], layout: ["layout", "layoutId"] }, Ho = {}; for (let e in QR) Ho[e] = { isEnabled: t => QR[e].some(r => !!t[r]) }; function ZR(e) { for (let t in e) Ho[t] = { ...Ho[t], ...e[t] } } var tk = I(W(), 1), um = I(P(), 1); var $V = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]); function nd(e) { return e.startsWith("while") || e.startsWith("drag") && e !== "draggable" || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || $V.has(e) } var JR = e => !nd(e); function Lx(e) { e && (JR = t => t.startsWith("on") ? !nd(t) : e(t)) } try { Lx(H_("@emotion/is-prop-valid").default) } catch { } function ek(e, t, r) { let n = {}; for (let o in e) o === "values" && typeof e.values == "object" || (JR(o) || r === !0 && nd(o) || !t && !nd(o) || e.draggable && o.startsWith("onDrag")) && (n[o] = e[o]); return n } function _x({ children: e, isValidProp: t, ...r }) { t && Lx(t), r = { ...(0, um.useContext)(Vn), ...r }, r.isStatic = Dr(() => r.isStatic); let n = (0, um.useMemo)(() => r, [JSON.stringify(r.transition), r.transformPagePoint, r.reducedMotion]); return (0, tk.jsx)(Vn.Provider, { value: n, children: e }) } function rk(e) { if (typeof Proxy > "u") return e; let t = new Map, r = (...n) => e(...n); return new Proxy(r, { get: (n, o) => o === "create" ? e : (t.has(o) || t.set(o, e(o)), t.get(o)) }) } var gm = I(W(), 1); var Bl = I(P(), 1); var nk = I(P(), 1), Gi = (0, nk.createContext)({}); var pm = I(P(), 1); function $i(e) { return e !== null && typeof e == "object" && typeof e.start == "function" } function Wo(e) { return typeof e == "string" || Array.isArray(e) } var dm = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"], od = ["initial", ...dm]; function Ys(e) { return $i(e.animate) || od.some(t => Wo(e[t])) } function fm(e) { return Boolean(Ys(e) || e.variants) } function ok(e, t) { if (Ys(e)) { let { initial: r, animate: n } = e; return { initial: r === !1 || Wo(r) ? r : void 0, animate: Wo(n) ? n : void 0 } } return e.inherit !== !1 ? t : {} } function sk(e) { let { initial: t, animate: r } = ok(e, (0, pm.useContext)(Gi)); return (0, pm.useMemo)(() => ({ initial: t, animate: r }), [ik(t), ik(r)]) } function ik(e) { return Array.isArray(e) ? e.join(" ") : e } var ak = Symbol.for("motionComponentSymbol"); var lk = I(P(), 1); function jo(e) { return e && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current") } function ck(e, t, r) { return (0, lk.useCallback)(n => { n && e.onMount && e.onMount(n), t && (n ? t.mount(n) : t.unmount()), r && (typeof r == "function" ? r(n) : jo(r) && (r.current = n)) }, [t]) } var pr = I(P(), 1); var Dl = e => e.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(); var KV = "framerAppearId", mm = "data-" + Dl(KV); var { schedule: Ml, cancel: x8 } = lm(queueMicrotask, !1); var uk = I(P(), 1), hm = (0, uk.createContext)({}); function dk(e, t, r, n, o) { var i, s; let { visualElement: a } = (0, pr.useContext)(Gi), l = (0, pr.useContext)(cm), c = (0, pr.useContext)(Wi), u = (0, pr.useContext)(Vn).reducedMotion, d = (0, pr.useRef)(null); n = n || l.renderer, !d.current && n && (d.current = n(e, { visualState: t, parent: a, props: r, presenceContext: c, blockInitialAnimation: c ? c.initial === !1 : !1, reducedMotionConfig: u })); let f = d.current, p = (0, pr.useContext)(hm); f && !f.projection && o && (f.type === "html" || f.type === "svg") && XV(d.current, r, o, p); let y = (0, pr.useRef)(!1); (0, pr.useInsertionEffect)(() => { f && y.current && f.update(r, c) }); let g = r[mm], S = (0, pr.useRef)(Boolean(g) && !(!((i = window.MotionHandoffIsComplete) === null || i === void 0) && i.call(window, g)) && ((s = window.MotionHasOptimisedAnimation) === null || s === void 0 ? void 0 : s.call(window, g))); return am(() => { f && (y.current = !0, window.MotionIsMounted = !0, f.updateFeatures(), Ml.render(f.render), S.current && f.animationState && f.animationState.animateChanges()) }), (0, pr.useEffect)(() => { f && (!S.current && f.animationState && f.animationState.animateChanges(), S.current && (queueMicrotask(() => { var h; (h = window.MotionHandoffMarkAsComplete) === null || h === void 0 || h.call(window, g) }), S.current = !1)) }), f } function XV(e, t, r, n) { let { layoutId: o, layout: i, drag: s, dragConstraints: a, layoutScroll: l, layoutRoot: c } = t; e.projection = new r(e.latestValues, t["data-framer-portal-id"] ? void 0 : fk(e.parent)), e.projection.setOptions({ layoutId: o, layout: i, alwaysMeasureLayout: Boolean(s) || a && jo(a), visualElement: e, animationType: typeof i == "string" ? i : "both", initialPromotionConfig: n, layoutScroll: l, layoutRoot: c }) } function fk(e) { if (e) return e.options.allowProjection !== !1 ? e.projection : fk(e.parent) } function pk({ preloadedFeatures: e, createVisualElement: t, useRender: r, useVisualState: n, Component: o }) { var i, s; e && ZR(e); function a(c, u) { let d, f = { ...(0, Bl.useContext)(Vn), ...c, layoutId: YV(c) }, { isStatic: p } = f, y = sk(c), g = n(c, p); if (!p && _l) { qV(f, e); let S = QV(f); d = S.MeasureLayout, y.visualElement = dk(o, g, f, t, S.ProjectionNode) } return (0, gm.jsxs)(Gi.Provider, { value: y, children: [d && y.visualElement ? (0, gm.jsx)(d, { visualElement: y.visualElement, ...f }) : null, r(o, c, ck(g, y.visualElement, u), g, p, y.visualElement)] }) } a.displayName = `motion.${typeof o == "string" ? o : `create(${(s = (i = o.displayName) !== null && i !== void 0 ? i : o.name) !== null && s !== void 0 ? s : ""})`}`; let l = (0, Bl.forwardRef)(a); return l[ak] = o, l } function YV({ layoutId: e }) { let t = (0, Bl.useContext)(Ll).id; return t && e !== void 0 ? t + "-" + e : e } function qV(e, t) { let r = (0, Bl.useContext)(cm).strict } function QV(e) { let { drag: t, layout: r } = Ho; if (!t && !r) return {}; let n = { ...t, ...r }; return { MeasureLayout: t?.isEnabled(e) || r?.isEnabled(e) ? n.MeasureLayout : void 0, ProjectionNode: n.ProjectionNode } } var $l = I(P(), 1); var Tk = I(P(), 1); var mk = e => t => typeof t == "string" && t.startsWith(e), Vl = mk("--"), ZV = mk("var(--"), Fl = e => ZV(e) ? JV.test(e.split("/*")[0].trim()) : !1, JV = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu; var qs = {}; function hk(e) { for (let t in e) qs[t] = e[t], Vl(t) && (qs[t].isCSSVariable = !0) } var ro = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"], mr = new Set(ro); function ym(e, { layout: t, layoutId: r }) { return mr.has(e) || e.startsWith("origin") || (t || r !== void 0) && (!!qs[e] || e === "opacity") } var Ce = e => Boolean(e && e.getVelocity); var vm = (e, t) => t && typeof e == "number" ? t.transform(e) : e; var At = (e, t, r) => r > t ? t : r < e ? e : r; var no = { test: e => typeof e == "number", parse: parseFloat, transform: e => e }, Uo = { ...no, transform: e => At(0, 1, e) }, id = { ...no, default: 1 }; var sd = e => ({ test: t => typeof t == "string" && t.endsWith(e) && t.split(" ").length === 1, parse: parseFloat, transform: t => `${t}${e}` }), oo = sd("deg"), er = sd("%"), j = sd("px"), gk = sd("vh"), yk = sd("vw"), Dx = { ...er, parse: e => er.parse(e) / 100, transform: e => er.transform(e * 100) }; var vk = { borderWidth: j, borderTopWidth: j, borderRightWidth: j, borderBottomWidth: j, borderLeftWidth: j, borderRadius: j, radius: j, borderTopLeftRadius: j, borderTopRightRadius: j, borderBottomRightRadius: j, borderBottomLeftRadius: j, width: j, maxWidth: j, height: j, maxHeight: j, top: j, right: j, bottom: j, left: j, padding: j, paddingTop: j, paddingRight: j, paddingBottom: j, paddingLeft: j, margin: j, marginTop: j, marginRight: j, marginBottom: j, marginLeft: j, backgroundPositionX: j, backgroundPositionY: j }; var Sk = { rotate: oo, rotateX: oo, rotateY: oo, rotateZ: oo, scale: id, scaleX: id, scaleY: id, scaleZ: id, skew: oo, skewX: oo, skewY: oo, distance: j, translateX: j, translateY: j, translateZ: j, x: j, y: j, z: j, perspective: j, transformPerspective: j, opacity: Uo, originX: Dx, originY: Dx, originZ: j }; var Mx = { ...no, transform: Math.round }; var zl = { ...vk, ...Sk, zIndex: Mx, size: j, fillOpacity: Uo, strokeOpacity: Uo, numOctaves: Mx }; var eF = { x: "translateX", y: "translateY", z: "translateZ", transformPerspective: "perspective" }, tF = ro.length; function xk(e, t, r) { let n = "", o = !0; for (let i = 0; i < tF; i++) { let s = ro[i], a = e[s]; if (a === void 0) continue; let l = !0; if (typeof a == "number" ? l = a === (s.startsWith("scale") ? 1 : 0) : l = parseFloat(a) === 0, !l || r) { let c = vm(a, zl[s]); if (!l) { o = !1; let u = eF[s] || s; n += `${u}(${c}) ` } r && (t[s] = c) } } return n = n.trim(), r ? n = r(t, o ? "" : n) : o && (n = "none"), n } function Hl(e, t, r) { let { style: n, vars: o, transformOrigin: i } = e, s = !1, a = !1; for (let l in t) { let c = t[l]; if (mr.has(l)) { s = !0; continue } else if (Vl(l)) { o[l] = c; continue } else { let u = vm(c, zl[l]); l.startsWith("origin") ? (a = !0, i[l] = u) : n[l] = u } } if (t.transform || (s || r ? n.transform = xk(t, e.transform, r) : n.transform && (n.transform = "none")), a) { let { originX: l = "50%", originY: c = "50%", originZ: u = 0 } = i; n.transformOrigin = `${l} ${c} ${u}` } } var Wl = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }); function Bx(e, t, r) { for (let n in t) !Ce(t[n]) && !ym(n, r) && (e[n] = t[n]) } function rF({ transformTemplate: e }, t) { return (0, Tk.useMemo)(() => { let r = Wl(); return Hl(r, t, e), Object.assign({}, r.vars, r.style) }, [t]) } function nF(e, t) { let r = e.style || {}, n = {}; return Bx(n, r, e), Object.assign(n, rF(e, t)), n } function Ek(e, t) { let r = {}, n = nF(e, t); return e.drag && e.dragListener !== !1 && (r.draggable = !1, n.userSelect = n.WebkitUserSelect = n.WebkitTouchCallout = "none", n.touchAction = e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`), e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (r.tabIndex = 0), r.style = n, r } var Ck = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"]; function jl(e) { return typeof e != "string" || e.includes("-") ? !1 : !!(Ck.indexOf(e) > -1 || /[A-Z]/u.test(e)) } var Rk = I(P(), 1); var oF = { offset: "stroke-dashoffset", array: "stroke-dasharray" }, iF = { offset: "strokeDashoffset", array: "strokeDasharray" }; function bk(e, t, r = 1, n = 0, o = !0) { e.pathLength = 1; let i = o ? oF : iF; e[i.offset] = j.transform(-n); let s = j.transform(t), a = j.transform(r); e[i.array] = `${s} ${a}` } function wk(e, t, r) { return typeof e == "string" ? e : j.transform(t + r * e) } function Ik(e, t, r) { let n = wk(t, e.x, e.width), o = wk(r, e.y, e.height); return `${n} ${o}` } function Ul(e, { attrX: t, attrY: r, attrScale: n, originX: o, originY: i, pathLength: s, pathSpacing: a = 1, pathOffset: l = 0, ...c }, u, d) { if (Hl(e, c, d), u) { e.style.viewBox && (e.attrs.viewBox = e.style.viewBox); return } e.attrs = e.style, e.style = {}; let { attrs: f, style: p, dimensions: y } = e; f.transform && (y && (p.transform = f.transform), delete f.transform), y && (o !== void 0 || i !== void 0 || p.transform) && (p.transformOrigin = Ik(y, o !== void 0 ? o : .5, i !== void 0 ? i : .5)), t !== void 0 && (f.x = t), r !== void 0 && (f.y = r), n !== void 0 && (f.scale = n), s !== void 0 && bk(f, s, a, l, !1) } var Sm = () => ({ ...Wl(), attrs: {} }); var Gl = e => typeof e == "string" && e.toLowerCase() === "svg"; function kk(e, t, r, n) { let o = (0, Rk.useMemo)(() => { let i = Sm(); return Ul(i, t, Gl(n), e.transformTemplate), { ...i.attrs, style: { ...i.style } } }, [t]); if (e.style) { let i = {}; Bx(i, e.style, e), o.style = { ...i, ...o.style } } return o } function Ak(e = !1) { return (r, n, o, { latestValues: i }, s) => { let l = (jl(r) ? kk : Ek)(n, i, s, r), c = ek(n, typeof r == "string", e), u = r !== $l.Fragment ? { ...c, ...l, ref: o } : {}, { children: d } = n, f = (0, $l.useMemo)(() => Ce(d) ? d.get() : d, [d]); return (0, $l.createElement)(r, { ...u, children: f }) } } var Vx = I(P(), 1); function Nk(e) { let t = [{}, {}]; return e?.values.forEach((r, n) => { t[0][n] = r.get(), t[1][n] = r.getVelocity() }), t } function Kl(e, t, r, n) { if (typeof t == "function") { let [o, i] = Nk(n); t = t(r !== void 0 ? r : e.custom, o, i) } if (typeof t == "string" && (t = e.variants && e.variants[t]), typeof t == "function") { let [o, i] = Nk(n); t = t(r !== void 0 ? r : e.custom, o, i) } return t } var ad = e => Array.isArray(e); var Ok = e => Boolean(e && typeof e == "object" && e.mix && e.toValue), Pk = e => ad(e) ? e[e.length - 1] || 0 : e; function Xl(e) { let t = Ce(e) ? e.get() : e; return Ok(t) ? t.toValue() : t } function sF({ scrapeMotionValuesFromProps: e, createRenderState: t, onUpdate: r }, n, o, i) { let s = { latestValues: aF(n, o, i, e), renderState: t() }; return r && (s.onMount = a => r({ props: n, current: a, ...s }), s.onUpdate = a => r(a)), s } var xm = e => (t, r) => { let n = (0, Vx.useContext)(Gi), o = (0, Vx.useContext)(Wi), i = () => sF(e, t, n, o); return r ? i() : Dr(i) }; function aF(e, t, r, n) { let o = {}, i = n(e, {}); for (let f in i) o[f] = Xl(i[f]); let { initial: s, animate: a } = e, l = Ys(e), c = fm(e); t && c && !l && e.inherit !== !1 && (s === void 0 && (s = t.initial), a === void 0 && (a = t.animate)); let u = r ? r.initial === !1 : !1; u = u || s === !1; let d = u ? a : s; if (d && typeof d != "boolean" && !$i(d)) { let f = Array.isArray(d) ? d : [d]; for (let p = 0; p < f.length; p++) { let y = Kl(e, f[p]); if (y) { let { transitionEnd: g, transition: S, ...h } = y; for (let m in h) { let v = h[m]; if (Array.isArray(v)) { let x = u ? v.length - 1 : 0; v = v[x] } v !== null && (o[m] = v) } for (let m in g) o[m] = g[m] } } } return o } function Yl(e, t, r) { var n; let { style: o } = e, i = {}; for (let s in o) (Ce(o[s]) || t.style && Ce(t.style[s]) || ym(s, e) || ((n = r?.getValue(s)) === null || n === void 0 ? void 0 : n.liveStyle) !== void 0) && (i[s] = o[s]); return i } var Lk = { useVisualState: xm({ scrapeMotionValuesFromProps: Yl, createRenderState: Wl }) }; function Tm(e, t) { try { t.dimensions = typeof e.getBBox == "function" ? e.getBBox() : e.getBoundingClientRect() } catch { t.dimensions = { x: 0, y: 0, width: 0, height: 0 } } } function Em(e, { style: t, vars: r }, n, o) { Object.assign(e.style, t, o && o.getProjectionStyles(n)); for (let i in r) e.style.setProperty(i, r[i]) } var Cm = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]); function bm(e, t, r, n) { Em(e, t, void 0, n); for (let o in t.attrs) e.setAttribute(Cm.has(o) ? o : Dl(o), t.attrs[o]) } function wm(e, t, r) { let n = Yl(e, t, r); for (let o in e) if (Ce(e[o]) || Ce(t[o])) { let i = ro.indexOf(o) !== -1 ? "attr" + o.charAt(0).toUpperCase() + o.substring(1) : o; n[i] = e[o] } return n } var _k = ["x", "y", "width", "height", "cx", "cy", "r"], Dk = { useVisualState: xm({ scrapeMotionValuesFromProps: wm, createRenderState: Sm, onUpdate: ({ props: e, prevProps: t, current: r, renderState: n, latestValues: o }) => { if (!r) return; let i = !!e.drag; if (!i) { for (let a in o) if (mr.has(a)) { i = !0; break } } if (!i) return; let s = !t; if (t) for (let a = 0; a < _k.length; a++) { let l = _k[a]; e[l] !== t[l] && (s = !0) } s && Z.read(() => { Tm(r, n), Z.render(() => { Ul(n, o, Gl(r.tagName), e.transformTemplate), bm(r, n) }) }) } }) }; function Mk(e, t) { return function (n, { forwardMotionProps: o } = { forwardMotionProps: !1 }) { let s = { ...jl(n) ? Dk : Lk, preloadedFeatures: e, useRender: Ak(o), createVisualElement: t, Component: n }; return pk(s) } } function Go(e, t, r) { let n = e.getProps(); return Kl(n, t, r !== void 0 ? r : n.custom, e) } function ql(e, t) { return e ? e[t] || e.default || e : void 0 } var Im = new Set(["width", "height", "top", "left", "right", "bottom", ...ro]); var Rm; function lF() { Rm = void 0 } var zt = { now: () => (Rm === void 0 && zt.set(Qe.isProcessing || Xs.useManualTiming ? Qe.timestamp : performance.now()), Rm), set: e => { Rm = e, queueMicrotask(lF) } }; function Ql(e, t) { e.indexOf(t) === -1 && e.push(t) } function Ki(e, t) { let r = e.indexOf(t); r > -1 && e.splice(r, 1) } var Xi = class { constructor() { this.subscriptions = [] } add(t) { return Ql(this.subscriptions, t), () => Ki(this.subscriptions, t) } notify(t, r, n) { let o = this.subscriptions.length; if (o) if (o === 1) this.subscriptions[0](t, r, n); else for (let i = 0; i < o; i++) { let s = this.subscriptions[i]; s && s(t, r, n) } } getSize() { return this.subscriptions.length } clear() { this.subscriptions.length = 0 } }; function km(e, t) { return t ? e * (1e3 / t) : 0 } var Bk = 30, cF = e => !isNaN(parseFloat(e)), Vk = { current: void 0 }, Am = class { constructor(t, r = {}) { this.version = "12.4.9", this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (n, o = !0) => { let i = zt.now(); this.updatedAt !== i && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(n), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), o && this.events.renderRequest && this.events.renderRequest.notify(this.current) }, this.hasAnimated = !1, this.setCurrent(t), this.owner = r.owner } setCurrent(t) { this.current = t, this.updatedAt = zt.now(), this.canTrackVelocity === null && t !== void 0 && (this.canTrackVelocity = cF(this.current)) } setPrevFrameValue(t = this.current) { this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt } onChange(t) { return this.on("change", t) } on(t, r) { this.events[t] || (this.events[t] = new Xi); let n = this.events[t].add(r); return t === "change" ? () => { n(), Z.read(() => { this.events.change.getSize() || this.stop() }) } : n } clearListeners() { for (let t in this.events) this.events[t].clear() } attach(t, r) { this.passiveEffect = t, this.stopPassiveEffect = r } set(t, r = !0) { !r || !this.passiveEffect ? this.updateAndNotify(t, r) : this.passiveEffect(t, this.updateAndNotify) } setWithVelocity(t, r, n) { this.set(r), this.prev = void 0, this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt - n } jump(t, r = !0) { this.updateAndNotify(t), this.prev = t, this.prevUpdatedAt = this.prevFrameValue = void 0, r && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } get() { return Vk.current && Vk.current.push(this), this.current } getPrevious() { return this.prev } getVelocity() { let t = zt.now(); if (!this.canTrackVelocity || this.prevFrameValue === void 0 || t - this.updatedAt > Bk) return 0; let r = Math.min(this.updatedAt - this.prevUpdatedAt, Bk); return km(parseFloat(this.current) - parseFloat(this.prevFrameValue), r) } start(t) { return this.stop(), new Promise(r => { this.hasAnimated = !0, this.animation = t(r), this.events.animationStart && this.events.animationStart.notify() }).then(() => { this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation() }) } stop() { this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation() } isAnimating() { return !!this.animation } clearAnimation() { delete this.animation } destroy() { this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } }; function ft(e, t) { return new Am(e, t) } function uF(e, t, r) { e.hasValue(t) ? e.getValue(t).set(r) : e.addValue(t, ft(r)) } function Fk(e, t) { let r = Go(e, t), { transitionEnd: n = {}, transition: o = {}, ...i } = r || {}; i = { ...i, ...n }; for (let s in i) { let a = Pk(i[s]); uF(e, s, a) } } function zk(e) { return Boolean(Ce(e) && e.add) } function ld(e, t) { let r = e.getValue("willChange"); if (zk(r)) return r.add(t) } function Nm(e) { return e.props[mm] } function Zl(e) { let t; return () => (t === void 0 && (t = e()), t) } var Hk = Zl(() => window.ScrollTimeline !== void 0); var Om = class { constructor(t) { this.stop = () => this.runAll("stop"), this.animations = t.filter(Boolean) } get finished() { return Promise.all(this.animations.map(t => "finished" in t ? t.finished : t)) } getAll(t) { return this.animations[0][t] } setAll(t, r) { for (let n = 0; n < this.animations.length; n++)this.animations[n][t] = r } attachTimeline(t, r) { let n = this.animations.map(o => { if (Hk() && o.attachTimeline) return o.attachTimeline(t); if (typeof r == "function") return r(o) }); return () => { n.forEach((o, i) => { o && o(), this.animations[i].stop() }) } } get time() { return this.getAll("time") } set time(t) { this.setAll("time", t) } get speed() { return this.getAll("speed") } set speed(t) { this.setAll("speed", t) } get startTime() { return this.getAll("startTime") } get duration() { let t = 0; for (let r = 0; r < this.animations.length; r++)t = Math.max(t, this.animations[r].duration); return t } runAll(t) { this.animations.forEach(r => r[t]()) } flatten() { this.runAll("flatten") } play() { this.runAll("play") } pause() { this.runAll("pause") } cancel() { this.runAll("cancel") } complete() { this.runAll("complete") } }; var Jl = class extends Om { then(t, r) { return Promise.all(this.animations).then(t).catch(r) } }; var Tt = e => e * 1e3, Ht = e => e / 1e3; var Pm = { current: !1 }; function Yi(e) { return typeof e == "function" } function Fx(e, t) { e.timeline = t, e.onfinish = null } var cd = e => Array.isArray(e) && typeof e[0] == "number"; var Wk = { linearEasing: void 0 }; function jk(e, t) { let r = Zl(e); return () => { var n; return (n = Wk[t]) !== null && n !== void 0 ? n : r() } } var ec = jk(() => { try { document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" }) } catch { return !1 } return !0 }, "linearEasing"); var Vr = (e, t, r) => { let n = t - e; return n === 0 ? 1 : (r - e) / n }; var Lm = (e, t, r = 10) => { let n = "", o = Math.max(Math.round(t / r), 2); for (let i = 0; i < o; i++)n += e(Vr(0, o - 1, i)) + ", "; return `linear(${n.substring(0, n.length - 2)})` }; function Hx(e) { return Boolean(typeof e == "function" && ec() || !e || typeof e == "string" && (e in zx || ec()) || cd(e) || Array.isArray(e) && e.every(Hx)) } var ud = ([e, t, r, n]) => `cubic-bezier(${e}, ${t}, ${r}, ${n})`, zx = { linear: "linear", ease: "ease", easeIn: "ease-in", easeOut: "ease-out", easeInOut: "ease-in-out", circIn: ud([0, .65, .55, 1]), circOut: ud([.55, 0, 1, .45]), backIn: ud([.31, .01, .66, -.59]), backOut: ud([.33, 1.53, .69, .99]) }; function Wx(e, t) { if (e) return typeof e == "function" && ec() ? Lm(e, t) : cd(e) ? ud(e) : Array.isArray(e) ? e.map(r => Wx(r, t) || zx.easeOut) : zx[e] } var Uk = (e, t, r) => (((1 - 3 * r + 3 * t) * e + (3 * r - 6 * t)) * e + 3 * t) * e, dF = 1e-7, fF = 12; function pF(e, t, r, n, o) { let i, s, a = 0; do s = t + (r - t) / 2, i = Uk(s, n, o) - e, i > 0 ? r = s : t = s; while (Math.abs(i) > dF && ++a < fF); return s } function qi(e, t, r, n) { if (e === t && r === n) return He; let o = i => pF(i, 0, 1, e, r); return i => i === 0 || i === 1 ? i : Uk(o(i), t, n) } var _m = e => t => t <= .5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2; var Dm = e => t => 1 - e(1 - t); var jx = qi(.33, 1.53, .69, .99), dd = Dm(jx), Mm = _m(dd); var Bm = e => (e *= 2) < 1 ? .5 * dd(e) : .5 * (2 - Math.pow(2, -10 * (e - 1))); var Vm = e => 1 - Math.sin(Math.acos(e)), Fm = Dm(Vm), zm = _m(Vm); var Hm = e => /^0[^.\s]+$/u.test(e); function Gk(e) { return typeof e == "number" ? e === 0 : e !== null ? e === "none" || e === "0" || Hm(e) : !0 } var Qi = e => Math.round(e * 1e5) / 1e5; var tc = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu; function $k(e) { return e == null } var Kk = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu; var rc = (e, t) => r => Boolean(typeof r == "string" && Kk.test(r) && r.startsWith(e) || t && !$k(r) && Object.prototype.hasOwnProperty.call(r, t)), Wm = (e, t, r) => n => { if (typeof n != "string") return n; let [o, i, s, a] = n.match(tc); return { [e]: parseFloat(o), [t]: parseFloat(i), [r]: parseFloat(s), alpha: a !== void 0 ? parseFloat(a) : 1 } }; var mF = e => At(0, 255, e), Ux = { ...no, transform: e => Math.round(mF(e)) }, io = { test: rc("rgb", "red"), parse: Wm("red", "green", "blue"), transform: ({ red: e, green: t, blue: r, alpha: n = 1 }) => "rgba(" + Ux.transform(e) + ", " + Ux.transform(t) + ", " + Ux.transform(r) + ", " + Qi(Uo.transform(n)) + ")" }; function hF(e) { let t = "", r = "", n = "", o = ""; return e.length > 5 ? (t = e.substring(1, 3), r = e.substring(3, 5), n = e.substring(5, 7), o = e.substring(7, 9)) : (t = e.substring(1, 2), r = e.substring(2, 3), n = e.substring(3, 4), o = e.substring(4, 5), t += t, r += r, n += n, o += o), { red: parseInt(t, 16), green: parseInt(r, 16), blue: parseInt(n, 16), alpha: o ? parseInt(o, 16) / 255 : 1 } } var fd = { test: rc("#"), parse: hF, transform: io.transform }; var Zi = { test: rc("hsl", "hue"), parse: Wm("hue", "saturation", "lightness"), transform: ({ hue: e, saturation: t, lightness: r, alpha: n = 1 }) => "hsla(" + Math.round(e) + ", " + er.transform(Qi(t)) + ", " + er.transform(Qi(r)) + ", " + Qi(Uo.transform(n)) + ")" }; var nt = { test: e => io.test(e) || fd.test(e) || Zi.test(e), parse: e => io.test(e) ? io.parse(e) : Zi.test(e) ? Zi.parse(e) : fd.parse(e), transform: e => typeof e == "string" ? e : e.hasOwnProperty("red") ? io.transform(e) : Zi.transform(e) }; var Xk = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu; function gF(e) { var t, r; return isNaN(e) && typeof e == "string" && (((t = e.match(tc)) === null || t === void 0 ? void 0 : t.length) || 0) + (((r = e.match(Xk)) === null || r === void 0 ? void 0 : r.length) || 0) > 0 } var qk = "number", Qk = "color", yF = "var", vF = "var(", Yk = "${}", SF = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu; function Qs(e) { let t = e.toString(), r = [], n = { color: [], number: [], var: [] }, o = [], i = 0, a = t.replace(SF, l => (nt.test(l) ? (n.color.push(i), o.push(Qk), r.push(nt.parse(l))) : l.startsWith(vF) ? (n.var.push(i), o.push(yF), r.push(l)) : (n.number.push(i), o.push(qk), r.push(parseFloat(l))), ++i, Yk)).split(Yk); return { values: r, split: a, indexes: n, types: o } } function Zk(e) { return Qs(e).values } function Jk(e) { let { split: t, types: r } = Qs(e), n = t.length; return o => { let i = ""; for (let s = 0; s < n; s++)if (i += t[s], o[s] !== void 0) { let a = r[s]; a === qk ? i += Qi(o[s]) : a === Qk ? i += nt.transform(o[s]) : i += o[s] } return i } } var xF = e => typeof e == "number" ? 0 : e; function TF(e) { let t = Zk(e); return Jk(e)(t.map(xF)) } var tr = { test: gF, parse: Zk, createTransformer: Jk, getAnimatableNone: TF }; var EF = new Set(["brightness", "contrast", "saturate", "opacity"]); function CF(e) { let [t, r] = e.slice(0, -1).split("("); if (t === "drop-shadow") return e; let [n] = r.match(tc) || []; if (!n) return e; let o = r.replace(n, ""), i = EF.has(t) ? 1 : 0; return n !== r && (i *= 100), t + "(" + i + o + ")" } var bF = /\b([a-z-]*)\(.*?\)/gu, pd = { ...tr, getAnimatableNone: e => { let t = e.match(bF); return t ? t.map(CF).join(" ") : e } }; var wF = { ...zl, color: nt, backgroundColor: nt, outlineColor: nt, fill: nt, stroke: nt, borderColor: nt, borderTopColor: nt, borderRightColor: nt, borderBottomColor: nt, borderLeftColor: nt, filter: pd, WebkitFilter: pd }, nc = e => wF[e]; function jm(e, t) { let r = nc(e); return r !== pd && (r = tr), r.getAnimatableNone ? r.getAnimatableNone(t) : void 0 } var IF = new Set(["auto", "none", "0"]); function eA(e, t, r) { let n = 0, o; for (; n < e.length && !o;) { let i = e[n]; typeof i == "string" && !IF.has(i) && Qs(i).values.length && (o = e[n]), n++ } if (o && r) for (let i of t) e[i] = jm(r, o) } var Gx = e => e === no || e === j, tA = (e, t) => parseFloat(e.split(", ")[t]), rA = (e, t) => (r, { transform: n }) => { if (n === "none" || !n) return 0; let o = n.match(/^matrix3d\((.+)\)$/u); if (o) return tA(o[1], t); { let i = n.match(/^matrix\((.+)\)$/u); return i ? tA(i[1], e) : 0 } }, RF = new Set(["x", "y", "z"]), kF = ro.filter(e => !RF.has(e)); function nA(e) { let t = []; return kF.forEach(r => { let n = e.getValue(r); n !== void 0 && (t.push([r, n.get()]), n.set(r.startsWith("scale") ? 1 : 0)) }), t } var Zs = { width: ({ x: e }, { paddingLeft: t = "0", paddingRight: r = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(r), height: ({ y: e }, { paddingTop: t = "0", paddingBottom: r = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(r), top: (e, { top: t }) => parseFloat(t), left: (e, { left: t }) => parseFloat(t), bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min), right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min), x: rA(4, 13), y: rA(5, 14) }; Zs.translateX = Zs.x; Zs.translateY = Zs.y; var Js = new Set, $x = !1, Kx = !1; function oA() { if (Kx) { let e = Array.from(Js).filter(n => n.needsMeasurement), t = new Set(e.map(n => n.element)), r = new Map; t.forEach(n => { let o = nA(n); o.length && (r.set(n, o), n.render()) }), e.forEach(n => n.measureInitialState()), t.forEach(n => { n.render(); let o = r.get(n); o && o.forEach(([i, s]) => { var a; (a = n.getValue(i)) === null || a === void 0 || a.set(s) }) }), e.forEach(n => n.measureEndState()), e.forEach(n => { n.suspendedScrollY !== void 0 && window.scrollTo(0, n.suspendedScrollY) }) } Kx = !1, $x = !1, Js.forEach(e => e.complete()), Js.clear() } function iA() { Js.forEach(e => { e.readKeyframes(), e.needsMeasurement && (Kx = !0) }) } function sA() { iA(), oA() } var Ji = class { constructor(t, r, n, o, i, s = !1) { this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...t], this.onComplete = r, this.name = n, this.motionValue = o, this.element = i, this.isAsync = s } scheduleResolve() { this.isScheduled = !0, this.isAsync ? (Js.add(this), $x || ($x = !0, Z.read(iA), Z.resolveKeyframes(oA))) : (this.readKeyframes(), this.complete()) } readKeyframes() { let { unresolvedKeyframes: t, name: r, element: n, motionValue: o } = this; for (let i = 0; i < t.length; i++)if (t[i] === null) if (i === 0) { let s = o?.get(), a = t[t.length - 1]; if (s !== void 0) t[0] = s; else if (n && r) { let l = n.readValue(r, a); l != null && (t[0] = l) } t[0] === void 0 && (t[0] = a), o && s === void 0 && o.set(t[0]) } else t[i] = t[i - 1] } setFinalKeyframe() { } measureInitialState() { } renderEndStyles() { } measureEndState() { } complete() { this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), Js.delete(this) } cancel() { this.isComplete || (this.isScheduled = !1, Js.delete(this)) } resume() { this.isComplete || this.scheduleResolve() } }; var Um = e => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e); var AF = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u; function NF(e) { let t = AF.exec(e); if (!t) return [,]; let [, r, n, o] = t; return [`--${r ?? n}`, o] } var OF = 4; function Xx(e, t, r = 1) { Mr(r <= OF, `Max CSS variable fallback depth detected in property "${e}". This may indicate a circular fallback dependency.`); let [n, o] = NF(e); if (!n) return; let i = window.getComputedStyle(t).getPropertyValue(n); if (i) { let s = i.trim(); return Um(s) ? parseFloat(s) : s } return Fl(o) ? Xx(o, t, r + 1) : o } var Gm = e => t => t.test(e); var aA = { test: e => e === "auto", parse: e => e }; var Yx = [no, j, er, oo, yk, gk, aA], qx = e => Yx.find(Gm(e)); var oc = class extends Ji { constructor(t, r, n, o, i) { super(t, r, n, o, i, !0) } readKeyframes() { let { unresolvedKeyframes: t, element: r, name: n } = this; if (!r || !r.current) return; super.readKeyframes(); for (let l = 0; l < t.length; l++) { let c = t[l]; if (typeof c == "string" && (c = c.trim(), Fl(c))) { let u = Xx(c, r.current); u !== void 0 && (t[l] = u), l === t.length - 1 && (this.finalKeyframe = c) } } if (this.resolveNoneKeyframes(), !Im.has(n) || t.length !== 2) return; let [o, i] = t, s = qx(o), a = qx(i); if (s !== a) if (Gx(s) && Gx(a)) for (let l = 0; l < t.length; l++) { let c = t[l]; typeof c == "string" && (t[l] = parseFloat(c)) } else this.needsMeasurement = !0 } resolveNoneKeyframes() { let { unresolvedKeyframes: t, name: r } = this, n = []; for (let o = 0; o < t.length; o++)Gk(t[o]) && n.push(o); n.length && eA(t, n, r) } measureInitialState() { let { element: t, unresolvedKeyframes: r, name: n } = this; if (!t || !t.current) return; n === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = Zs[n](t.measureViewportBox(), window.getComputedStyle(t.current)), r[0] = this.measuredOrigin; let o = r[r.length - 1]; o !== void 0 && t.getValue(n, o).jump(o, !1) } measureEndState() { var t; let { element: r, name: n, unresolvedKeyframes: o } = this; if (!r || !r.current) return; let i = r.getValue(n); i && i.jump(this.measuredOrigin, !1); let s = o.length - 1, a = o[s]; o[s] = Zs[n](r.measureViewportBox(), window.getComputedStyle(r.current)), a !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = a), !((t = this.removedTransforms) === null || t === void 0) && t.length && this.removedTransforms.forEach(([l, c]) => { r.getValue(l).set(c) }), this.resolveNoneKeyframes() } }; var Qx = (e, t) => t === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && (tr.test(e) || e === "0") && !e.startsWith("url(")); function PF(e) { let t = e[0]; if (e.length === 1) return !0; for (let r = 0; r < e.length; r++)if (e[r] !== t) return !0 } function lA(e, t, r, n) { let o = e[0]; if (o === null) return !1; if (t === "display" || t === "visibility") return !0; let i = e[e.length - 1], s = Qx(o, t), a = Qx(i, t); return Ui(s === a, `You are trying to animate ${t} from "${o}" to "${i}". ${o} is not an animatable value - to enable this animation set ${o} to a value animatable to ${i} via the \`style\` property.`), !s || !a ? !1 : PF(e) || (r === "spring" || Yi(r)) && n } var LF = e => e !== null; function es(e, { repeat: t, repeatType: r = "loop" }, n) { let o = e.filter(LF), i = t && r !== "loop" && t % 2 === 1 ? 0 : o.length - 1; return !i || n === void 0 ? o[i] : n } var _F = 40, ic = class { constructor({ autoplay: t = !0, delay: r = 0, type: n = "keyframes", repeat: o = 0, repeatDelay: i = 0, repeatType: s = "loop", ...a }) { this.isStopped = !1, this.hasAttemptedResolve = !1, this.createdAt = zt.now(), this.options = { autoplay: t, delay: r, type: n, repeat: o, repeatDelay: i, repeatType: s, ...a }, this.updateFinishedPromise() } calcStartTime() { return this.resolvedAt ? this.resolvedAt - this.createdAt > _F ? this.resolvedAt : this.createdAt : this.createdAt } get resolved() { return !this._resolved && !this.hasAttemptedResolve && sA(), this._resolved } onKeyframesResolved(t, r) { this.resolvedAt = zt.now(), this.hasAttemptedResolve = !0; let { name: n, type: o, velocity: i, delay: s, onComplete: a, onUpdate: l, isGenerator: c } = this.options; if (!c && !lA(t, n, o, i)) if (Pm.current || !s) { l && l(es(t, this.options, r)), a && a(), this.resolveFinishedPromise(); return } else this.options.duration = 0; let u = this.initPlayback(t, r); u !== !1 && (this._resolved = { keyframes: t, finalKeyframe: r, ...u }, this.onPostResolved()) } onPostResolved() { } then(t, r) { return this.currentFinishedPromise.then(t, r) } flatten() { this.options.type = "keyframes", this.options.ease = "linear" } updateFinishedPromise() { this.currentFinishedPromise = new Promise(t => { this.resolveFinishedPromise = t }) } }; function sc(e) { let t = 0, r = 50, n = e.next(t); for (; !n.done && t < 2e4;)t += r, n = e.next(t); return t >= 2e4 ? 1 / 0 : t } var so = { layout: 0, mainThread: 0, waapi: 0 }; var ce = (e, t, r) => e + (t - e) * r; function Zx(e, t, r) { return r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? e + (t - e) * 6 * r : r < 1 / 2 ? t : r < 2 / 3 ? e + (t - e) * (2 / 3 - r) * 6 : e } function cA({ hue: e, saturation: t, lightness: r, alpha: n }) { e /= 360, t /= 100, r /= 100; let o = 0, i = 0, s = 0; if (!t) o = i = s = r; else { let a = r < .5 ? r * (1 + t) : r + t - r * t, l = 2 * r - a; o = Zx(l, a, e + 1 / 3), i = Zx(l, a, e), s = Zx(l, a, e - 1 / 3) } return { red: Math.round(o * 255), green: Math.round(i * 255), blue: Math.round(s * 255), alpha: n } } function ac(e, t) { return r => r > 0 ? t : e } var Jx = (e, t, r) => { let n = e * e, o = r * (t * t - n) + n; return o < 0 ? 0 : Math.sqrt(o) }, DF = [fd, io, Zi], MF = e => DF.find(t => t.test(e)); function uA(e) { let t = MF(e); if (Ui(Boolean(t), `'${e}' is not an animatable color. Use the equivalent color code instead.`), !Boolean(t)) return !1; let r = t.parse(e); return t === Zi && (r = cA(r)), r } var e0 = (e, t) => { let r = uA(e), n = uA(t); if (!r || !n) return ac(e, t); let o = { ...r }; return i => (o.red = Jx(r.red, n.red, i), o.green = Jx(r.green, n.green, i), o.blue = Jx(r.blue, n.blue, i), o.alpha = ce(r.alpha, n.alpha, i), io.transform(o)) }; var BF = (e, t) => r => t(e(r)), ao = (...e) => e.reduce(BF); var $m = new Set(["none", "hidden"]); function dA(e, t) { return $m.has(e) ? r => r <= 0 ? e : t : r => r >= 1 ? t : e } function VF(e, t) { return r => ce(e, t, r) } function Km(e) { return typeof e == "number" ? VF : typeof e == "string" ? Fl(e) ? ac : nt.test(e) ? e0 : HF : Array.isArray(e) ? fA : typeof e == "object" ? nt.test(e) ? e0 : FF : ac } function fA(e, t) { let r = [...e], n = r.length, o = e.map((i, s) => Km(i)(i, t[s])); return i => { for (let s = 0; s < n; s++)r[s] = o[s](i); return r } } function FF(e, t) { let r = { ...e, ...t }, n = {}; for (let o in r) e[o] !== void 0 && t[o] !== void 0 && (n[o] = Km(e[o])(e[o], t[o])); return o => { for (let i in n) r[i] = n[i](o); return r } } function zF(e, t) { var r; let n = [], o = { color: 0, var: 0, number: 0 }; for (let i = 0; i < t.values.length; i++) { let s = t.types[i], a = e.indexes[s][o[s]], l = (r = e.values[a]) !== null && r !== void 0 ? r : 0; n[i] = l, o[s]++ } return n } var HF = (e, t) => { let r = tr.createTransformer(t), n = Qs(e), o = Qs(t); return n.indexes.var.length === o.indexes.var.length && n.indexes.color.length === o.indexes.color.length && n.indexes.number.length >= o.indexes.number.length ? $m.has(e) && !o.values.length || $m.has(t) && !n.values.length ? dA(e, t) : ao(fA(zF(n, o), o.values), r) : (Ui(!0, `Complex values '${e}' and '${t}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`), ac(e, t)) }; function Xm(e, t, r) { return typeof e == "number" && typeof t == "number" && typeof r == "number" ? ce(e, t, r) : Km(e)(e, t) } var WF = 5; function Ym(e, t, r) { let n = Math.max(t - WF, 0); return km(r - e(n), t - n) } var Ve = { stiffness: 100, damping: 10, mass: 1, velocity: 0, duration: 800, bounce: .3, visualDuration: .3, restSpeed: { granular: .01, default: 2 }, restDelta: { granular: .005, default: .5 }, minDuration: .01, maxDuration: 10, minDamping: .05, maxDamping: 1 }; var t0 = .001; function pA({ duration: e = Ve.duration, bounce: t = Ve.bounce, velocity: r = Ve.velocity, mass: n = Ve.mass }) { let o, i; Ui(e <= Tt(Ve.maxDuration), "Spring duration must be 10 seconds or less"); let s = 1 - t; s = At(Ve.minDamping, Ve.maxDamping, s), e = At(Ve.minDuration, Ve.maxDuration, Ht(e)), s < 1 ? (o = c => { let u = c * s, d = u * e, f = u - r, p = qm(c, s), y = Math.exp(-d); return t0 - f / p * y }, i = c => { let d = c * s * e, f = d * r + r, p = Math.pow(s, 2) * Math.pow(c, 2) * e, y = Math.exp(-d), g = qm(Math.pow(c, 2), s); return (-o(c) + t0 > 0 ? -1 : 1) * ((f - p) * y) / g }) : (o = c => { let u = Math.exp(-c * e), d = (c - r) * e + 1; return -t0 + u * d }, i = c => { let u = Math.exp(-c * e), d = (r - c) * (e * e); return u * d }); let a = 5 / e, l = UF(o, i, a); if (e = Tt(e), isNaN(l)) return { stiffness: Ve.stiffness, damping: Ve.damping, duration: e }; { let c = Math.pow(l, 2) * n; return { stiffness: c, damping: s * 2 * Math.sqrt(n * c), duration: e } } } var jF = 12; function UF(e, t, r) { let n = r; for (let o = 1; o < jF; o++)n = n - e(n) / t(n); return n } function qm(e, t) { return e * Math.sqrt(1 - t * t) } var GF = ["duration", "bounce"], $F = ["stiffness", "damping", "mass"]; function mA(e, t) { return t.some(r => e[r] !== void 0) } function KF(e) { let t = { velocity: Ve.velocity, stiffness: Ve.stiffness, damping: Ve.damping, mass: Ve.mass, isResolvedFromDuration: !1, ...e }; if (!mA(e, $F) && mA(e, GF)) if (e.visualDuration) { let r = e.visualDuration, n = 2 * Math.PI / (r * 1.2), o = n * n, i = 2 * At(.05, 1, 1 - (e.bounce || 0)) * Math.sqrt(o); t = { ...t, mass: Ve.mass, stiffness: o, damping: i } } else { let r = pA(e); t = { ...t, ...r, mass: Ve.mass }, t.isResolvedFromDuration = !0 } return t } function lc(e = Ve.visualDuration, t = Ve.bounce) { let r = typeof e != "object" ? { visualDuration: e, keyframes: [0, 1], bounce: t } : e, { restSpeed: n, restDelta: o } = r, i = r.keyframes[0], s = r.keyframes[r.keyframes.length - 1], a = { done: !1, value: i }, { stiffness: l, damping: c, mass: u, duration: d, velocity: f, isResolvedFromDuration: p } = KF({ ...r, velocity: -Ht(r.velocity || 0) }), y = f || 0, g = c / (2 * Math.sqrt(l * u)), S = s - i, h = Ht(Math.sqrt(l / u)), m = Math.abs(S) < 5; n || (n = m ? Ve.restSpeed.granular : Ve.restSpeed.default), o || (o = m ? Ve.restDelta.granular : Ve.restDelta.default); let v; if (g < 1) { let C = qm(h, g); v = T => { let E = Math.exp(-g * h * T); return s - E * ((y + g * h * S) / C * Math.sin(C * T) + S * Math.cos(C * T)) } } else if (g === 1) v = C => s - Math.exp(-h * C) * (S + (y + h * S) * C); else { let C = h * Math.sqrt(g * g - 1); v = T => { let E = Math.exp(-g * h * T), w = Math.min(C * T, 300); return s - E * ((y + g * h * S) * Math.sinh(w) + C * S * Math.cosh(w)) / C } } let x = { calculatedDuration: p && d || null, next: C => { let T = v(C); if (p) a.done = C >= d; else { let E = 0; g < 1 && (E = C === 0 ? Tt(y) : Ym(v, C, T)); let w = Math.abs(E) <= n, k = Math.abs(s - T) <= o; a.done = w && k } return a.value = a.done ? s : T, a }, toString: () => { let C = Math.min(sc(x), 2e4), T = Lm(E => x.next(C * E).value, C, 30); return C + "ms " + T } }; return x } function n0({ keyframes: e, velocity: t = 0, power: r = .8, timeConstant: n = 325, bounceDamping: o = 10, bounceStiffness: i = 500, modifyTarget: s, min: a, max: l, restDelta: c = .5, restSpeed: u }) { let d = e[0], f = { done: !1, value: d }, p = w => a !== void 0 && w < a || l !== void 0 && w > l, y = w => a === void 0 ? l : l === void 0 || Math.abs(a - w) < Math.abs(l - w) ? a : l, g = r * t, S = d + g, h = s === void 0 ? S : s(S); h !== S && (g = h - d); let m = w => -g * Math.exp(-w / n), v = w => h + m(w), x = w => { let k = m(w), R = v(w); f.done = Math.abs(k) <= c, f.value = f.done ? h : R }, C, T, E = w => { p(f.value) && (C = w, T = lc({ keyframes: [f.value, y(f.value)], velocity: Ym(v, w, f.value), damping: o, stiffness: i, restDelta: c, restSpeed: u })) }; return E(0), { calculatedDuration: null, next: w => { let k = !1; return !T && C === void 0 && (k = !0, x(w), E(w)), C !== void 0 && w >= C ? T.next(w - C) : (!k && x(w), f) } } } var hA = qi(.42, 0, 1, 1), gA = qi(0, 0, .58, 1), Qm = qi(.42, 0, .58, 1); var Zm = e => Array.isArray(e) && typeof e[0] != "number"; var yA = { linear: He, easeIn: hA, easeInOut: Qm, easeOut: gA, circIn: Vm, circInOut: zm, circOut: Fm, backIn: dd, backInOut: Mm, backOut: jx, anticipate: Bm }, o0 = e => { if (cd(e)) { Mr(e.length === 4, "Cubic bezier arrays must contain four numerical values."); let [t, r, n, o] = e; return qi(t, r, n, o) } else if (typeof e == "string") return Mr(yA[e] !== void 0, `Invalid easing type '${e}'`), yA[e]; return e }; function XF(e, t, r) { let n = [], o = r || Xm, i = e.length - 1; for (let s = 0; s < i; s++) { let a = o(e[s], e[s + 1]); if (t) { let l = Array.isArray(t) ? t[s] || He : t; a = ao(l, a) } n.push(a) } return n } function Jm(e, t, { clamp: r = !0, ease: n, mixer: o } = {}) { let i = e.length; if (Mr(i === t.length, "Both input and output ranges must be the same length"), i === 1) return () => t[0]; if (i === 2 && t[0] === t[1]) return () => t[1]; let s = e[0] === e[1]; e[0] > e[i - 1] && (e = [...e].reverse(), t = [...t].reverse()); let a = XF(t, n, o), l = a.length, c = u => { if (s && u < e[0]) return t[0]; let d = 0; if (l > 1) for (; d < e.length - 2 && !(u < e[d + 1]); d++); let f = Vr(e[d], e[d + 1], u); return a[d](f) }; return r ? u => c(At(e[0], e[i - 1], u)) : c } function eh(e, t) { let r = e[e.length - 1]; for (let n = 1; n <= t; n++) { let o = Vr(0, t, n); e.push(ce(r, 1, o)) } } function th(e) { let t = [0]; return eh(t, e.length - 1), t } function vA(e, t) { return e.map(r => r * t) } function YF(e, t) { return e.map(() => t || Qm).splice(0, e.length - 1) } function md({ duration: e = 300, keyframes: t, times: r, ease: n = "easeInOut" }) { let o = Zm(n) ? n.map(o0) : o0(n), i = { done: !1, value: t[0] }, s = vA(r && r.length === t.length ? r : th(t), e), a = Jm(s, t, { ease: Array.isArray(o) ? o : YF(t, o) }); return { calculatedDuration: e, next: l => (i.value = a(l), i.done = l >= e, i) } } var SA = e => { let t = ({ timestamp: r }) => e(r); return { start: () => Z.update(t, !0), stop: () => fr(t), now: () => Qe.isProcessing ? Qe.timestamp : zt.now() } }; var qF = { decay: n0, inertia: n0, tween: md, keyframes: md, spring: lc }, QF = e => e / 100, ea = class extends ic { constructor(t) { super(t), this.holdTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.startTime = null, this.state = "idle", this.stop = () => { if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle") return; this.teardown(); let { onStop: l } = this.options; l && l() }; let { name: r, motionValue: n, element: o, keyframes: i } = this.options, s = o?.KeyframeResolver || Ji, a = (l, c) => this.onKeyframesResolved(l, c); this.resolver = new s(i, a, r, n, o), this.resolver.scheduleResolve() } flatten() { super.flatten(), this._resolved && Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes)) } initPlayback(t) { let { type: r = "keyframes", repeat: n = 0, repeatDelay: o = 0, repeatType: i, velocity: s = 0 } = this.options, a = Yi(r) ? r : qF[r] || md, l, c; a !== md && typeof t[0] != "number" && (l = ao(QF, Xm(t[0], t[1])), t = [0, 100]); let u = a({ ...this.options, keyframes: t }); i === "mirror" && (c = a({ ...this.options, keyframes: [...t].reverse(), velocity: -s })), u.calculatedDuration === null && (u.calculatedDuration = sc(u)); let { calculatedDuration: d } = u, f = d + o, p = f * (n + 1) - o; return { generator: u, mirroredGenerator: c, mapPercentToKeyframes: l, calculatedDuration: d, resolvedDuration: f, totalDuration: p } } onPostResolved() { let { autoplay: t = !0 } = this.options; so.mainThread++, this.play(), this.pendingPlayState === "paused" || !t ? this.pause() : this.state = this.pendingPlayState } tick(t, r = !1) { let { resolved: n } = this; if (!n) { let { keyframes: w } = this.options; return { done: !0, value: w[w.length - 1] } } let { finalKeyframe: o, generator: i, mirroredGenerator: s, mapPercentToKeyframes: a, keyframes: l, calculatedDuration: c, totalDuration: u, resolvedDuration: d } = n; if (this.startTime === null) return i.next(0); let { delay: f, repeat: p, repeatType: y, repeatDelay: g, onUpdate: S } = this.options; this.speed > 0 ? this.startTime = Math.min(this.startTime, t) : this.speed < 0 && (this.startTime = Math.min(t - u / this.speed, this.startTime)), r ? this.currentTime = t : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(t - this.startTime) * this.speed; let h = this.currentTime - f * (this.speed >= 0 ? 1 : -1), m = this.speed >= 0 ? h < 0 : h > u; this.currentTime = Math.max(h, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = u); let v = this.currentTime, x = i; if (p) { let w = Math.min(this.currentTime, u) / d, k = Math.floor(w), R = w % 1; !R && w >= 1 && (R = 1), R === 1 && k--, k = Math.min(k, p + 1), Boolean(k % 2) && (y === "reverse" ? (R = 1 - R, g && (R -= g / d)) : y === "mirror" && (x = s)), v = At(0, 1, R) * d } let C = m ? { done: !1, value: l[0] } : x.next(v); a && (C.value = a(C.value)); let { done: T } = C; !m && c !== null && (T = this.speed >= 0 ? this.currentTime >= u : this.currentTime <= 0); let E = this.holdTime === null && (this.state === "finished" || this.state === "running" && T); return E && o !== void 0 && (C.value = es(l, this.options, o)), S && S(C.value), E && this.finish(), C } get duration() { let { resolved: t } = this; return t ? Ht(t.calculatedDuration) : 0 } get time() { return Ht(this.currentTime) } set time(t) { t = Tt(t), this.currentTime = t, this.holdTime !== null || this.speed === 0 ? this.holdTime = t : this.driver && (this.startTime = this.driver.now() - t / this.speed) } get speed() { return this.playbackSpeed } set speed(t) { let r = this.playbackSpeed !== t; this.playbackSpeed = t, r && (this.time = Ht(this.currentTime)) } play() { if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) { this.pendingPlayState = "running"; return } if (this.isStopped) return; let { driver: t = SA, onPlay: r, startTime: n } = this.options; this.driver || (this.driver = t(i => this.tick(i))), r && r(); let o = this.driver.now(); this.holdTime !== null ? this.startTime = o - this.holdTime : this.startTime ? this.state === "finished" && (this.startTime = o) : this.startTime = n ?? this.calcStartTime(), this.state === "finished" && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start() } pause() { var t; if (!this._resolved) { this.pendingPlayState = "paused"; return } this.state = "paused", this.holdTime = (t = this.currentTime) !== null && t !== void 0 ? t : 0 } complete() { this.state !== "running" && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null } finish() { this.teardown(), this.state = "finished"; let { onComplete: t } = this.options; t && t() } cancel() { this.cancelTime !== null && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise() } teardown() { this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel(), so.mainThread-- } stopDriver() { this.driver && (this.driver.stop(), this.driver = void 0) } sample(t) { return this.startTime = 0, this.tick(t, !0) } }; var xA = new Set(["opacity", "clipPath", "filter", "transform"]); function TA(e, t, r, { delay: n = 0, duration: o = 300, repeat: i = 0, repeatType: s = "loop", ease: a = "easeInOut", times: l } = {}) { let c = { [t]: r }; l && (c.offset = l); let u = Wx(a, o); Array.isArray(u) && (c.easing = u), Br.value && so.waapi++; let d = e.animate(c, { delay: n, duration: o, easing: Array.isArray(u) ? "linear" : u, fill: "both", iterations: i + 1, direction: s === "reverse" ? "alternate" : "normal" }); return Br.value && d.finished.finally(() => { so.waapi-- }), d } var EA = Zl(() => Object.hasOwnProperty.call(Element.prototype, "animate")); var rh = 10, ZF = 2e4; function JF(e) { return Yi(e.type) || e.type === "spring" || !Hx(e.ease) } function ez(e, t) { let r = new ea({ ...t, keyframes: e, repeat: 0, delay: 0, isGenerator: !0 }), n = { done: !1, value: e[0] }, o = [], i = 0; for (; !n.done && i < ZF;)n = r.sample(i), o.push(n.value), i += rh; return { times: void 0, keyframes: o, duration: i - rh, ease: "linear" } } var CA = { anticipate: Bm, backInOut: Mm, circInOut: zm }; function tz(e) { return e in CA } var hd = class extends ic { constructor(t) { super(t); let { name: r, motionValue: n, element: o, keyframes: i } = this.options; this.resolver = new oc(i, (s, a) => this.onKeyframesResolved(s, a), r, n, o), this.resolver.scheduleResolve() } initPlayback(t, r) { let { duration: n = 300, times: o, ease: i, type: s, motionValue: a, name: l, startTime: c } = this.options; if (!a.owner || !a.owner.current) return !1; if (typeof i == "string" && ec() && tz(i) && (i = CA[i]), JF(this.options)) { let { onComplete: d, onUpdate: f, motionValue: p, element: y, ...g } = this.options, S = ez(t, g); t = S.keyframes, t.length === 1 && (t[1] = t[0]), n = S.duration, o = S.times, i = S.ease, s = "keyframes" } let u = TA(a.owner.current, l, t, { ...this.options, duration: n, times: o, ease: i }); return u.startTime = c ?? this.calcStartTime(), this.pendingTimeline ? (Fx(u, this.pendingTimeline), this.pendingTimeline = void 0) : u.onfinish = () => { let { onComplete: d } = this.options; a.set(es(t, this.options, r)), d && d(), this.cancel(), this.resolveFinishedPromise() }, { animation: u, duration: n, times: o, type: s, ease: i, keyframes: t } } get duration() { let { resolved: t } = this; if (!t) return 0; let { duration: r } = t; return Ht(r) } get time() { let { resolved: t } = this; if (!t) return 0; let { animation: r } = t; return Ht(r.currentTime || 0) } set time(t) { let { resolved: r } = this; if (!r) return; let { animation: n } = r; n.currentTime = Tt(t) } get speed() { let { resolved: t } = this; if (!t) return 1; let { animation: r } = t; return r.playbackRate } set speed(t) { let { resolved: r } = this; if (!r) return; let { animation: n } = r; n.playbackRate = t } get state() { let { resolved: t } = this; if (!t) return "idle"; let { animation: r } = t; return r.playState } get startTime() { let { resolved: t } = this; if (!t) return null; let { animation: r } = t; return r.startTime } attachTimeline(t) { if (!this._resolved) this.pendingTimeline = t; else { let { resolved: r } = this; if (!r) return He; let { animation: n } = r; Fx(n, t) } return He } play() { if (this.isStopped) return; let { resolved: t } = this; if (!t) return; let { animation: r } = t; r.playState === "finished" && this.updateFinishedPromise(), r.play() } pause() { let { resolved: t } = this; if (!t) return; let { animation: r } = t; r.pause() } stop() { if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle") return; this.resolveFinishedPromise(), this.updateFinishedPromise(); let { resolved: t } = this; if (!t) return; let { animation: r, keyframes: n, duration: o, type: i, ease: s, times: a } = t; if (r.playState === "idle" || r.playState === "finished") return; if (this.time) { let { motionValue: c, onUpdate: u, onComplete: d, element: f, ...p } = this.options, y = new ea({ ...p, keyframes: n, duration: o, type: i, ease: s, times: a, isGenerator: !0 }), g = Tt(this.time); c.setWithVelocity(y.sample(g - rh).value, y.sample(g).value, rh) } let { onStop: l } = this.options; l && l(), this.cancel() } complete() { let { resolved: t } = this; t && t.animation.finish() } cancel() { let { resolved: t } = this; t && t.animation.cancel() } static supports(t) { let { motionValue: r, name: n, repeatDelay: o, repeatType: i, damping: s, type: a } = t; if (!r || !r.owner || !(r.owner.current instanceof HTMLElement)) return !1; let { onUpdate: l, transformTemplate: c } = r.owner.getProps(); return EA() && n && xA.has(n) && !l && !c && !o && i !== "mirror" && s !== 0 && a !== "inertia" } }; var rz = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 }, nz = e => ({ type: "spring", stiffness: 550, damping: e === 0 ? 2 * Math.sqrt(550) : 30, restSpeed: 10 }), oz = { type: "keyframes", duration: .8 }, iz = { type: "keyframes", ease: [.25, .1, .35, 1], duration: .3 }, bA = (e, { keyframes: t }) => t.length > 2 ? oz : mr.has(e) ? e.startsWith("scale") ? nz(t[1]) : rz : iz; function wA({ when: e, delay: t, delayChildren: r, staggerChildren: n, staggerDirection: o, repeat: i, repeatType: s, repeatDelay: a, from: l, elapsed: c, ...u }) { return !!Object.keys(u).length } var cc = (e, t, r, n = {}, o, i) => s => { let a = ql(n, e) || {}, l = a.delay || n.delay || 0, { elapsed: c = 0 } = n; c = c - Tt(l); let u = { keyframes: Array.isArray(r) ? r : [null, r], ease: "easeOut", velocity: t.getVelocity(), ...a, delay: -c, onUpdate: f => { t.set(f), a.onUpdate && a.onUpdate(f) }, onComplete: () => { s(), a.onComplete && a.onComplete() }, name: e, motionValue: t, element: i ? void 0 : o }; wA(a) || (u = { ...u, ...bA(e, u) }), u.duration && (u.duration = Tt(u.duration)), u.repeatDelay && (u.repeatDelay = Tt(u.repeatDelay)), u.from !== void 0 && (u.keyframes[0] = u.from); let d = !1; if ((u.type === !1 || u.duration === 0 && !u.repeatDelay) && (u.duration = 0, u.delay === 0 && (d = !0)), (Pm.current || Xs.skipAnimations) && (d = !0, u.duration = 0, u.delay = 0), d && !i && t.get() !== void 0) { let f = es(u.keyframes, a); if (f !== void 0) return Z.update(() => { u.onUpdate(f), u.onComplete() }), new Jl([]) } return !i && hd.supports(u) ? new hd(u) : new ea(u) }; function sz({ protectedKeys: e, needsAnimating: t }, r) { let n = e.hasOwnProperty(r) && t[r] !== !0; return t[r] = !1, n } function uc(e, t, { delay: r = 0, transitionOverride: n, type: o } = {}) { var i; let { transition: s = e.getDefaultTransition(), transitionEnd: a, ...l } = t; n && (s = n); let c = [], u = o && e.animationState && e.animationState.getState()[o]; for (let d in l) { let f = e.getValue(d, (i = e.latestValues[d]) !== null && i !== void 0 ? i : null), p = l[d]; if (p === void 0 || u && sz(u, d)) continue; let y = { delay: r, ...ql(s || {}, d) }, g = !1; if (window.MotionHandoffAnimation) { let h = Nm(e); if (h) { let m = window.MotionHandoffAnimation(h, d, Z); m !== null && (y.startTime = m, g = !0) } } ld(e, d), f.start(cc(d, f, p, e.shouldReduceMotion && Im.has(d) ? { type: !1 } : y, e, g)); let S = f.animation; S && c.push(S) } return a && Promise.all(c).then(() => { Z.update(() => { a && Fk(e, a) }) }), c } function nh(e, t, r = {}) { var n; let o = Go(e, t, r.type === "exit" ? (n = e.presenceContext) === null || n === void 0 ? void 0 : n.custom : void 0), { transition: i = e.getDefaultTransition() || {} } = o || {}; r.transitionOverride && (i = r.transitionOverride); let s = o ? () => Promise.all(uc(e, o, r)) : () => Promise.resolve(), a = e.variantChildren && e.variantChildren.size ? (c = 0) => { let { delayChildren: u = 0, staggerChildren: d, staggerDirection: f } = i; return az(e, t, u + c, d, f, r) } : () => Promise.resolve(), { when: l } = i; if (l) { let [c, u] = l === "beforeChildren" ? [s, a] : [a, s]; return c().then(() => u()) } else return Promise.all([s(), a(r.delay)]) } function az(e, t, r = 0, n = 0, o = 1, i) { let s = [], a = (e.variantChildren.size - 1) * n, l = o === 1 ? (c = 0) => c * n : (c = 0) => a - c * n; return Array.from(e.variantChildren).sort(lz).forEach((c, u) => { c.notify("AnimationStart", t), s.push(nh(c, t, { ...i, delay: r + l(u) }).then(() => c.notify("AnimationComplete", t))) }), Promise.all(s) } function lz(e, t) { return e.sortNodePosition(t) } function IA(e, t, r = {}) { e.notify("AnimationStart", t); let n; if (Array.isArray(t)) { let o = t.map(i => nh(e, i, r)); n = Promise.all(o) } else if (typeof t == "string") n = nh(e, t, r); else { let o = typeof t == "function" ? Go(e, t, r.custom) : t; n = Promise.all(uc(e, o, r)) } return n.then(() => { e.notify("AnimationComplete", t) }) } function i0(e, t) { if (!Array.isArray(t)) return !1; let r = t.length; if (r !== e.length) return !1; for (let n = 0; n < r; n++)if (t[n] !== e[n]) return !1; return !0 } var cz = od.length; function s0(e) { if (!e) return; if (!e.isControllingVariants) { let r = e.parent ? s0(e.parent) || {} : {}; return e.props.initial !== void 0 && (r.initial = e.props.initial), r } let t = {}; for (let r = 0; r < cz; r++) { let n = od[r], o = e.props[n]; (Wo(o) || o === !1) && (t[n] = o) } return t } var uz = [...dm].reverse(), dz = dm.length; function fz(e) { return t => Promise.all(t.map(({ animation: r, options: n }) => IA(e, r, n))) } function kA(e) { let t = fz(e), r = RA(), n = !0, o = l => (c, u) => { var d; let f = Go(e, u, l === "exit" ? (d = e.presenceContext) === null || d === void 0 ? void 0 : d.custom : void 0); if (f) { let { transition: p, transitionEnd: y, ...g } = f; c = { ...c, ...g, ...y } } return c }; function i(l) { t = l(e) } function s(l) { let { props: c } = e, u = s0(e.parent) || {}, d = [], f = new Set, p = {}, y = 1 / 0; for (let S = 0; S < dz; S++) { let h = uz[S], m = r[h], v = c[h] !== void 0 ? c[h] : u[h], x = Wo(v), C = h === l ? m.isActive : null; C === !1 && (y = S); let T = v === u[h] && v !== c[h] && x; if (T && n && e.manuallyAnimateOnMount && (T = !1), m.protectedKeys = { ...p }, !m.isActive && C === null || !v && !m.prevProp || $i(v) || typeof v == "boolean") continue; let E = pz(m.prevProp, v), w = E || h === l && m.isActive && !T && x || S > y && x, k = !1, R = Array.isArray(v) ? v : [v], A = R.reduce(o(h), {}); C === !1 && (A = {}); let { prevResolvedValues: N = {} } = m, O = { ...N, ...A }, D = B => { w = !0, f.has(B) && (k = !0, f.delete(B)), m.needsAnimating[B] = !0; let z = e.getValue(B); z && (z.liveStyle = !1) }; for (let B in O) { let z = A[B], Q = N[B]; if (p.hasOwnProperty(B)) continue; let se = !1; ad(z) && ad(Q) ? se = !i0(z, Q) : se = z !== Q, se ? z != null ? D(B) : f.add(B) : z !== void 0 && f.has(B) ? D(B) : m.protectedKeys[B] = !0 } m.prevProp = v, m.prevResolvedValues = A, m.isActive && (p = { ...p, ...A }), n && e.blockInitialAnimation && (w = !1), w && (!(T && E) || k) && d.push(...R.map(B => ({ animation: B, options: { type: h } }))) } if (f.size) { let S = {}; if (typeof c.initial != "boolean") { let h = Go(e, Array.isArray(c.initial) ? c.initial[0] : c.initial); h && h.transition && (S.transition = h.transition) } f.forEach(h => { let m = e.getBaseTarget(h), v = e.getValue(h); v && (v.liveStyle = !0), S[h] = m ?? null }), d.push({ animation: S }) } let g = Boolean(d.length); return n && (c.initial === !1 || c.initial === c.animate) && !e.manuallyAnimateOnMount && (g = !1), n = !1, g ? t(d) : Promise.resolve() } function a(l, c) { var u; if (r[l].isActive === c) return Promise.resolve(); (u = e.variantChildren) === null || u === void 0 || u.forEach(f => { var p; return (p = f.animationState) === null || p === void 0 ? void 0 : p.setActive(l, c) }), r[l].isActive = c; let d = s(l); for (let f in r) r[f].protectedKeys = {}; return d } return { animateChanges: s, setActive: a, setAnimateFunction: i, getState: () => r, reset: () => { r = RA(), n = !0 } } } function pz(e, t) { return typeof t == "string" ? t !== e : Array.isArray(t) ? !i0(t, e) : !1 } function ta(e = !1) { return { isActive: e, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} } } function RA() { return { animate: ta(!0), whileInView: ta(), whileHover: ta(), whileTap: ta(), whileDrag: ta(), whileFocus: ta(), exit: ta() } } var Et = class { constructor(t) { this.isMounted = !1, this.node = t } update() { } }; var oh = class extends Et { constructor(t) { super(t), t.animationState || (t.animationState = kA(t)) } updateAnimationControlsSubscription() { let { animate: t } = this.node.getProps(); $i(t) && (this.unmountControls = t.subscribe(this.node)) } mount() { this.updateAnimationControlsSubscription() } update() { let { animate: t } = this.node.getProps(), { animate: r } = this.node.prevProps || {}; t !== r && this.updateAnimationControlsSubscription() } unmount() { var t; this.node.animationState.reset(), (t = this.unmountControls) === null || t === void 0 || t.call(this) } }; var mz = 0, ih = class extends Et { constructor() { super(...arguments), this.id = mz++ } update() { if (!this.node.presenceContext) return; let { isPresent: t, onExitComplete: r } = this.node.presenceContext, { isPresent: n } = this.node.prevPresenceContext || {}; if (!this.node.animationState || t === n) return; let o = this.node.animationState.setActive("exit", !t); r && !t && o.then(() => { r(this.id) }) } mount() { let { register: t, onExitComplete: r } = this.node.presenceContext || {}; r && r(this.id), t && (this.unmount = t(this.id)) } unmount() { } }; var AA = { animation: { Feature: oh }, exit: { Feature: ih } }; var en = { x: !1, y: !1 }; function sh() { return en.x || en.y } function NA(e) { return e === "x" || e === "y" ? en[e] ? null : (en[e] = !0, () => { en[e] = !1 }) : en.x || en.y ? null : (en.x = en.y = !0, () => { en.x = en.y = !1 }) } function $o(e, t, r, n = { passive: !0 }) { return e.addEventListener(t, r, n), () => e.removeEventListener(t, r) } var dc = e => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1; function Ko(e) { return { point: { x: e.pageX, y: e.pageY } } } var OA = e => t => dc(t) && e(t, Ko(t)); function Xo(e, t, r, n) { return $o(e, t, OA(r), n) } function ah({ top: e, left: t, right: r, bottom: n }) { return { x: { min: t, max: r }, y: { min: e, max: n } } } function PA({ x: e, y: t }) { return { top: t.min, right: e.max, bottom: t.max, left: e.min } } function LA(e, t) { if (!t) return e; let r = t({ x: e.left, y: e.top }), n = t({ x: e.right, y: e.bottom }); return { top: r.y, left: r.x, bottom: n.y, right: n.x } } var BA = 1e-4, hz = 1 - BA, gz = 1 + BA, VA = .01, yz = 0 - VA, vz = 0 + VA; function pt(e) { return e.max - e.min } function FA(e, t, r) { return Math.abs(e - t) <= r } function _A(e, t, r, n = .5) { e.origin = n, e.originPoint = ce(t.min, t.max, e.origin), e.scale = pt(r) / pt(t), e.translate = ce(r.min, r.max, e.origin) - e.originPoint, (e.scale >= hz && e.scale <= gz || isNaN(e.scale)) && (e.scale = 1), (e.translate >= yz && e.translate <= vz || isNaN(e.translate)) && (e.translate = 0) } function fc(e, t, r, n) { _A(e.x, t.x, r.x, n ? n.originX : void 0), _A(e.y, t.y, r.y, n ? n.originY : void 0) } function DA(e, t, r) { e.min = r.min + t.min, e.max = e.min + pt(t) } function zA(e, t, r) { DA(e.x, t.x, r.x), DA(e.y, t.y, r.y) } function MA(e, t, r) { e.min = t.min - r.min, e.max = e.min + pt(t) } function pc(e, t, r) { MA(e.x, t.x, r.x), MA(e.y, t.y, r.y) } var HA = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }), ra = () => ({ x: HA(), y: HA() }), WA = () => ({ min: 0, max: 0 }), Ne = () => ({ x: WA(), y: WA() }); function hr(e) { return [e("x"), e("y")] } function a0(e) { return e === void 0 || e === 1 } function lh({ scale: e, scaleX: t, scaleY: r }) { return !a0(e) || !a0(t) || !a0(r) } function Yo(e) { return lh(e) || l0(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY } function l0(e) { return jA(e.x) || jA(e.y) } function jA(e) { return e && e !== "0%" } function gd(e, t, r) { let n = e - r, o = t * n; return r + o } function UA(e, t, r, n, o) { return o !== void 0 && (e = gd(e, o, n)), gd(e, r, n) + t } function c0(e, t = 0, r = 1, n, o) { e.min = UA(e.min, t, r, n, o), e.max = UA(e.max, t, r, n, o) } function u0(e, { x: t, y: r }) { c0(e.x, t.translate, t.scale, t.originPoint), c0(e.y, r.translate, r.scale, r.originPoint) } var GA = .999999999999, $A = 1.0000000000001; function XA(e, t, r, n = !1) { let o = r.length; if (!o) return; t.x = t.y = 1; let i, s; for (let a = 0; a < o; a++) { i = r[a], s = i.projectionDelta; let { visualElement: l } = i.options; l && l.props.style && l.props.style.display === "contents" || (n && i.options.layoutScroll && i.scroll && i !== i.root && na(e, { x: -i.scroll.offset.x, y: -i.scroll.offset.y }), s && (t.x *= s.x.scale, t.y *= s.y.scale, u0(e, s)), n && Yo(i.latestValues) && na(e, i.latestValues)) } t.x < $A && t.x > GA && (t.x = 1), t.y < $A && t.y > GA && (t.y = 1) } function ts(e, t) { e.min = e.min + t, e.max = e.max + t } function KA(e, t, r, n, o = .5) { let i = ce(e.min, e.max, o); c0(e, t, r, i, n) } function na(e, t) { KA(e.x, t.x, t.scaleX, t.scale, t.originX), KA(e.y, t.y, t.scaleY, t.scale, t.originY) } function d0(e, t) { return ah(LA(e.getBoundingClientRect(), t)) } function YA(e, t, r) { let n = d0(e, r), { scroll: o } = t; return o && (ts(n.x, o.offset.x), ts(n.y, o.offset.y)), n } function oa(e, t) { let r = `${t}PointerCapture`; if (e.target instanceof Element && r in e.target && e.pointerId !== void 0) try { e.target[r](e.pointerId) } catch { } } var qA = (e, t) => Math.abs(e - t); function QA(e, t) { let r = qA(e.x, t.x), n = qA(e.y, t.y); return Math.sqrt(r ** 2 + n ** 2) } var mc = class { constructor(t, r, { transformPagePoint: n, dragSnapToOrigin: o = !1 } = {}) { if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.updatePoint = () => { if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return; let u = p0(this.lastMoveEventInfo, this.history), d = this.startEvent !== null, f = QA(u.offset, { x: 0, y: 0 }) >= 3; if (!d && !f) return; let { point: p } = u, { timestamp: y } = Qe; this.history.push({ ...p, timestamp: y }); let { onStart: g, onMove: S } = this.handlers; d || (g && g(this.lastMoveEvent, u), this.startEvent = this.lastMoveEvent), S && S(this.lastMoveEvent, u) }, this.handlePointerMove = (u, d) => { if (this.index = JA(u.currentTarget), u.target instanceof Element && u.target.hasPointerCapture && u.pointerId !== void 0) try { if (!u.target.hasPointerCapture(u.pointerId)) return } catch { } this.lastMoveEvent = u, this.lastMoveEventInfo = f0(d, this.transformPagePoint), Z.update(this.updatePoint, !0) }, this.handlePointerUp = (u, d) => { oa(u, "release"), this.end(); let { onEnd: f, onSessionEnd: p, resumeAnimation: y } = this.handlers; if (this.dragSnapToOrigin && y && y(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return; let g = p0(u.type === "pointercancel" || u.type === "lostpointercapture" ? this.lastMoveEventInfo : f0(d, this.transformPagePoint), this.history); this.startEvent && f && f(u, g), p && p(u, g) }, !dc(t)) return; this.dragSnapToOrigin = o, this.handlers = r, this.transformPagePoint = n; let i = Ko(t), s = f0(i, this.transformPagePoint), { point: a } = s, { timestamp: l } = Qe; this.history = [{ ...a, timestamp: l }]; let { onSessionStart: c } = r; c && c(t, p0(s, this.history)), oa(t, "set"), this.removeListeners = ao(Xo(t.currentTarget, "pointermove", this.handlePointerMove), Xo(t.currentTarget, "pointerup", this.handlePointerUp), Xo(t.currentTarget, "pointercancel", this.handlePointerUp), Xo(t.currentTarget, "lostpointercapture", (u, d) => { JA(u.currentTarget) !== this.index ? oa(u, "set") : this.handlePointerUp(u, d) })) } updateHandlers(t) { this.handlers = t } end() { this.removeListeners && this.removeListeners(), fr(this.updatePoint) } }; function f0(e, t) { return t ? { point: t(e.point) } : e } function ZA(e, t) { return { x: e.x - t.x, y: e.y - t.y } } function p0({ point: e }, t) { return { point: e, delta: ZA(e, eN(t)), offset: ZA(e, Sz(t)), velocity: xz(t, .1) } } function Sz(e) { return e[0] } function eN(e) { return e[e.length - 1] } function xz(e, t) { if (e.length < 2) return { x: 0, y: 0 }; let r = e.length - 1, n = null, o = eN(e); for (; r >= 0 && (n = e[r], !(o.timestamp - n.timestamp > Tt(t)));)r--; if (!n) return { x: 0, y: 0 }; let i = Ht(o.timestamp - n.timestamp); if (i === 0) return { x: 0, y: 0 }; let s = { x: (o.x - n.x) / i, y: (o.y - n.y) / i }; return s.x === 1 / 0 && (s.x = 0), s.y === 1 / 0 && (s.y = 0), s } function JA(e) { return e.parentNode ? Array.from(e.parentNode.children).indexOf(e) : -1 } function iN(e, { min: t, max: r }, n) { return t !== void 0 && e < t ? e = n ? ce(t, e, n.min) : Math.max(e, t) : r !== void 0 && e > r && (e = n ? ce(r, e, n.max) : Math.min(e, r)), e } function tN(e, t, r) { return { min: t !== void 0 ? e.min + t : void 0, max: r !== void 0 ? e.max + r - (e.max - e.min) : void 0 } } function sN(e, { top: t, left: r, bottom: n, right: o }) { return { x: tN(e.x, r, o), y: tN(e.y, t, n) } } function rN(e, t) { let r = t.min - e.min, n = t.max - e.max; return t.max - t.min < e.max - e.min && ([r, n] = [n, r]), { min: r, max: n } } function aN(e, t) { return { x: rN(e.x, t.x), y: rN(e.y, t.y) } } function lN(e, t) { let r = .5, n = pt(e), o = pt(t); return o > n ? r = Vr(t.min, t.max - n, e.min) : n > o && (r = Vr(e.min, e.max - o, t.min)), At(0, 1, r) } function cN(e, t) { let r = {}; return t.min !== void 0 && (r.min = t.min - e.min), t.max !== void 0 && (r.max = t.max - e.min), r } var ch = .35; function uN(e = ch) { return e === !1 ? e = 0 : e === !0 && (e = ch), { x: nN(e, "left", "right"), y: nN(e, "top", "bottom") } } function nN(e, t, r) { return { min: oN(e, t), max: oN(e, r) } } function oN(e, t) { return typeof e == "number" ? e : e[t] || 0 } var Tz = new WeakMap, dh = class { constructor(t) { this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = Ne(), this.visualElement = t } start(t, { snapToCursor: r = !1 } = {}) { let { presenceContext: n } = this.visualElement; if (n && n.isPresent === !1) return; let o = u => { let { dragSnapToOrigin: d } = this.getProps(); d ? this.pauseAnimation() : this.stopAnimation(), r && this.snapToCursor(Ko(u).point) }, i = (u, d) => { let { drag: f, dragPropagation: p, onDragStart: y } = this.getProps(); if (f && !p && (this.openDragLock && this.openDragLock(), this.openDragLock = NA(f), !this.openDragLock)) return; this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), hr(S => { let h = this.getAxisMotionValue(S).get() || 0; if (er.test(h)) { let { projection: m } = this.visualElement; if (m && m.layout) { let v = m.layout.layoutBox[S]; v && (h = pt(v) * (parseFloat(h) / 100)) } } this.originPoint[S] = h }), y && Z.postRender(() => y(u, d)), ld(this.visualElement, "transform"); let { animationState: g } = this.visualElement; g && g.setActive("whileDrag", !0) }, s = (u, d) => { let { dragPropagation: f, dragDirectionLock: p, onDirectionLock: y, onDrag: g } = this.getProps(); if (!f && !this.openDragLock) return; let { offset: S } = d; if (p && this.currentDirection === null) { this.currentDirection = Ez(S), this.currentDirection !== null && y && y(this.currentDirection); return } this.updateAxis("x", d.point, S), this.updateAxis("y", d.point, S), this.visualElement.render(), g && g(u, d) }, a = (u, d) => this.stop(u, d), l = () => hr(u => { var d; return this.getAnimationState(u) === "paused" && ((d = this.getAxisMotionValue(u).animation) === null || d === void 0 ? void 0 : d.play()) }), { dragSnapToOrigin: c } = this.getProps(); this.panSession = new mc(t, { onSessionStart: o, onStart: i, onMove: s, onSessionEnd: a, resumeAnimation: l }, { transformPagePoint: this.visualElement.getTransformPagePoint(), dragSnapToOrigin: c }) } stop(t, r) { let n = this.isDragging; if (this.cancel(), !n) return; let { velocity: o } = r; this.startAnimation(o); let { onDragEnd: i } = this.getProps(); i && Z.postRender(() => i(t, r)) } cancel() { this.isDragging = !1; let { projection: t, animationState: r } = this.visualElement; t && (t.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0; let { dragPropagation: n } = this.getProps(); !n && this.openDragLock && (this.openDragLock(), this.openDragLock = null), r && r.setActive("whileDrag", !1) } updateAxis(t, r, n) { let { drag: o } = this.getProps(); if (!n || !uh(t, o, this.currentDirection)) return; let i = this.getAxisMotionValue(t), s = this.originPoint[t] + n[t]; this.constraints && this.constraints[t] && (s = iN(s, this.constraints[t], this.elastic[t])), i.set(s) } resolveConstraints() { var t; let { dragConstraints: r, dragElastic: n } = this.getProps(), o = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (t = this.visualElement.projection) === null || t === void 0 ? void 0 : t.layout, i = this.constraints; r && jo(r) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : r && o ? this.constraints = sN(o.layoutBox, r) : this.constraints = !1, this.elastic = uN(n), i !== this.constraints && o && this.constraints && !this.hasMutatedConstraints && hr(s => { this.constraints !== !1 && this.getAxisMotionValue(s) && (this.constraints[s] = cN(o.layoutBox[s], this.constraints[s])) }) } resolveRefConstraints() { let { dragConstraints: t, onMeasureDragConstraints: r } = this.getProps(); if (!t || !jo(t)) return !1; let n = t.current; Mr(n !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop."); let { projection: o } = this.visualElement; if (!o || !o.layout) return !1; let i = YA(n, o.root, this.visualElement.getTransformPagePoint()), s = aN(o.layout.layoutBox, i); if (r) { let a = r(PA(s)); this.hasMutatedConstraints = !!a, a && (s = ah(a)) } return s } startAnimation(t) { let { drag: r, dragMomentum: n, dragElastic: o, dragTransition: i, dragSnapToOrigin: s, onDragTransitionEnd: a } = this.getProps(), l = this.constraints || {}, c = hr(u => { if (!uh(u, r, this.currentDirection)) return; let d = l && l[u] || {}; s && (d = { min: 0, max: 0 }); let f = o ? 200 : 1e6, p = o ? 40 : 1e7, y = { type: "inertia", velocity: n ? t[u] : 0, bounceStiffness: f, bounceDamping: p, timeConstant: 750, restDelta: 1, restSpeed: 10, ...i, ...d }; return this.startAxisValueAnimation(u, y) }); return Promise.all(c).then(a) } startAxisValueAnimation(t, r) { let n = this.getAxisMotionValue(t); return ld(this.visualElement, t), n.start(cc(t, n, 0, r, this.visualElement, !1)) } stopAnimation() { hr(t => this.getAxisMotionValue(t).stop()) } pauseAnimation() { hr(t => { var r; return (r = this.getAxisMotionValue(t).animation) === null || r === void 0 ? void 0 : r.pause() }) } getAnimationState(t) { var r; return (r = this.getAxisMotionValue(t).animation) === null || r === void 0 ? void 0 : r.state } getAxisMotionValue(t) { let r = `_drag${t.toUpperCase()}`, n = this.visualElement.getProps(), o = n[r]; return o || this.visualElement.getValue(t, (n.initial ? n.initial[t] : void 0) || 0) } snapToCursor(t) { hr(r => { let { drag: n } = this.getProps(); if (!uh(r, n, this.currentDirection)) return; let { projection: o } = this.visualElement, i = this.getAxisMotionValue(r); if (o && o.layout) { let { min: s, max: a } = o.layout.layoutBox[r]; i.set(t[r] - ce(s, a, .5)) } }) } scalePositionWithinConstraints() { if (!this.visualElement.current) return; let { drag: t, dragConstraints: r } = this.getProps(), { projection: n } = this.visualElement; if (!jo(r) || !n || !this.constraints) return; this.stopAnimation(); let o = { x: 0, y: 0 }; hr(s => { let a = this.getAxisMotionValue(s); if (a && this.constraints !== !1) { let l = a.get(); o[s] = lN({ min: l, max: l }, this.constraints[s]) } }); let { transformTemplate: i } = this.visualElement.getProps(); this.visualElement.current.style.transform = i ? i({}, "") : "none", n.root && n.root.updateScroll(), n.updateLayout(), this.resolveConstraints(), hr(s => { if (!uh(s, t, null)) return; let a = this.getAxisMotionValue(s), { min: l, max: c } = this.constraints[s]; a.set(ce(l, c, o[s])) }) } addListeners() { if (!this.visualElement.current) return; Tz.set(this.visualElement, this); let t = this.visualElement.current, r = Xo(t, "pointerdown", l => { let { drag: c, dragListener: u = !0 } = this.getProps(); c && u && this.start(l) }), n = () => { let { dragConstraints: l } = this.getProps(); jo(l) && l.current && (this.constraints = this.resolveRefConstraints()) }, { projection: o } = this.visualElement, i = o.addEventListener("measure", n); o && !o.layout && (o.root && o.root.updateScroll(), o.updateLayout()), Z.read(n); let s = $o(window, "resize", () => this.scalePositionWithinConstraints()), a = o.addEventListener("didUpdate", ({ delta: l, hasLayoutChanged: c }) => { this.isDragging && c && (hr(u => { let d = this.getAxisMotionValue(u); d && (this.originPoint[u] += l[u].translate, d.set(d.get() + l[u].translate)) }), this.visualElement.render()) }); return () => { s(), r(), i(), a && a() } } getProps() { let t = this.visualElement.getProps(), { drag: r = !1, dragDirectionLock: n = !1, dragPropagation: o = !1, dragConstraints: i = !1, dragElastic: s = ch, dragMomentum: a = !0 } = t; return { ...t, drag: r, dragDirectionLock: n, dragPropagation: o, dragConstraints: i, dragElastic: s, dragMomentum: a } } }; function uh(e, t, r) { return (t === !0 || t === e) && (r === null || r === e) } function Ez(e, t = 10) { let r = null; return Math.abs(e.y) > t ? r = "y" : Math.abs(e.x) > t && (r = "x"), r } var fh = class extends Et { constructor(t) { super(t), this.removeGroupControls = He, this.removeListeners = He, this.controls = new dh(t) } mount() { let { dragControls: t } = this.node.getProps(); t && (this.removeGroupControls = t.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || He } unmount() { this.removeGroupControls(), this.removeListeners() } }; var dN = e => (t, r) => { e && Z.postRender(() => e(t, r)) }, ph = class extends Et { constructor() { super(...arguments), this.removePointerDownListener = He } onPointerDown(t) { this.session = new mc(t, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint() }) } createPanHandlers() { let { onPanSessionStart: t, onPanStart: r, onPan: n, onPanEnd: o } = this.node.getProps(); return { onSessionStart: dN(t), onStart: dN(r), onMove: n, onEnd: (i, s) => { delete this.session, o && Z.postRender(() => o(i, s)) } } } mount() { this.removePointerDownListener = Xo(this.node.current, "pointerdown", t => this.onPointerDown(t)) } update() { this.session && this.session.updateHandlers(this.createPanHandlers()) } unmount() { this.removePointerDownListener(), this.session && this.session.end() } }; var mN = I(W(), 1), yd = I(P(), 1); var hc = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }; function fN(e, t) { return t.max === t.min ? 0 : e / (t.max - t.min) * 100 } var gc = { correct: (e, t) => { if (!t.target) return e; if (typeof e == "string") if (j.test(e)) e = parseFloat(e); else return e; let r = fN(e, t.target.x), n = fN(e, t.target.y); return `${r}% ${n}%` } }; var pN = { correct: (e, { treeScale: t, projectionDelta: r }) => { let n = e, o = tr.parse(e); if (o.length > 5) return n; let i = tr.createTransformer(e), s = typeof o[0] != "number" ? 1 : 0, a = r.x.scale * t.x, l = r.y.scale * t.y; o[0 + s] /= a, o[1 + s] /= l; let c = ce(a, l, .5); return typeof o[2 + s] == "number" && (o[2 + s] /= c), typeof o[3 + s] == "number" && (o[3 + s] /= c), i(o) } }; var m0 = class extends yd.Component { componentDidMount() { let { visualElement: t, layoutGroup: r, switchLayoutGroup: n, layoutId: o } = this.props, { projection: i } = t; hk(Cz), i && (r.group && r.group.add(i), n && n.register && o && n.register(i), i.root.didUpdate(), i.addEventListener("animationComplete", () => { this.safeToRemove() }), i.setOptions({ ...i.options, onExitComplete: () => this.safeToRemove() })), hc.hasEverUpdated = !0 } getSnapshotBeforeUpdate(t) { let { layoutDependency: r, visualElement: n, drag: o, isPresent: i } = this.props, s = n.projection; return s && (s.isPresent = i, o || t.layoutDependency !== r || r === void 0 || t.isPresent !== i ? s.willUpdate() : this.safeToRemove(), t.isPresent !== i && (i ? s.promote() : s.relegate() || Z.postRender(() => { let a = s.getStack(); (!a || !a.members.length) && this.safeToRemove() }))), null } componentDidUpdate() { let { projection: t } = this.props.visualElement; t && (t.root.didUpdate(), Ml.postRender(() => { !t.currentAnimation && t.isLead() && this.safeToRemove() })) } componentWillUnmount() { let { visualElement: t, layoutGroup: r, switchLayoutGroup: n } = this.props, { projection: o } = t; o && (o.scheduleCheckAfterUnmount(), r && r.group && r.group.remove(o), n && n.deregister && n.deregister(o)) } safeToRemove() { let { safeToRemove: t } = this.props; t && t() } render() { return null } }; function mh(e) { let [t, r] = om(), n = (0, yd.useContext)(Ll); return (0, mN.jsx)(m0, { ...e, layoutGroup: n, switchLayoutGroup: (0, yd.useContext)(hm), isPresent: t, safeToRemove: r }) } var Cz = { borderRadius: { ...gc, applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"] }, borderTopLeftRadius: gc, borderTopRightRadius: gc, borderBottomLeftRadius: gc, borderBottomRightRadius: gc, boxShadow: pN }; function hh(e, t, r) { let n = Ce(e) ? e : ft(e); return n.start(cc("", n, t, r)), n.animation } function gh(e) { return e instanceof SVGElement && e.tagName !== "svg" } var hN = (e, t) => e.depth - t.depth; var yh = class { constructor() { this.children = [], this.isDirty = !1 } add(t) { Ql(this.children, t), this.isDirty = !0 } remove(t) { Ki(this.children, t), this.isDirty = !0 } forEach(t) { this.isDirty && this.children.sort(hN), this.isDirty = !1, this.children.forEach(t) } }; function gN(e, t) { let r = zt.now(), n = ({ timestamp: o }) => { let i = o - r; i >= t && (fr(n), e(i - t)) }; return Z.read(n, !0), () => fr(n) } var xN = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], bz = xN.length, yN = e => typeof e == "string" ? parseFloat(e) : e, vN = e => typeof e == "number" || j.test(e); function TN(e, t, r, n, o, i) { o ? (e.opacity = ce(0, r.opacity !== void 0 ? r.opacity : 1, wz(n)), e.opacityExit = ce(t.opacity !== void 0 ? t.opacity : 1, 0, Iz(n))) : i && (e.opacity = ce(t.opacity !== void 0 ? t.opacity : 1, r.opacity !== void 0 ? r.opacity : 1, n)); for (let s = 0; s < bz; s++) { let a = `border${xN[s]}Radius`, l = SN(t, a), c = SN(r, a); if (l === void 0 && c === void 0) continue; l || (l = 0), c || (c = 0), l === 0 || c === 0 || vN(l) === vN(c) ? (e[a] = Math.max(ce(yN(l), yN(c), n), 0), (er.test(c) || er.test(l)) && (e[a] += "%")) : e[a] = c } (t.rotate || r.rotate) && (e.rotate = ce(t.rotate || 0, r.rotate || 0, n)) } function SN(e, t) { return e[t] !== void 0 ? e[t] : e.borderRadius } var wz = EN(0, .5, Fm), Iz = EN(.5, .95, He); function EN(e, t, r) { return n => n < e ? 0 : n > t ? 1 : r(Vr(e, t, n)) } function CN(e, t) { e.min = t.min, e.max = t.max } function Fr(e, t) { CN(e.x, t.x), CN(e.y, t.y) } function h0(e, t) { e.translate = t.translate, e.scale = t.scale, e.originPoint = t.originPoint, e.origin = t.origin } function bN(e, t, r, n, o) { return e -= t, e = gd(e, 1 / r, n), o !== void 0 && (e = gd(e, 1 / o, n)), e } function Rz(e, t = 0, r = 1, n = .5, o, i = e, s = e) { if (er.test(t) && (t = parseFloat(t), t = ce(s.min, s.max, t / 100) - s.min), typeof t != "number") return; let a = ce(i.min, i.max, n); e === i && (a -= t), e.min = bN(e.min, t, r, a, o), e.max = bN(e.max, t, r, a, o) } function wN(e, t, [r, n, o], i, s) { Rz(e, t[r], t[n], t[o], t.scale, i, s) } var kz = ["x", "scaleX", "originX"], Az = ["y", "scaleY", "originY"]; function g0(e, t, r, n) { wN(e.x, t, kz, r ? r.x : void 0, n ? n.x : void 0), wN(e.y, t, Az, r ? r.y : void 0, n ? n.y : void 0) } function IN(e) { return e.translate === 0 && e.scale === 1 } function y0(e) { return IN(e.x) && IN(e.y) } function RN(e, t) { return e.min === t.min && e.max === t.max } function AN(e, t) { return RN(e.x, t.x) && RN(e.y, t.y) } function kN(e, t) { return Math.round(e.min) === Math.round(t.min) && Math.round(e.max) === Math.round(t.max) } function v0(e, t) { return kN(e.x, t.x) && kN(e.y, t.y) } function S0(e) { return pt(e.x) / pt(e.y) } function x0(e, t) { return e.translate === t.translate && e.scale === t.scale && e.originPoint === t.originPoint } var vh = class { constructor() { this.members = [] } add(t) { Ql(this.members, t), t.scheduleRender() } remove(t) { if (Ki(this.members, t), t === this.prevLead && (this.prevLead = void 0), t === this.lead) { let r = this.members[this.members.length - 1]; r && this.promote(r) } } relegate(t) { let r = this.members.findIndex(o => t === o); if (r === 0) return !1; let n; for (let o = r; o >= 0; o--) { let i = this.members[o]; if (i.isPresent !== !1) { n = i; break } } return n ? (this.promote(n), !0) : !1 } promote(t, r) { let n = this.lead; if (t !== n && (this.prevLead = n, this.lead = t, t.show(), n)) { n.instance && n.scheduleRender(), t.scheduleRender(), t.resumeFrom = n, r && (t.resumeFrom.preserveOpacity = !0), n.snapshot && (t.snapshot = n.snapshot, t.snapshot.latestValues = n.animationValues || n.latestValues), t.root && t.root.isUpdating && (t.isLayoutDirty = !0); let { crossfade: o } = t.options; o === !1 && n.hide() } } exitAnimationComplete() { this.members.forEach(t => { let { options: r, resumingFrom: n } = t; r.onExitComplete && r.onExitComplete(), n && n.options.onExitComplete && n.options.onExitComplete() }) } scheduleRender() { this.members.forEach(t => { t.instance && t.scheduleRender(!1) }) } removeLeadSnapshot() { this.lead && this.lead.snapshot && (this.lead.snapshot = void 0) } }; function NN(e, t, r) { let n = "", o = e.x.translate / t.x, i = e.y.translate / t.y, s = r?.z || 0; if ((o || i || s) && (n = `translate3d(${o}px, ${i}px, ${s}px) `), (t.x !== 1 || t.y !== 1) && (n += `scale(${1 / t.x}, ${1 / t.y}) `), r) { let { transformPerspective: c, rotate: u, rotateX: d, rotateY: f, skewX: p, skewY: y } = r; c && (n = `perspective(${c}px) ${n}`), u && (n += `rotate(${u}deg) `), d && (n += `rotateX(${d}deg) `), f && (n += `rotateY(${f}deg) `), p && (n += `skewX(${p}deg) `), y && (n += `skewY(${y}deg) `) } let a = e.x.scale * t.x, l = e.y.scale * t.y; return (a !== 1 || l !== 1) && (n += `scale(${a}, ${l})`), n || "none" } var ia = { nodes: 0, calculatedTargetDeltas: 0, calculatedProjections: 0 }, T0 = ["", "X", "Y", "Z"], Nz = { visibility: "hidden" }, ON = 1e3, Oz = 0; function E0(e, t, r, n) { let { latestValues: o } = t; o[e] && (r[e] = o[e], t.setStaticValue(e, 0), n && (n[e] = 0)) } function FN(e) { if (e.hasCheckedOptimisedAppear = !0, e.root === e) return; let { visualElement: t } = e.options; if (!t) return; let r = Nm(t); if (window.MotionHasOptimisedAnimation(r, "transform")) { let { layout: o, layoutId: i } = e.options; window.MotionCancelOptimisedAnimation(r, "transform", Z, !(o || i)) } let { parent: n } = e; n && !n.hasCheckedOptimisedAppear && FN(n) } function Sh({ attachResizeListener: e, defaultParent: t, measureScroll: r, checkIsScrollRoot: n, resetTransform: o }) { return class { constructor(s = {}, a = t?.()) { this.id = Oz++, this.animationId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => { this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots()) }, this.updateProjection = () => { this.projectionUpdateScheduled = !1, Br.value && (ia.nodes = ia.calculatedTargetDeltas = ia.calculatedProjections = 0), this.nodes.forEach(_z), this.nodes.forEach(Fz), this.nodes.forEach(zz), this.nodes.forEach(Dz), Br.addProjectionMetrics && Br.addProjectionMetrics(ia) }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = s, this.root = a ? a.root || a : this, this.path = a ? [...a.path, a] : [], this.parent = a, this.depth = a ? a.depth + 1 : 0; for (let l = 0; l < this.path.length; l++)this.path[l].shouldResetTransform = !0; this.root === this && (this.nodes = new yh) } addEventListener(s, a) { return this.eventHandlers.has(s) || this.eventHandlers.set(s, new Xi), this.eventHandlers.get(s).add(a) } notifyListeners(s, ...a) { let l = this.eventHandlers.get(s); l && l.notify(...a) } hasListeners(s) { return this.eventHandlers.has(s) } mount(s, a = this.root.hasTreeAnimated) { if (this.instance) return; this.isSVG = gh(s), this.instance = s; let { layoutId: l, layout: c, visualElement: u } = this.options; if (u && !u.current && u.mount(s), this.root.nodes.add(this), this.parent && this.parent.children.add(this), a && (c || l) && (this.isLayoutDirty = !0), e) { let d, f = () => this.root.updateBlockedByResize = !1; e(s, () => { this.root.updateBlockedByResize = !0, d && d(), d = gN(f, 250), hc.hasAnimatedSinceResize && (hc.hasAnimatedSinceResize = !1, this.nodes.forEach(LN)) }) } l && this.root.registerSharedNode(l, this), this.options.animate !== !1 && u && (l || c) && this.addEventListener("didUpdate", ({ delta: d, hasLayoutChanged: f, hasRelativeLayoutChanged: p, layout: y }) => { if (this.isTreeAnimationBlocked()) { this.target = void 0, this.relativeTarget = void 0; return } let g = this.options.transition || u.getDefaultTransition() || Gz, { onLayoutAnimationStart: S, onLayoutAnimationComplete: h } = u.getProps(), m = !this.targetLayout || !v0(this.targetLayout, y), v = !f && p; if (this.options.layoutRoot || this.resumeFrom || v || f && (m || !this.currentAnimation)) { this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(d, v); let x = { ...ql(g, "layout"), onPlay: S, onComplete: h }; (u.shouldReduceMotion || this.options.layoutRoot) && (x.delay = 0, x.type = !1), this.startAnimation(x) } else f || LN(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete(); this.targetLayout = y }) } unmount() { this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this); let s = this.getStack(); s && s.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, fr(this.updateProjection) } blockUpdate() { this.updateManuallyBlocked = !0 } unblockUpdate() { this.updateManuallyBlocked = !1 } isUpdateBlocked() { return this.updateManuallyBlocked || this.updateBlockedByResize } isTreeAnimationBlocked() { return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1 } startUpdate() { this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(Hz), this.animationId++) } getTransformTemplate() { let { visualElement: s } = this.options; return s && s.getProps().transformTemplate } willUpdate(s = !0) { if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) { this.options.onExitComplete && this.options.onExitComplete(); return } if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && FN(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return; this.isLayoutDirty = !0; for (let u = 0; u < this.path.length; u++) { let d = this.path[u]; d.shouldResetTransform = !0, d.updateScroll("snapshot"), d.options.layoutRoot && d.willUpdate(!1) } let { layoutId: a, layout: l } = this.options; if (a === void 0 && !l) return; let c = this.getTransformTemplate(); this.prevTransformTemplateValue = c ? c(this.latestValues, "") : void 0, this.updateSnapshot(), s && this.notifyListeners("willUpdate") } update() { if (this.updateScheduled = !1, this.isUpdateBlocked()) { this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(PN); return } this.isUpdating || this.nodes.forEach(Bz), this.isUpdating = !1, this.nodes.forEach(Vz), this.nodes.forEach(Pz), this.nodes.forEach(Lz), this.clearAllSnapshots(); let a = zt.now(); Qe.delta = At(0, 1e3 / 60, a - Qe.timestamp), Qe.timestamp = a, Qe.isProcessing = !0, rd.update.process(Qe), rd.preRender.process(Qe), rd.render.process(Qe), Qe.isProcessing = !1 } didUpdate() { this.updateScheduled || (this.updateScheduled = !0, Ml.read(this.scheduleUpdate)) } clearAllSnapshots() { this.nodes.forEach(Mz), this.sharedNodes.forEach(Wz) } scheduleUpdateProjection() { this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, Z.preRender(this.updateProjection, !1, !0)) } scheduleCheckAfterUnmount() { Z.postRender(() => { this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed() }) } updateSnapshot() { this.snapshot || !this.instance || (this.snapshot = this.measure(), this.snapshot && !pt(this.snapshot.measuredBox.x) && !pt(this.snapshot.measuredBox.y) && (this.snapshot = void 0)) } updateLayout() { if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return; if (this.resumeFrom && !this.resumeFrom.instance) for (let l = 0; l < this.path.length; l++)this.path[l].updateScroll(); let s = this.layout; this.layout = this.measure(!1), this.layoutCorrected = Ne(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox); let { visualElement: a } = this.options; a && a.notify("LayoutMeasure", this.layout.layoutBox, s ? s.layoutBox : void 0) } updateScroll(s = "measure") { let a = Boolean(this.options.layoutScroll && this.instance); if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === s && (a = !1), a) { let l = n(this.instance); this.scroll = { animationId: this.root.animationId, phase: s, isRoot: l, offset: r(this.instance), wasRoot: this.scroll ? this.scroll.isRoot : l } } } resetTransform() { if (!o) return; let s = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, a = this.projectionDelta && !y0(this.projectionDelta), l = this.getTransformTemplate(), c = l ? l(this.latestValues, "") : void 0, u = c !== this.prevTransformTemplateValue; s && (a || Yo(this.latestValues) || u) && (o(this.instance, c), this.shouldResetTransform = !1, this.scheduleRender()) } measure(s = !0) { let a = this.measurePageBox(), l = this.removeElementScroll(a); return s && (l = this.removeTransform(l)), $z(l), { animationId: this.root.animationId, measuredBox: a, layoutBox: l, latestValues: {}, source: this.id } } measurePageBox() { var s; let { visualElement: a } = this.options; if (!a) return Ne(); let l = a.measureViewportBox(); if (!(((s = this.scroll) === null || s === void 0 ? void 0 : s.wasRoot) || this.path.some(Kz))) { let { scroll: u } = this.root; u && (ts(l.x, u.offset.x), ts(l.y, u.offset.y)) } return l } removeElementScroll(s) { var a; let l = Ne(); if (Fr(l, s), !((a = this.scroll) === null || a === void 0) && a.wasRoot) return l; for (let c = 0; c < this.path.length; c++) { let u = this.path[c], { scroll: d, options: f } = u; u !== this.root && d && f.layoutScroll && (d.wasRoot && Fr(l, s), ts(l.x, d.offset.x), ts(l.y, d.offset.y)) } return l } applyTransform(s, a = !1) { let l = Ne(); Fr(l, s); for (let c = 0; c < this.path.length; c++) { let u = this.path[c]; !a && u.options.layoutScroll && u.scroll && u !== u.root && na(l, { x: -u.scroll.offset.x, y: -u.scroll.offset.y }), Yo(u.latestValues) && na(l, u.latestValues) } return Yo(this.latestValues) && na(l, this.latestValues), l } removeTransform(s) { let a = Ne(); Fr(a, s); for (let l = 0; l < this.path.length; l++) { let c = this.path[l]; if (!c.instance || !Yo(c.latestValues)) continue; lh(c.latestValues) && c.updateSnapshot(); let u = Ne(), d = c.measurePageBox(); Fr(u, d), g0(a, c.latestValues, c.snapshot ? c.snapshot.layoutBox : void 0, u) } return Yo(this.latestValues) && g0(a, this.latestValues), a } setTargetDelta(s) { this.targetDelta = s, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0 } setOptions(s) { this.options = { ...this.options, ...s, crossfade: s.crossfade !== void 0 ? s.crossfade : !0 } } clearMeasurements() { this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1 } forceRelativeParentToResolveTarget() { this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== Qe.timestamp && this.relativeParent.resolveTargetDelta(!0) } resolveTargetDelta(s = !1) { var a; let l = this.getLead(); this.isProjectionDirty || (this.isProjectionDirty = l.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = l.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = l.isSharedProjectionDirty); let c = Boolean(this.resumingFrom) || this !== l; if (!(s || c && this.isSharedProjectionDirty || this.isProjectionDirty || !((a = this.parent) === null || a === void 0) && a.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize)) return; let { layout: d, layoutId: f } = this.options; if (!(!this.layout || !(d || f))) { if (this.resolvedRelativeTargetAt = Qe.timestamp, !this.targetDelta && !this.relativeTarget) { let p = this.getClosestProjectingParent(); p && p.layout && this.animationProgress !== 1 ? (this.relativeParent = p, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Ne(), this.relativeTargetOrigin = Ne(), pc(this.relativeTargetOrigin, this.layout.layoutBox, p.layout.layoutBox), Fr(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } if (!(!this.relativeTarget && !this.targetDelta)) { if (this.target || (this.target = Ne(), this.targetWithTransforms = Ne()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), zA(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (Boolean(this.resumingFrom) ? this.target = this.applyTransform(this.layout.layoutBox) : Fr(this.target, this.layout.layoutBox), u0(this.target, this.targetDelta)) : Fr(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) { this.attemptToResolveRelativeTarget = !1; let p = this.getClosestProjectingParent(); p && Boolean(p.resumingFrom) === Boolean(this.resumingFrom) && !p.options.layoutScroll && p.target && this.animationProgress !== 1 ? (this.relativeParent = p, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Ne(), this.relativeTargetOrigin = Ne(), pc(this.relativeTargetOrigin, this.target, p.target), Fr(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } Br.value && ia.calculatedTargetDeltas++ } } } getClosestProjectingParent() { if (!(!this.parent || lh(this.parent.latestValues) || l0(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent() } isProjecting() { return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout) } calcProjection() { var s; let a = this.getLead(), l = Boolean(this.resumingFrom) || this !== a, c = !0; if ((this.isProjectionDirty || !((s = this.parent) === null || s === void 0) && s.isProjectionDirty) && (c = !1), l && (this.isSharedProjectionDirty || this.isTransformDirty) && (c = !1), this.resolvedRelativeTargetAt === Qe.timestamp && (c = !1), c) return; let { layout: u, layoutId: d } = this.options; if (this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(u || d)) return; Fr(this.layoutCorrected, this.layout.layoutBox); let f = this.treeScale.x, p = this.treeScale.y; XA(this.layoutCorrected, this.treeScale, this.path, l), a.layout && !a.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (a.target = a.layout.layoutBox, a.targetWithTransforms = Ne()); let { target: y } = a; if (!y) { this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender()); return } !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (h0(this.prevProjectionDelta.x, this.projectionDelta.x), h0(this.prevProjectionDelta.y, this.projectionDelta.y)), fc(this.projectionDelta, this.layoutCorrected, y, this.latestValues), (this.treeScale.x !== f || this.treeScale.y !== p || !x0(this.projectionDelta.x, this.prevProjectionDelta.x) || !x0(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", y)), Br.value && ia.calculatedProjections++ } hide() { this.isVisible = !1 } show() { this.isVisible = !0 } scheduleRender(s = !0) { var a; if ((a = this.options.visualElement) === null || a === void 0 || a.scheduleRender(), s) { let l = this.getStack(); l && l.scheduleRender() } this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0) } createProjectionDeltas() { this.prevProjectionDelta = ra(), this.projectionDelta = ra(), this.projectionDeltaWithTransform = ra() } setAnimationOrigin(s, a = !1) { let l = this.snapshot, c = l ? l.latestValues : {}, u = { ...this.latestValues }, d = ra(); (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a; let f = Ne(), p = l ? l.source : void 0, y = this.layout ? this.layout.source : void 0, g = p !== y, S = this.getStack(), h = !S || S.members.length <= 1, m = Boolean(g && !h && this.options.crossfade === !0 && !this.path.some(Uz)); this.animationProgress = 0; let v; this.mixTargetDelta = x => { let C = x / 1e3; _N(d.x, s.x, C), _N(d.y, s.y, C), this.setTargetDelta(d), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (pc(f, this.layout.layoutBox, this.relativeParent.layout.layoutBox), jz(this.relativeTarget, this.relativeTargetOrigin, f, C), v && AN(this.relativeTarget, v) && (this.isProjectionDirty = !1), v || (v = Ne()), Fr(v, this.relativeTarget)), g && (this.animationValues = u, TN(u, c, this.latestValues, C, m, h)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = C }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0) } startAnimation(s) { this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (fr(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = Z.update(() => { hc.hasAnimatedSinceResize = !0, so.layout++, this.currentAnimation = hh(0, ON, { ...s, onUpdate: a => { this.mixTargetDelta(a), s.onUpdate && s.onUpdate(a) }, onStop: () => { so.layout-- }, onComplete: () => { so.layout--, s.onComplete && s.onComplete(), this.completeAnimation() } }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0 }) } completeAnimation() { this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0); let s = this.getStack(); s && s.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete") } finishAnimation() { this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(ON), this.currentAnimation.stop()), this.completeAnimation() } applyTransformsToTarget() { let s = this.getLead(), { targetWithTransforms: a, target: l, layout: c, latestValues: u } = s; if (!(!a || !l || !c)) { if (this !== s && this.layout && c && zN(this.options.animationType, this.layout.layoutBox, c.layoutBox)) { l = this.target || Ne(); let d = pt(this.layout.layoutBox.x); l.x.min = s.target.x.min, l.x.max = l.x.min + d; let f = pt(this.layout.layoutBox.y); l.y.min = s.target.y.min, l.y.max = l.y.min + f } Fr(a, l), na(a, u), fc(this.projectionDeltaWithTransform, this.layoutCorrected, a, u) } } registerSharedNode(s, a) { this.sharedNodes.has(s) || this.sharedNodes.set(s, new vh), this.sharedNodes.get(s).add(a); let c = a.options.initialPromotionConfig; a.promote({ transition: c ? c.transition : void 0, preserveFollowOpacity: c && c.shouldPreserveFollowOpacity ? c.shouldPreserveFollowOpacity(a) : void 0 }) } isLead() { let s = this.getStack(); return s ? s.lead === this : !0 } getLead() { var s; let { layoutId: a } = this.options; return a ? ((s = this.getStack()) === null || s === void 0 ? void 0 : s.lead) || this : this } getPrevLead() { var s; let { layoutId: a } = this.options; return a ? (s = this.getStack()) === null || s === void 0 ? void 0 : s.prevLead : void 0 } getStack() { let { layoutId: s } = this.options; if (s) return this.root.sharedNodes.get(s) } promote({ needsReset: s, transition: a, preserveFollowOpacity: l } = {}) { let c = this.getStack(); c && c.promote(this, l), s && (this.projectionDelta = void 0, this.needsReset = !0), a && this.setOptions({ transition: a }) } relegate() { let s = this.getStack(); return s ? s.relegate(this) : !1 } resetSkewAndRotation() { let { visualElement: s } = this.options; if (!s) return; let a = !1, { latestValues: l } = s; if ((l.z || l.rotate || l.rotateX || l.rotateY || l.rotateZ || l.skewX || l.skewY) && (a = !0), !a) return; let c = {}; l.z && E0("z", s, c, this.animationValues); for (let u = 0; u < T0.length; u++)E0(`rotate${T0[u]}`, s, c, this.animationValues), E0(`skew${T0[u]}`, s, c, this.animationValues); s.render(); for (let u in c) s.setStaticValue(u, c[u]), this.animationValues && (this.animationValues[u] = c[u]); s.scheduleRender() } getProjectionStyles(s) { var a, l; if (!this.instance || this.isSVG) return; if (!this.isVisible) return Nz; let c = { visibility: "" }, u = this.getTransformTemplate(); if (this.needsReset) return this.needsReset = !1, c.opacity = "", c.pointerEvents = Xl(s?.pointerEvents) || "", c.transform = u ? u(this.latestValues, "") : "none", c; let d = this.getLead(); if (!this.projectionDelta || !this.layout || !d.target) { let g = {}; return this.options.layoutId && (g.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, g.pointerEvents = Xl(s?.pointerEvents) || ""), this.hasProjected && !Yo(this.latestValues) && (g.transform = u ? u({}, "") : "none", this.hasProjected = !1), g } let f = d.animationValues || d.latestValues; this.applyTransformsToTarget(), c.transform = NN(this.projectionDeltaWithTransform, this.treeScale, f), u && (c.transform = u(f, c.transform)); let { x: p, y } = this.projectionDelta; c.transformOrigin = `${p.origin * 100}% ${y.origin * 100}% 0`, d.animationValues ? c.opacity = d === this ? (l = (a = f.opacity) !== null && a !== void 0 ? a : this.latestValues.opacity) !== null && l !== void 0 ? l : 1 : this.preserveOpacity ? this.latestValues.opacity : f.opacityExit : c.opacity = d === this ? f.opacity !== void 0 ? f.opacity : "" : f.opacityExit !== void 0 ? f.opacityExit : 0; for (let g in qs) { if (f[g] === void 0) continue; let { correct: S, applyTo: h, isCSSVariable: m } = qs[g], v = c.transform === "none" ? f[g] : S(f[g], d); if (h) { let x = h.length; for (let C = 0; C < x; C++)c[h[C]] = v } else m ? this.options.visualElement.renderState.vars[g] = v : c[g] = v } return this.options.layoutId && (c.pointerEvents = d === this ? Xl(s?.pointerEvents) || "" : "none"), c } clearSnapshot() { this.resumeFrom = this.snapshot = void 0 } resetTree() { this.root.nodes.forEach(s => { var a; return (a = s.currentAnimation) === null || a === void 0 ? void 0 : a.stop() }), this.root.nodes.forEach(PN), this.root.sharedNodes.clear() } } } function Pz(e) { e.updateLayout() } function Lz(e) { var t; let r = ((t = e.resumeFrom) === null || t === void 0 ? void 0 : t.snapshot) || e.snapshot; if (e.isLead() && e.layout && r && e.hasListeners("didUpdate")) { let { layoutBox: n, measuredBox: o } = e.layout, { animationType: i } = e.options, s = r.source !== e.layout.source; i === "size" ? hr(d => { let f = s ? r.measuredBox[d] : r.layoutBox[d], p = pt(f); f.min = n[d].min, f.max = f.min + p }) : zN(i, r.layoutBox, n) && hr(d => { let f = s ? r.measuredBox[d] : r.layoutBox[d], p = pt(n[d]); f.max = f.min + p, e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0, e.relativeTarget[d].max = e.relativeTarget[d].min + p) }); let a = ra(); fc(a, n, r.layoutBox); let l = ra(); s ? fc(l, e.applyTransform(o, !0), r.measuredBox) : fc(l, n, r.layoutBox); let c = !y0(a), u = !1; if (!e.resumeFrom) { let d = e.getClosestProjectingParent(); if (d && !d.resumeFrom) { let { snapshot: f, layout: p } = d; if (f && p) { let y = Ne(); pc(y, r.layoutBox, f.layoutBox); let g = Ne(); pc(g, n, p.layoutBox), v0(y, g) || (u = !0), d.options.layoutRoot && (e.relativeTarget = g, e.relativeTargetOrigin = y, e.relativeParent = d) } } } e.notifyListeners("didUpdate", { layout: n, snapshot: r, delta: l, layoutDelta: a, hasLayoutChanged: c, hasRelativeLayoutChanged: u }) } else if (e.isLead()) { let { onExitComplete: n } = e.options; n && n() } e.options.transition = void 0 } function _z(e) { Br.value && ia.nodes++, e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty), e.isSharedProjectionDirty || (e.isSharedProjectionDirty = Boolean(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)), e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty)) } function Dz(e) { e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1 } function Mz(e) { e.clearSnapshot() } function PN(e) { e.clearMeasurements() } function Bz(e) { e.isLayoutDirty = !1 } function Vz(e) { let { visualElement: t } = e.options; t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"), e.resetTransform() } function LN(e) { e.finishAnimation(), e.targetDelta = e.relativeTarget = e.target = void 0, e.isProjectionDirty = !0 } function Fz(e) { e.resolveTargetDelta() } function zz(e) { e.calcProjection() } function Hz(e) { e.resetSkewAndRotation() } function Wz(e) { e.removeLeadSnapshot() } function _N(e, t, r) { e.translate = ce(t.translate, 0, r), e.scale = ce(t.scale, 1, r), e.origin = t.origin, e.originPoint = t.originPoint } function DN(e, t, r, n) { e.min = ce(t.min, r.min, n), e.max = ce(t.max, r.max, n) } function jz(e, t, r, n) { DN(e.x, t.x, r.x, n), DN(e.y, t.y, r.y, n) } function Uz(e) { return e.animationValues && e.animationValues.opacityExit !== void 0 } var Gz = { duration: .45, ease: [.4, 0, .1, 1] }, MN = e => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(e), BN = MN("applewebkit/") && !MN("chrome/") ? Math.round : He; function VN(e) { e.min = BN(e.min), e.max = BN(e.max) } function $z(e) { VN(e.x), VN(e.y) } function zN(e, t, r) { return e === "position" || e === "preserve-aspect" && !FA(S0(t), S0(r), .2) } function Kz(e) { var t; return e !== e.root && ((t = e.scroll) === null || t === void 0 ? void 0 : t.wasRoot) } var HN = Sh({ attachResizeListener: (e, t) => $o(e, "resize", t), measureScroll: () => ({ x: document.documentElement.scrollLeft || document.body.scrollLeft, y: document.documentElement.scrollTop || document.body.scrollTop }), checkIsScrollRoot: () => !0 }); var C0 = { current: void 0 }, xh = Sh({ measureScroll: e => ({ x: e.scrollLeft, y: e.scrollTop }), defaultParent: () => { if (!C0.current) { let e = new HN({}); e.mount(window), e.setOptions({ layoutScroll: !0 }), C0.current = e } return C0.current }, resetTransform: (e, t) => { e.style.transform = t !== void 0 ? t : "none" }, checkIsScrollRoot: e => Boolean(window.getComputedStyle(e).position === "fixed") }); var WN = { pan: { Feature: ph }, drag: { Feature: fh, ProjectionNode: xh, MeasureLayout: mh } }; function Th(e, t, r) { var n; if (e instanceof EventTarget) return [e]; if (typeof e == "string") { let o = document; t && (o = t.current); let i = (n = r?.[e]) !== null && n !== void 0 ? n : o.querySelectorAll(e); return i ? Array.from(i) : [] } return Array.from(e) } function Eh(e, t) { let r = Th(e), n = new AbortController, o = { passive: !0, ...t, signal: n.signal }; return [r, o, () => n.abort()] } function jN(e) { return !(e.pointerType === "touch" || sh()) } function UN(e, t, r = {}) { let [n, o, i] = Eh(e, r), s = a => { if (!jN(a)) return; let { target: l } = a, c = t(l, a); if (typeof c != "function" || !l) return; let u = d => { jN(d) && (c(d), l.removeEventListener("pointerleave", u)) }; l.addEventListener("pointerleave", u, o) }; return n.forEach(a => { a.addEventListener("pointerenter", s, o) }), i } function GN(e, t, r) { let { props: n } = e; e.animationState && n.whileHover && e.animationState.setActive("whileHover", r === "Start"); let o = "onHover" + r, i = n[o]; i && Z.postRender(() => i(t, Ko(t))) } var Ch = class extends Et { mount() { let { current: t } = this.node; t && (this.unmount = UN(t, (r, n) => (GN(this.node, n, "Start"), o => GN(this.node, o, "End")))) } unmount() { } }; var bh = class extends Et { constructor() { super(...arguments), this.isActive = !1 } onFocus() { let t = !1; try { t = this.node.current.matches(":focus-visible") } catch { t = !0 } !t || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0) } onBlur() { !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1) } mount() { this.unmount = ao($o(this.node.current, "focus", () => this.onFocus()), $o(this.node.current, "blur", () => this.onBlur())) } unmount() { } }; var b0 = (e, t) => t ? e === t ? !0 : b0(e, t.parentElement) : !1; var Xz = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]); function $N(e) { return Xz.has(e.tagName) || e.tabIndex !== -1 } var sa = new WeakSet; function KN(e) { return t => { t.key === "Enter" && e(t) } } function w0(e, t) { e.dispatchEvent(new PointerEvent("pointer" + t, { isPrimary: !0, bubbles: !0 })) } var XN = (e, t) => { let r = e.currentTarget; if (!r) return; let n = KN(() => { if (sa.has(r)) return; w0(r, "down"); let o = KN(() => { w0(r, "up") }), i = () => w0(r, "cancel"); r.addEventListener("keyup", o, t), r.addEventListener("blur", i, t) }); r.addEventListener("keydown", n, t), r.addEventListener("blur", () => r.removeEventListener("keydown", n), t) }; function YN(e) { return dc(e) && !sh() } function qN(e, t, r = {}) { let [n, o, i] = Eh(e, r), s = a => { let l = a.currentTarget; if (!l || !YN(a) || sa.has(l)) return; sa.add(l), oa(a, "set"); let c = t(l, a), u = (p, y) => { l.removeEventListener("pointerup", d), l.removeEventListener("pointercancel", f), oa(p, "release"), !(!YN(p) || !sa.has(l)) && (sa.delete(l), typeof c == "function" && c(p, { success: y })) }, d = p => { (p.isTrusted ? Yz(p, l instanceof Element ? l.getBoundingClientRect() : { left: 0, top: 0, right: window.innerWidth, bottom: window.innerHeight }) : !1) ? u(p, !1) : u(p, !(l instanceof Element) || b0(l, p.target)) }, f = p => { u(p, !1) }; l.addEventListener("pointerup", d, o), l.addEventListener("pointercancel", f, o), l.addEventListener("lostpointercapture", f, o) }; return n.forEach(a => { a = r.useGlobalTarget ? window : a; let l = !1; a instanceof HTMLElement && (l = !0, !$N(a) && a.getAttribute("tabindex") === null && (a.tabIndex = 0)), a.addEventListener("pointerdown", s, o), l && a.addEventListener("focus", c => XN(c, o), o) }), i } function Yz(e, t) { return e.clientX < t.left || e.clientX > t.right || e.clientY < t.top || e.clientY > t.bottom } function QN(e, t, r) { let { props: n } = e; if (e.current instanceof HTMLButtonElement && e.current.disabled) return; e.animationState && n.whileTap && e.animationState.setActive("whileTap", r === "Start"); let o = "onTap" + (r === "End" ? "" : r), i = n[o]; i && Z.postRender(() => i(t, Ko(t))) } var wh = class extends Et { mount() { let { current: t } = this.node; t && (this.unmount = qN(t, (r, n) => (QN(this.node, n, "Start"), (o, { success: i }) => QN(this.node, o, i ? "End" : "Cancel")), { useGlobalTarget: this.node.props.globalTapTarget })) } unmount() { } }; var R0 = new WeakMap, I0 = new WeakMap, qz = e => { let t = R0.get(e.target); t && t(e) }, Qz = e => { e.forEach(qz) }; function Zz({ root: e, ...t }) { let r = e || document; I0.has(r) || I0.set(r, {}); let n = I0.get(r), o = JSON.stringify(t); return n[o] || (n[o] = new IntersectionObserver(Qz, { root: e, ...t })), n[o] } function ZN(e, t, r) { let n = Zz(t); return R0.set(e, r), n.observe(e), () => { R0.delete(e), n.unobserve(e) } } var Jz = { some: 0, all: 1 }, Ih = class extends Et { constructor() { super(...arguments), this.hasEnteredView = !1, this.isInView = !1 } startObserver() { this.unmount(); let { viewport: t = {} } = this.node.getProps(), { root: r, margin: n, amount: o = "some", once: i } = t, s = { root: r ? r.current : void 0, rootMargin: n, threshold: typeof o == "number" ? o : Jz[o] }, a = l => { let { isIntersecting: c } = l; if (this.isInView === c || (this.isInView = c, i && !c && this.hasEnteredView)) return; c && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", c); let { onViewportEnter: u, onViewportLeave: d } = this.node.getProps(), f = c ? u : d; f && f(l) }; return ZN(this.node.current, s, a) } mount() { this.startObserver() } update() { if (typeof IntersectionObserver > "u") return; let { props: t, prevProps: r } = this.node;["amount", "margin", "root"].some(e5(t, r)) && this.startObserver() } unmount() { } }; function e5({ viewport: e = {} }, { viewport: t = {} } = {}) { return r => e[r] !== t[r] } var JN = { inView: { Feature: Ih }, tap: { Feature: wh }, focus: { Feature: bh }, hover: { Feature: Ch } }; var eO = { layout: { ProjectionNode: xh, MeasureLayout: mh } }; var iO = I(P(), 1); var vd = { current: null }, Rh = { current: !1 }; function tO() { if (Rh.current = !0, !!_l) if (window.matchMedia) { let e = window.matchMedia("(prefers-reduced-motion)"), t = () => vd.current = e.matches; e.addListener(t), t() } else vd.current = !1 } var t5 = [...Yx, nt, tr], rO = e => t5.find(Gm(e)); var rs = new WeakMap; function nO(e, t, r) { for (let n in t) { let o = t[n], i = r[n]; if (Ce(o)) e.addValue(n, o); else if (Ce(i)) e.addValue(n, ft(o, { owner: e })); else if (i !== o) if (e.hasValue(n)) { let s = e.getValue(n); s.liveStyle === !0 ? s.jump(o) : s.hasAnimated || s.set(o) } else { let s = e.getStaticValue(n); e.addValue(n, ft(s !== void 0 ? s : o, { owner: e })) } } for (let n in r) t[n] === void 0 && e.removeValue(n); return t } var oO = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"], yc = class { scrapeMotionValuesFromProps(t, r, n) { return {} } constructor({ parent: t, props: r, presenceContext: n, reducedMotionConfig: o, blockInitialAnimation: i, visualState: s }, a = {}) { this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.KeyframeResolver = Ji, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => { this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection)) }, this.renderScheduledAt = 0, this.scheduleRender = () => { let p = zt.now(); this.renderScheduledAt < p && (this.renderScheduledAt = p, Z.render(this.render, !1, !0)) }; let { latestValues: l, renderState: c, onUpdate: u } = s; this.onUpdate = u, this.latestValues = l, this.baseTarget = { ...l }, this.initialValues = r.initial ? { ...l } : {}, this.renderState = c, this.parent = t, this.props = r, this.presenceContext = n, this.depth = t ? t.depth + 1 : 0, this.reducedMotionConfig = o, this.options = a, this.blockInitialAnimation = Boolean(i), this.isControllingVariants = Ys(r), this.isVariantNode = fm(r), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = Boolean(t && t.current); let { willChange: d, ...f } = this.scrapeMotionValuesFromProps(r, {}, this); for (let p in f) { let y = f[p]; l[p] !== void 0 && Ce(y) && y.set(l[p], !1) } } mount(t) { this.current = t, rs.set(t, this), this.projection && !this.projection.instance && this.projection.mount(t), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((r, n) => this.bindToMotionValue(n, r)), Rh.current || tO(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : vd.current, this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext) } unmount() { this.projection && this.projection.unmount(), fr(this.notifyUpdate), fr(this.render), this.valueSubscriptions.forEach(t => t()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this); for (let t in this.events) this.events[t].clear(); for (let t in this.features) { let r = this.features[t]; r && (r.unmount(), r.isMounted = !1) } this.current = null } bindToMotionValue(t, r) { this.valueSubscriptions.has(t) && this.valueSubscriptions.get(t)(); let n = mr.has(t); n && this.onBindTransform && this.onBindTransform(); let o = r.on("change", a => { this.latestValues[t] = a, this.props.onUpdate && Z.preRender(this.notifyUpdate), n && this.projection && (this.projection.isTransformDirty = !0) }), i = r.on("renderRequest", this.scheduleRender), s; window.MotionCheckAppearSync && (s = window.MotionCheckAppearSync(this, t, r)), this.valueSubscriptions.set(t, () => { o(), i(), s && s(), r.owner && r.stop() }) } sortNodePosition(t) { return !this.current || !this.sortInstanceNodePosition || this.type !== t.type ? 0 : this.sortInstanceNodePosition(this.current, t.current) } updateFeatures() { let t = "animation"; for (t in Ho) { let r = Ho[t]; if (!r) continue; let { isEnabled: n, Feature: o } = r; if (!this.features[t] && o && n(this.props) && (this.features[t] = new o(this)), this.features[t]) { let i = this.features[t]; i.isMounted ? i.update() : (i.mount(), i.isMounted = !0) } } } triggerBuild() { this.build(this.renderState, this.latestValues, this.props) } measureViewportBox() { return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Ne() } getStaticValue(t) { return this.latestValues[t] } setStaticValue(t, r) { this.latestValues[t] = r } update(t, r) { (t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = t, this.prevPresenceContext = this.presenceContext, this.presenceContext = r; for (let n = 0; n < oO.length; n++) { let o = oO[n]; this.propEventSubscriptions[o] && (this.propEventSubscriptions[o](), delete this.propEventSubscriptions[o]); let i = "on" + o, s = t[i]; s && (this.propEventSubscriptions[o] = this.on(o, s)) } this.prevMotionValues = nO(this, this.scrapeMotionValuesFromProps(t, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue(), this.onUpdate && this.onUpdate(this) } getProps() { return this.props } getVariant(t) { return this.props.variants ? this.props.variants[t] : void 0 } getDefaultTransition() { return this.props.transition } getTransformPagePoint() { return this.props.transformPagePoint } getClosestVariantNode() { return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0 } addVariantChild(t) { let r = this.getClosestVariantNode(); if (r) return r.variantChildren && r.variantChildren.add(t), () => r.variantChildren.delete(t) } addValue(t, r) { let n = this.values.get(t); r !== n && (n && this.removeValue(t), this.bindToMotionValue(t, r), this.values.set(t, r), this.latestValues[t] = r.get()) } removeValue(t) { this.values.delete(t); let r = this.valueSubscriptions.get(t); r && (r(), this.valueSubscriptions.delete(t)), delete this.latestValues[t], this.removeValueFromRenderState(t, this.renderState) } hasValue(t) { return this.values.has(t) } getValue(t, r) { if (this.props.values && this.props.values[t]) return this.props.values[t]; let n = this.values.get(t); return n === void 0 && r !== void 0 && (n = ft(r === null ? void 0 : r, { owner: this }), this.addValue(t, n)), n } readValue(t, r) { var n; let o = this.latestValues[t] !== void 0 || !this.current ? this.latestValues[t] : (n = this.getBaseTargetFromProps(this.props, t)) !== null && n !== void 0 ? n : this.readValueFromInstance(this.current, t, this.options); return o != null && (typeof o == "string" && (Um(o) || Hm(o)) ? o = parseFloat(o) : !rO(o) && tr.test(r) && (o = jm(t, r)), this.setBaseTarget(t, Ce(o) ? o.get() : o)), Ce(o) ? o.get() : o } setBaseTarget(t, r) { this.baseTarget[t] = r } getBaseTarget(t) { var r; let { initial: n } = this.props, o; if (typeof n == "string" || typeof n == "object") { let s = Kl(this.props, n, (r = this.presenceContext) === null || r === void 0 ? void 0 : r.custom); s && (o = s[t]) } if (n && o !== void 0) return o; let i = this.getBaseTargetFromProps(this.props, t); return i !== void 0 && !Ce(i) ? i : this.initialValues[t] !== void 0 && o === void 0 ? void 0 : this.baseTarget[t] } on(t, r) { return this.events[t] || (this.events[t] = new Xi), this.events[t].add(r) } notify(t, ...r) { this.events[t] && this.events[t].notify(...r) } }; var vc = class extends yc { constructor() { super(...arguments), this.KeyframeResolver = oc } sortInstanceNodePosition(t, r) { return t.compareDocumentPosition(r) & 2 ? 1 : -1 } getBaseTargetFromProps(t, r) { return t.style ? t.style[r] : void 0 } removeValueFromRenderState(t, { vars: r, style: n }) { delete r[t], delete n[t] } handleChildMotionValue() { this.childSubscription && (this.childSubscription(), delete this.childSubscription); let { children: t } = this.props; Ce(t) && (this.childSubscription = t.on("change", r => { this.current && (this.current.textContent = `${r}`) })) } }; function r5(e) { return window.getComputedStyle(e) } var Sc = class extends vc { constructor() { super(...arguments), this.type = "html", this.renderInstance = Em } readValueFromInstance(t, r) { if (mr.has(r)) { let n = nc(r); return n && n.default || 0 } else { let n = r5(t), o = (Vl(r) ? n.getPropertyValue(r) : n[r]) || 0; return typeof o == "string" ? o.trim() : o } } measureInstanceViewportBox(t, { transformPagePoint: r }) { return d0(t, r) } build(t, r, n) { Hl(t, r, n.transformTemplate) } scrapeMotionValuesFromProps(t, r, n) { return Yl(t, r, n) } }; var xc = class extends vc { constructor() { super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = Ne, this.updateDimensions = () => { this.current && !this.renderState.dimensions && Tm(this.current, this.renderState) } } getBaseTargetFromProps(t, r) { return t[r] } readValueFromInstance(t, r) { if (mr.has(r)) { let n = nc(r); return n && n.default || 0 } return r = Cm.has(r) ? r : Dl(r), t.getAttribute(r) } scrapeMotionValuesFromProps(t, r, n) { return wm(t, r, n) } onBindTransform() { this.current && !this.renderState.dimensions && Z.postRender(this.updateDimensions) } build(t, r, n) { Ul(t, r, this.isSVGTag, n.transformTemplate) } renderInstance(t, r, n, o) { bm(t, r, n, o) } mount(t) { this.isSVGTag = Gl(t.tagName), super.mount(t) } }; var sO = (e, t) => jl(e) ? new xc(t) : new Sc(t, { allowProjection: e !== iO.Fragment }); var aO = Mk({ ...AA, ...JN, ...WN, ...eO }, sO); var tn = rk(aO); var Tc = I(P(), 1); function ns(e) { let t = Dr(() => ft(e)), { isStatic: r } = (0, Tc.useContext)(Vn); if (r) { let [, n] = (0, Tc.useState)(e); (0, Tc.useEffect)(() => t.on("change", n), []) } return t } var n5 = e => e && typeof e == "object" && e.mix, o5 = e => n5(e) ? e.mix : void 0; function os(...e) { let t = !Array.isArray(e[0]), r = t ? 0 : -1, n = e[0 + r], o = e[1 + r], i = e[2 + r], s = e[3 + r], a = Jm(o, i, { mixer: o5(i[0]), ...s }); return t ? a(n) : a } var lO = I(P(), 1); function cO(e) { return (0, lO.useEffect)(() => () => e(), []) } function uO(e, t = 100, r) { let n = r({ ...e, keyframes: [0, t] }), o = Math.min(sc(n), 2e4); return { type: "keyframes", ease: i => n.next(o * i).value / t, duration: Ht(o) } } var dO = (e, t, r) => { let n = t - e; return ((r - e) % n + n) % n + e }; function kh(e, t) { return Zm(e) ? e[dO(0, e.length, t)] : e } function Sd(e) { return typeof e == "object" && !Array.isArray(e) } function Ah(e, t, r, n) { return typeof e == "string" && Sd(t) ? Th(e, r, n) : e instanceof NodeList ? Array.from(e) : Array.isArray(e) ? e : [e] } function fO(e, t, r) { return e * (t + 1) } function k0(e, t, r, n) { var o; return typeof t == "number" ? t : t.startsWith("-") || t.startsWith("+") ? Math.max(0, e + parseFloat(t)) : t === "<" ? r : (o = n.get(t)) !== null && o !== void 0 ? o : e } function i5(e, t, r) { for (let n = 0; n < e.length; n++) { let o = e[n]; o.at > t && o.at < r && (Ki(e, o), n--) } } function pO(e, t, r, n, o, i) { i5(e, o, i); for (let s = 0; s < t.length; s++)e.push({ value: t[s], at: ce(o, i, n[s]), easing: kh(r, s) }) } function mO(e, t) { for (let r = 0; r < e.length; r++)e[r] = e[r] / (t + 1) } function hO(e, t) { return e.at === t.at ? e.value === null ? 1 : t.value === null ? -1 : 0 : e.at - t.at } var s5 = "easeInOut", a5 = 20; function vO(e, { defaultTransition: t = {}, ...r } = {}, n, o) { let i = t.duration || .3, s = new Map, a = new Map, l = {}, c = new Map, u = 0, d = 0, f = 0; for (let p = 0; p < e.length; p++) { let y = e[p]; if (typeof y == "string") { c.set(y, d); continue } else if (!Array.isArray(y)) { c.set(y.name, k0(d, y.at, u, c)); continue } let [g, S, h = {}] = y; h.at !== void 0 && (d = k0(d, h.at, u, c)); let m = 0, v = (x, C, T, E = 0, w = 0) => { let k = l5(x), { delay: R = 0, times: A = th(k), type: N = "keyframes", repeat: O, repeatType: D, repeatDelay: b = 0, ...H } = C, { ease: B = t.ease || "easeOut", duration: z } = C, Q = typeof R == "function" ? R(E, w) : R, se = k.length, he = Yi(N) ? N : o?.[N]; if (se <= 2 && he) { let $ = 100; if (se === 2 && d5(k)) { let ie = k[1] - k[0]; $ = Math.abs(ie) } let oe = { ...H }; z !== void 0 && (oe.duration = Tt(z)); let ve = uO(oe, $, he); B = ve.ease, z = ve.duration } z ?? (z = i); let xe = d + Q; A.length === 1 && A[0] === 0 && (A[1] = 1); let Oe = A.length - k.length; if (Oe > 0 && eh(A, Oe), k.length === 1 && k.unshift(null), O) { Mr(O < a5, "Repeat count too high, must be less than 20"), z = fO(z, O); let $ = [...k], oe = [...A]; B = Array.isArray(B) ? [...B] : [B]; let ve = [...B]; for (let ie = 0; ie < O; ie++) { k.push(...$); for (let Se = 0; Se < $.length; Se++)A.push(oe[Se] + (ie + 1)), B.push(Se === 0 ? "linear" : kh(ve, Se - 1)) } mO(A, O) } let Y = xe + z; pO(T, k, B, A, xe, Y), m = Math.max(Q + z, m), f = Math.max(Y, f) }; if (Ce(g)) { let x = gO(g, a); v(S, h, yO("default", x)) } else { let x = Ah(g, S, n, l), C = x.length; for (let T = 0; T < C; T++) { S = S, h = h; let E = x[T], w = gO(E, a); for (let k in S) v(S[k], c5(h, k), yO(k, w), T, C) } } u = d, d += m } return a.forEach((p, y) => { for (let g in p) { let S = p[g]; S.sort(hO); let h = [], m = [], v = []; for (let C = 0; C < S.length; C++) { let { at: T, value: E, easing: w } = S[C]; h.push(E), m.push(Vr(0, f, T)), v.push(w || "easeOut") } m[0] !== 0 && (m.unshift(0), h.unshift(h[0]), v.unshift(s5)), m[m.length - 1] !== 1 && (m.push(1), h.push(null)), s.has(y) || s.set(y, { keyframes: {}, transition: {} }); let x = s.get(y); x.keyframes[g] = h, x.transition[g] = { ...t, duration: f, ease: v, times: m, ...r } } }), s } function gO(e, t) { return !t.has(e) && t.set(e, {}), t.get(e) } function yO(e, t) { return t[e] || (t[e] = []), t[e] } function l5(e) { return Array.isArray(e) ? e : [e] } function c5(e, t) { return e && e[t] ? { ...e, ...e[t] } : { ...e } } var u5 = e => typeof e == "number", d5 = e => e.every(u5); function f5(e, t) { return e in t } var Nh = class extends yc { constructor() { super(...arguments), this.type = "object" } readValueFromInstance(t, r) { if (f5(r, t)) { let n = t[r]; if (typeof n == "string" || typeof n == "number") return n } } getBaseTargetFromProps() { } removeValueFromRenderState(t, r) { delete r.output[t] } measureInstanceViewportBox() { return Ne() } build(t, r) { Object.assign(t.output, r) } renderInstance(t, { output: r }) { Object.assign(t, r) } sortInstanceNodePosition() { return 0 } }; function SO(e) { let t = { presenceContext: null, props: {}, visualState: { renderState: { transform: {}, transformOrigin: {}, style: {}, vars: {}, attrs: {} }, latestValues: {} } }, r = gh(e) ? new xc(t) : new Sc(t); r.mount(e), rs.set(e, r) } function xO(e) { let t = { presenceContext: null, props: {}, visualState: { renderState: { output: {} }, latestValues: {} } }, r = new Nh(t); r.mount(e), rs.set(e, r) } function p5(e, t) { return Ce(e) || typeof e == "number" || typeof e == "string" && !Sd(t) } function Oh(e, t, r, n) { let o = []; if (p5(e, t)) o.push(hh(e, Sd(t) && t.default || t, r && (r.default || r))); else { let i = Ah(e, t, n), s = i.length; Mr(Boolean(s), "No valid elements provided."); for (let a = 0; a < s; a++) { let l = i[a], c = l instanceof Element ? SO : xO; rs.has(l) || c(l); let u = rs.get(l), d = { ...r }; "delay" in d && typeof d.delay == "function" && (d.delay = d.delay(a, s)), o.push(...uc(u, { ...t, transition: d }, {})) } } return o } function TO(e, t, r) { let n = []; return vO(e, t, r, { spring: lc }).forEach(({ keyframes: i, transition: s }, a) => { n.push(...Oh(a, i, s)) }), n } function m5(e) { return Array.isArray(e) && e.some(Array.isArray) } function Ph(e) { function t(r, n, o) { let i = []; m5(r) ? i = TO(r, n, e) : i = Oh(r, n, o, e); let s = new Jl(i); return e && e.animations.push(s), s } return t } var gr = Ph(); function A0() { let e = Dr(() => ({ current: null, animations: [] })), t = Dr(() => Ph(e)); return cO(() => { e.animations.forEach(r => r.stop()) }), [e, t] } var Tr = I(W()), Xt = I(P()); function yr(e) { return e.type === "FRAME" || e.type === "TEXT" ? !!e.behaviors?.marquee : !1 } var G; (function (e) { e.FIXED = "FIXED", e.FILL_PARENT = "FILL_PARENT", e.HUG_CONTENTS = "HUG_CONTENTS" })(G || (G = {})); function Wt(e) { return is(e) && e.layoutMode !== "NONE" } function EO(e) { return Wt(e) && "children" in e && !!e.children && e.children.length > 0 } function jt(e, t) { return t ? (me(t.children.includes(e.id), "node is parent of other node"), Wt(t) && e.layoutPositioning !== "ABSOLUTE") : !1 } function is(e) { return e.type === "FRAME" || e.type === "SLOT" || e.type === "CODE_INSTANCE" || e.type === "CODE_LAYER" || e.type === "REPEATER" || e.type === "CMS_RICH_TEXT" } function Lh(e) { let { minWidth: t, minHeight: r, maxWidth: n, maxHeight: o } = e, i = {}; return r && (i.minHeight = r), o && (i.maxHeight = o), t && (i.minWidth = t), n && (i.maxWidth = n), i } function ot(e, t, r, n) { let i = (() => { let s = Dh(e, ee.state?.renderOptions.rootNodeStyle); if (t && jt(e, t)) { let l = t.layoutMode; switch (l) { case "HORIZONTAL": case "GRID": if (e.layoutGrow) return "FILL_PARENT"; break; case "VERTICAL": if (e.layoutAlign === "STRETCH") return "FILL_PARENT"; break; case "NONE": throw new te("parent layout mode is NONE"); default: ye(l) } } else if (t === null && (s === "independent" || n?.renderedByCode)) return "FILL_PARENT"; let a = is(e) && CO(e); if (a && (e.layoutMode === "HORIZONTAL" || e.layoutMode === "GRID")) switch (e.primaryAxisSizingMode) { case "FIXED": return "FIXED"; case "AUTO": case void 0: return "HUG_CONTENTS"; default: ye(e.primaryAxisSizingMode) }if (a && e.layoutMode === "VERTICAL") switch (e.counterAxisSizingMode) { case "FIXED": return "FIXED"; case "AUTO": default: return "HUG_CONTENTS" }return e.type === "TEXT" && e.textAutoResize === "WIDTH_AND_HEIGHT" || e.type === "GROUP" ? "HUG_CONTENTS" : "FIXED" })(); if (yr(e) && !r) { let s = t && ot(t, null, !1, n) === "HUG_CONTENTS"; (i === "HUG_CONTENTS" || i === "FILL_PARENT" && s) && (i = "FIXED") } return i } function mt(e, t, r) { let n = Dh(e, ee.state?.renderOptions.rootNodeStyle); if (t && jt(e, t)) switch (t.layoutMode) { case "VERTICAL": if (e.layoutGrow) return "FILL_PARENT"; break; case "HORIZONTAL": case "GRID": if (e.layoutAlign === "STRETCH") return "FILL_PARENT"; break; case "NONE": throw new te("parent layout mode is NONE"); default: ye(t.layoutMode) } else if (t === null && (n === "independent" || r?.renderedByCode)) return "FILL_PARENT"; let o = is(e) && CO(e); if (o && e.layoutMode === "VERTICAL") switch (e.primaryAxisSizingMode) { case "FIXED": return "FIXED"; case "AUTO": case void 0: return "HUG_CONTENTS"; default: ye(e.primaryAxisSizingMode) }if (o && (e.layoutMode === "HORIZONTAL" || e.layoutMode === "GRID")) switch (e.counterAxisSizingMode) { case "FIXED": return "FIXED"; case "AUTO": default: return "HUG_CONTENTS" }return e.type === "TEXT" && (e.textAutoResize === "WIDTH_AND_HEIGHT" || e.textAutoResize === "HEIGHT") || e.type === "GROUP" ? "HUG_CONTENTS" : "FIXED" } function CO(e) { return Wt(e) ? e.type === "CODE_INSTANCE" || e.type === "CODE_LAYER" || e.type === "REPEATER" || e.type === "CMS_RICH_TEXT" ? !0 : e.type === "FRAME" || e.type === "SLOT" ? e.children.length > 0 : !1 : !1 } function _h(e, t) { return !t || !Wt(t) || !jt(e, t) ? !1 : e.layoutAlign === "STRETCH" && t.layoutMode === "HORIZONTAL" && t.counterAxisSizingMode === "AUTO" && t.counterAxisAlignItems !== "MIN" } function Dh(e, t) { return t !== "component" ? t : e.type === "FRAME" && e.isComponentDefinition ? "component" : "independent" } var as = "--transform-inner-width", ls = "--transform-inner-height"; function aa(e, t, r) { let n = _r(Zr(r?.group?.relativeTransform, e.relativeTransform)); return t !== null && wO(n) } function bO(e, t, r, n, o) { let i = _r(Zr(r?.group?.relativeTransform, e.relativeTransform)); if (t == null || !wO(i)) return {}; let s = i, a = ot(e, t), l = mt(e, t), c = {}; if (c.transform = n ? IO(s[0][0], s[1][0], s[0][1], s[1][1], o) : `matrix(${s[0][0]}, ${s[1][0]}, ${s[0][1]}, ${s[1][1]}, 0, 0)`, rn(e, t)) { (a === G.HUG_CONTENTS || l === G.HUG_CONTENTS) && console.warn("Transformed sized determined by both constraints and hug not yet supported."); let { width: u, height: d, transform: f } = Mh(e.absoluteBoundingBox.width, e.absoluteBoundingBox.height, i, e.size, e.absoluteBoundingBox, n, o); c.width = u, c.height = d, c.transform = f } else a === G.FILL_PARENT ? c.width = "100%" : c.width = "auto", l === G.FILL_PARENT ? c.height = "100%" : c.height = "auto"; return c } function Mh(e, t, r, n, o, i, s) { let a = ss(0, 0, r), l = ss(0, n.y || 1, r), c = ss(n.x || 1, 0, r), u = { x: l.x - a.x, y: l.y - a.y }, d = { x: c.x - a.x, y: c.y - a.y }, f = e / o.width, p = t / o.height, y = (T, E) => Math.sqrt(T * T + E * E), g = y(f * d.x, p * d.y), S = y(f * u.x, p * u.y), h = f * d.x / g, m = p * d.y / g, v = f * u.x / S, x = p * u.y / S, C = i ? IO(h, m, v, x, s) : `matrix(${h}, ${m}, ${v}, ${x}, 0, 0) `; return { width: L(g), height: L(S), transform: C } } function wO(e) { return !rt(e[0][0], 1, Lr) || !rt(e[1][0], 0, Lr) || !rt(e[0][1], 0, Lr) || !rt(e[1][1], 1, Lr) } function Ec(e) { return !rt(Math.abs(e[0][0]), 1, Lr) || !rt(Math.abs(e[1][0]), 0, Lr) || !rt(Math.abs(e[0][1]), 0, Lr) || !rt(Math.abs(e[1][1]), 1, Lr) } function Bh(e) { let t = Math.abs(e[0][0]), r = Math.abs(e[0][1]); if (!(rt(t, 1, Lr) && rt(r, 0, Lr))) return `calc(1px * ((var(${ls}) * ${r}) + (var(${as}) * ${t})))` } function Vh(e) { let t = Math.abs(e[1][0]), r = Math.abs(e[1][1]); if (!(rt(r, 1, Lr) && rt(t, 0, Lr))) return `calc(1px * ((var(${as}) * ${t}) + (var(${ls}) * ${r})))` } function rn(e, t) { return Fh(e, t) || zh(e, t) } function Fh(e, t) { let r = e.constraints; return jt(e, t) ? !1 : r?.vertical === Ln.TOP_BOTTOM || r?.vertical === Ln.SCALE } function zh(e, t) { let r = e.constraints; return jt(e, t) ? !1 : r?.horizontal === Pn.LEFT_RIGHT || r?.horizontal === Pn.SCALE } function IO(e, t, r, n, o) { let i = Ke(e), s = Ke(t), a = Ke(r), l = Ke(n), c = Math.atan2(s, i) * (180 / Math.PI), u = c * Math.PI / 180, d = Math.cos(u), f = Math.sin(u), p = i * l - s * a, y = Math.sqrt(i * i + s * s), g = p / y, S = d, h = -f, m = f, v = d, x = (i * S + s * m) / y, C = (i * h + s * v) / y, T = (a * S + l * m) / g, E = (a * h + l * v) / g, w = Math.atan2(T, E) * (180 / Math.PI), k = Math.atan2(C, x) * (180 / Math.PI), R = Number(c.toFixed(2)), A = Number(w.toFixed(2)), N = Number(k.toFixed(2)), O = Number(y.toFixed(2)), D = Number(g.toFixed(2)); if (o) { if (o.current !== R) { let b = N0(o.current, R); R = o.current + b } o.current = R } return `rotate(${R}deg) skewX(${A}deg) skewY(${N}deg) scaleX(${O}) scaleY(${D})` } function N0(e, t) { let r = (e % 360 + 360) % 360, n = (t % 360 + 360) % 360, o = n - r; return o > 180 ? o -= 360 : o < -180 && (o += 360), Math.abs(o) === 180 ? r === 0 && n === 180 ? -180 : r === 180 && n === 0 || e < t ? 180 : -180 : o } function Wh(e, t, r, n, o) { let i = { ...Lh(e) }, { width: s, height: a, top: l, left: c, bottom: u, right: d, transform: f, aspectRatio: p } = y5(e, t, r, n, o); return s !== void 0 && (i.width = s), a !== void 0 && (i.height = a), f !== void 0 && (i.transform = f), p !== void 0 && (i.aspectRatio = p), o?.group?.withinAutoLayout ? (i.gridColumn = 1, i.gridRow = 1, i.position = "relative", c !== void 0 && (i.marginLeft = c), d !== void 0 && (i.marginRight = d), l !== void 0 && (i.marginTop = l), u !== void 0 && (i.marginBottom = u)) : (i.position = RO(e, t), c !== void 0 && (i.left = c), d !== void 0 && (i.right = d), l !== void 0 && (i.top = l), u !== void 0 && (i.bottom = u)), RO(e, t) === "fixed" && (i.zIndex = 9999), i } function RO(e, t) { return e.scrollBehavior === "STICKY_SCROLLS" ? "sticky" : Boolean(t?.type === "FRAME" && t.isBreakpointFrame) && e.scrollBehavior === "FIXED" ? "fixed" : "absolute" } function jh(e, t = !1) { let { horizontal: r = Pn.LEFT, vertical: n = Ln.TOP } = (t ? void 0 : e.constraints) ?? {}; return { horizontal: r, vertical: n } } function g5(e, t) { let { horizontal: r, vertical: n } = jh(e, t); return { horizontal: { type: r, left: e.constraintValues?.left ?? { pixelOffset: 0, sizeFraction: 0 }, right: e.constraintValues?.right ?? { pixelOffset: 0, sizeFraction: 1 } }, vertical: { type: n, top: e.constraintValues?.top ?? { pixelOffset: 0, sizeFraction: 0 }, bottom: e.constraintValues?.bottom ?? { pixelOffset: 0, sizeFraction: 1 } } } } function y5(e, t, r, n, o) { let { horizontal: i, vertical: s } = g5(e, o?.group?.withinAutoLayout), a = _r(Zr(o?.group?.relativeTransform, e.relativeTransform)), l = Uh(a, e.size), c = rn(e, t), u = !c && Ec(a) ? Bh(a) : void 0, d = !c && Ec(a) ? Vh(a) : void 0, { transform: f, ...p } = S5({ nodeWidth: l.width, bboxWidth: u, constraintBox: i, resizing: ot(e, t), textAlign: e.type === "TEXT" ? e.textAlignHorizontal : void 0 }), { transform: y, ...g } = x5({ nodeHeight: l.height, bboxHeight: d, constraintBox: s, resizing: mt(e, t), textAlign: e.type === "TEXT" ? e.textAlignVertical : void 0 }), S; if (e.targetAspectRatio && v5(e, t)) { let h = Ec(a) ? `${l.width} / ${l.height}` : `${e.targetAspectRatio.x} / ${e.targetAspectRatio.y}`; Fh(e, t) && (S = h, p.width = void 0), zh(e, t) && (S = h, g.height = void 0) } return r && (p.width && (p.width = X(n && e.boundVariables?.size?.x?.resolvedCodeSyntax?.[n], e.boundVariables?.size?.x?.resolvedName, typeof p.width == "number" ? `${p.width}px` : p.width) ?? p.width), g.height && (g.height = X(n && e.boundVariables?.size?.y?.resolvedCodeSyntax?.[n], e.boundVariables?.size?.y?.resolvedName, typeof g.height == "number" ? `${g.height}px` : g.height) ?? g.height)), { ...p, ...g, aspectRatio: S, transform: f || y ? [f, y].filter(Boolean).join(" ") : void 0 } } function v5(e, t) { let r = Fh(e, t), n = zh(e, t); return !r && !n ? !0 : r !== n } function Hh(e, t = !1) { return ht(e.pixelOffset, e.sizeFraction, t) } function ht(e, t, r = !1) { let n = L(e, 2); if (t === 0 && !r) return n === 0 ? "0" : `${n}px`; if (t === 1 && r) return n === 0 ? "0" : `${-n}px`; if (r) { let i = L(100 - t * 100, 2); return n === 0 ? i === 0 ? "0" : `${i}%` : `calc(${i}% - ${n}px)` } let o = L(t * 100, 2); return n === 0 ? o === 0 ? "0" : `${o}%` : `calc(${o}% + ${n}px)` } function S5({ nodeWidth: e, bboxWidth: t, constraintBox: r, resizing: n, textAlign: o }) { let i, s, a, l, c = t ?? (n === G.FIXED ? L(e) : void 0); if (r.type === "SCALE" || r.type === "LEFT_RIGHT") s = Hh(r.left), a = Hh(r.right, !0); else if (r.type === "RIGHT") { i = c; let { pixelOffset: u, sizeFraction: d } = r.right; switch (o) { case "CENTER": { a = ht(u - e / 2, d, !0), l = "translateX(50%)"; break } case void 0: case "RIGHT": { a = ht(u, d, !0); break } case "LEFT": case "JUSTIFIED": { a = ht(u - e, d, !0), l = "translateX(100%)"; break } default: ye(o) } } else if (r.type === "CENTER") { i = c; let { pixelOffset: u, sizeFraction: d } = r.left, f = r.right.pixelOffset - u; switch (o) { case void 0: case "CENTER": { s = ht(u + f / 2, d), l = "translateX(-50%)"; break } case "LEFT": case "JUSTIFIED": { s = ht(u, d); break } case "RIGHT": { s = ht(u + f, d), l = "translateX(-100%)"; break } default: ye(o) } } else if (r.type === "LEFT") { i = c; let { pixelOffset: u, sizeFraction: d } = r.left; switch (o) { case "CENTER": { s = ht(u + e / 2, d), l = "translateX(-50%)"; break } case "LEFT": case "JUSTIFIED": case void 0: { s = ht(u, d); break } case "RIGHT": { s = ht(u + e, d), l = "translateX(-100%)"; break } default: ye(o) } } else ye(r); return { width: i, left: s, right: a, transform: l } } function x5({ nodeHeight: e, bboxHeight: t, constraintBox: r, resizing: n, textAlign: o }) { let i, s, a, l, c = t ?? (n === G.FIXED ? L(e) : void 0); if (r.type === "SCALE" || r.type === "TOP_BOTTOM") s = Hh(r.top), a = Hh(r.bottom, !0); else if (r.type === "BOTTOM") { i = c; let { pixelOffset: u, sizeFraction: d } = r.bottom; switch (o) { case "CENTER": { a = ht(u - e / 2, d, !0), l = "translateY(50%)"; break } case void 0: case "BOTTOM": { a = ht(u, d, !0); break } case "TOP": { a = ht(u - e, d, !0), l = "translateY(100%)"; break } default: ye(o) } } else if (r.type === "CENTER") { i = c; let { pixelOffset: u, sizeFraction: d } = r.top, f = r.bottom.pixelOffset - u; switch (o) { case void 0: case "CENTER": { s = ht(u + f / 2, d), l = "translateY(-50%)"; break } case "BOTTOM": { s = ht(u + f, d), l = "translateY(-100%)"; break } case "TOP": { s = ht(u, d); break } default: ye(o) } } else if (r.type === "TOP") { i = c; let { pixelOffset: u, sizeFraction: d } = r.top; switch (o) { case "CENTER": { s = ht(u + e / 2, d), l = "translateY(-50%)"; break } case "BOTTOM": { s = ht(u + e, d), l = "translateY(-100%)"; break } case "TOP": case void 0: { s = ht(u, d); break } default: ye(o) } } else ye(r); return { height: i, top: s, bottom: a, transform: l } } function ss(e, t, r) { return { x: r[0][0] * e + r[0][1] * t + r[0][2] * 1, y: r[1][0] * e + r[1][1] * t + r[1][2] * 1 } } function Uh(e, t) { let r = ss(0, 0, e), n = ss(t.x, 0, e), o = ss(0, t.y, e), i = ss(t.x, t.y, e), s = Math.min(r.x, n.x, o.x, i.x), a = Math.max(r.x, n.x, o.x, i.x), l = Math.min(r.y, n.y, o.y, i.y), c = Math.max(r.y, n.y, o.y, i.y), u = a - s, d = c - l, f = Ke(s), p = Ke(l), y = Ke(u), g = Ke(d); return { x: f, y: p, width: y, height: g } } var T5 = { NONE: void 0, HORIZONTAL: void 0, VERTICAL: "column" }, Gh = { MIN: "flex-start", CENTER: "center", MAX: "flex-end", SPACE_BETWEEN: "space-between", BASELINE: "baseline" }; function E5(e) { return e.type === "TEXT" && e.textAutoResize === "HEIGHT" } function kO(e, t, r) { let n = Lh(e); if (Wt(t), !t || !Wt(t)) return n; let o = ot(e, t), i = mt(e, t); if (aa(e, t, r)) { let f = _r(Zr(r?.group?.relativeTransform, e.relativeTransform)); o !== G.FILL_PARENT && (n.width = Bh(f)), i !== G.FILL_PARENT && (n.height = Vh(f)) } else o === G.FIXED && (e.targetAspectRatio && i !== G.FIXED ? n.aspectRatio = `${e.targetAspectRatio.x} / ${e.targetAspectRatio.y}` : n.width = L(e.size.x + Gp(e, t))), i === G.FIXED && (e.targetAspectRatio && o !== G.FIXED ? n.aspectRatio = `${e.targetAspectRatio.x} / ${e.targetAspectRatio.y}` : n.height = L(e.size.y + $p(e, t))); n.position = "relative", e.scrollBehavior === "STICKY_SCROLLS" && (n.position = "sticky", n.top = 0), n.flexShrink = 0; let s = t.layoutMode, a = s === "HORIZONTAL", l = s === "VERTICAL", c = s === "GRID", u = t && ot(t) === G.FIXED, d = t && mt(t) === G.FIXED; if (a && o === G.FILL_PARENT || l && i === G.FILL_PARENT ? (n.flex = `${e.layoutGrow} 0 0`, e.minWidth || (n.minWidth = 1), e.minHeight || (n.minHeight = 1)) : c ? (e.gridColumnAnchorIndex !== void 0 && e.gridRowAnchorIndex, n.gridColumn = `${e.gridColumnAnchorIndex + 1}${e.gridColumnSpan ? ` / span ${e.gridColumnSpan}` : ""}`, n.gridRow = `${e.gridRowAnchorIndex + 1}${e.gridRowSpan ? ` / span ${e.gridRowSpan}` : ""}`, (e.gridChildHorizontalAlign && o === G.FIXED || o === G.HUG_CONTENTS) && (n.justifySelf = Gh[e.gridChildHorizontalAlign || "MIN"]), (e.gridChildVerticalAlign && i === G.FIXED || i === G.HUG_CONTENTS) && (n.alignSelf = Gh[e.gridChildVerticalAlign || "MIN"])) : (a && u && o === G.FIXED || l && d && mt(e) === G.FIXED) && (n.flexShrink, n.flexShrink = 0), (a && i === G.FILL_PARENT || l && o === G.FILL_PARENT) && (l ? E5(e) && !r?.allChildrenAreFillWidth ? (n.width = "min-content", n.minWidth = "100%") : n.width = "100%" : t.counterAxisSizingMode !== "FIXED" && !_h(e, t) ? n.alignSelf = "stretch" : n.height = "100%"), is(t), is(t) && r?.negativeItemSpacing) { let f = t.layoutMode === "HORIZONTAL" ? "marginRight" : "marginBottom"; n[f] = `${r.negativeItemSpacing}px` } return n } var AO = (e, t, r) => { if (e.type === "RECTANGLE") return 0; if (e.layoutMode === "NONE" || e.itemSpacing >= 0 || !r) return L(e.itemSpacing); let n = -1 / 0; if (e.layoutMode === "HORIZONTAL") { let o = r.filter(i => ot(i, e) !== G.FILL_PARENT); if (o.length > 0) { let i = o.map(s => Uh(s.relativeTransform, s.size).width); n = -Math.min(...i) } else ot(e, t) !== G.FILL_PARENT && (n = -e.size.x) } else { let o = r.filter(i => mt(i, e) !== G.FILL_PARENT); if (o.length > 0) { let i = o.map(s => Uh(s.relativeTransform, s.size).height); n = -Math.min(...i) } else mt(e, t) !== G.FILL_PARENT && (n = -e.size.y) } return L(Math.max(n, e.itemSpacing)) }; function O0({ node: e, children: t, itemSpacing: r, shouldOutputVariables: n, codeSyntaxLanguage: o }) { let i = {}, { layoutMode: s, primaryAxisAlignItems: a, counterAxisAlignItems: l, layoutWrap: c, counterAxisSpacing: u = 0 } = e; if (b5(i, e, r, n, o), s === "GRID") i.display = ot(e) === G.HUG_CONTENTS ? "inline-grid" : "grid", e.gridColumnsSizing && (i.gridTemplateColumns = e.gridColumnsSizing), e.gridRowsSizing && (i.gridTemplateRows = e.gridRowsSizing), e.gridColumnGap && (i.columnGap = e.gridColumnGap), e.gridRowGap && (i.rowGap = e.gridRowGap); else { i.display = "flex"; let d = w5(e, t); if (i.flexDirection = T5[s], e.itemReverseZIndex && (i.isolation = "isolate"), a && a !== "MIN" && (i.justifyContent = Gh[a]), l && (i.alignItems = Gh[l]), i.alignContent = d, c === "WRAP" && (i.flexWrap = "wrap"), a !== "SPACE_BETWEEN" ? !c || c === "NO_WRAP" ? r > 0 && (i.gap = r) : (r === u || u === void 0) && d !== "space-between" ? i.gap = r : d === "space-between" ? i.columnGap = r : r < 0 ? i.rowGap = u : i.gap = u === r ? u : `${u}px ${r}px` : c === "WRAP" && d !== "space-between" && u && (i.rowGap = u), n) { let f = i.gap || 0, p = X(o && e.boundVariables?.itemSpacing?.resolvedCodeSyntax?.[o], e.boundVariables?.itemSpacing?.resolvedName, typeof f == "number" ? `${f}px` : f); p && (i.gap = p) } } return i } function C5(e, t) { return t ? t.every(r => I5(r, e) === G.FILL_PARENT) : !0 } function b5(e, t, r, n, o) { let i = Wt(t) && t.strokesIncludedInLayout && t.type !== "CODE_INSTANCE" && t.type !== "CODE_LAYER" ? tR(t) : { top: 0, right: 0, bottom: 0, left: 0 }; r < 0 && (t.layoutMode === "HORIZONTAL" ? i.right = i.right - r : i.bottom = i.bottom - r); let s = L((t.paddingTop || 0) + i.top), a = L((t.paddingBottom || 0) + i.bottom), l = L((t.paddingLeft || 0) + i.left), c = L((t.paddingRight || 0) + i.right); e.boxSizing = "border-box", n ? (e.paddingTop = X(o && t.boundVariables?.paddingTop?.resolvedCodeSyntax?.[o], t.boundVariables?.paddingTop?.resolvedName, `${s}px`) ?? s, e.paddingBottom = X(o && t.boundVariables?.paddingBottom?.resolvedCodeSyntax?.[o], t.boundVariables?.paddingBottom?.resolvedName, `${a}px`) ?? a, e.paddingLeft = X(o && t.boundVariables?.paddingLeft?.resolvedCodeSyntax?.[o], t.boundVariables?.paddingLeft?.resolvedName, `${l}px`) ?? l, e.paddingRight = X(o && t.boundVariables?.paddingRight?.resolvedCodeSyntax?.[o], t.boundVariables?.paddingRight?.resolvedName, `${c}px`) ?? c) : (e.paddingTop = s, e.paddingBottom = a, e.paddingLeft = l, e.paddingRight = c) } function w5(e, t) { if (e.counterAxisAlignContent === "SPACE_BETWEEN") return "space-between"; if (e.layoutWrap === "WRAP" && !C5(e, t)) { let r = e.counterAxisAlignItems || "MIN"; return P0(r) } return "stretch" } function P0(e) { switch (e) { case "MIN": return "flex-start"; case "CENTER": return "center"; case "MAX": return "flex-end"; case "BASELINE": return "baseline" } } function I5(e, t) { return t && Wt(t) && t.layoutMode === "VERTICAL" ? ot(e, t) : mt(e, t) } var nn = (e, t) => { let r = e.scrollBehavior === "STICKY_SCROLLS" || e.scrollBehavior === "FIXED"; return { [Ye.ScrollParallax]: r || (t?.isInStickyOrFixedTree ?? !1) } }; var Cc = I(W()), Cse = I(P()); function qo(e, t) { return `node-${e.replace(/:/g, "_").replace(/;/g, "-")}${t ? `_${t}` : ""}` } function $h() { let e = ue(), t = Hp(ml()), { disableElementIds: r } = Ee(); return r ? !0 : e === "preview" && t } function de(e, t) { let r = Ee(), n = $h(); if (!(r.disableElementIds && t || !n)) return qo(e.id, t) } var L0 = I(W()), Kh = I(P()); var Xh = Kh.default.createContext(!1); function NO(e) { let { isNodeListItem: t, children: r } = e; return (0, L0.jsx)(Xh.Provider, { value: t, children: r }) } function lo({ children: e }) { return (0, L0.jsx)(Xh.Provider, { value: !1, children: e }) } function co() { return Kh.default.useContext(Xh) ? "li" : "div" } function Yh() { return Kh.default.useContext(Xh) } function OO() { let e = co(); return tn[e] } var qh = { top: 0, left: void 0, right: void 0, bottom: void 0, pointerEvents: "auto" }; function xd({ children: e, stickyWrapperStyles: t, node: r }) { let n = M(t ?? {}), o = de(r, "sticky-wrapper"), i = co(); return t ? (0, Cc.jsx)(lo, { children: (0, Cc.jsx)(i, { id: o, className: n, children: e }) }) : (0, Cc.jsx)(Cc.Fragment, { children: e }) } function PO(e = [], t, r) { return { boxShadow: R5(e, t, r), filter: M0(e, t, r).filter, backdropFilter: B0(e, t, r).backdropFilter } } function R5(e, t, r) { return [...e].reverse().map(o => { if (o.type === "DROP_SHADOW") return _0([o], t, r).boxShadow; if (o.type === "INNER_SHADOW") return D0([o], t, r).boxShadow }).filter(o => !!o).join(", ") || void 0 } function _0(e, t, r) { return { boxShadow: [...e].reverse().map(o => { if (o.type !== "DROP_SHADOW") return; let i = `${L(o.offset.x)}px`, s = `${L(o.offset.y)}px`, a = `${L(o.radius)}px`, l = `${L(o.spread || 0)}px`, c = dt.fromRGBA(o.color, t, o.boundVariables?.color?.resolvedName, r && o.boundVariables?.color?.resolvedCodeSyntax?.[r]).value; return t && (i = X(r && o.boundVariables?.offsetX?.resolvedCodeSyntax?.[r], o.boundVariables?.offsetX?.resolvedName, i) ?? i, s = X(r && o.boundVariables?.offsetY?.resolvedCodeSyntax?.[r], o.boundVariables?.offsetY?.resolvedName, s) ?? s, a = X(r && o.boundVariables?.radius?.resolvedCodeSyntax?.[r], o.boundVariables?.radius?.resolvedName, a) ?? a, l = X(r && o.boundVariables?.spread?.resolvedCodeSyntax?.[r], o.boundVariables?.spread?.resolvedName, l) ?? l), `${i} ${s} ${a} ${l} ${c}` }).filter(o => !!o).join(", ") || void 0 } } function D0(e, t, r) { return { boxShadow: [...e].reverse().map(o => { if (o.type !== "INNER_SHADOW") return; let i = `${L(o.offset.x)}px`, s = `${L(o.offset.y)}px`, a = `${L(o.radius)}px`, l = `${L(o.spread || 0)}px`, c = dt.fromRGBA(o.color, t, o.boundVariables?.color?.resolvedName, r && o.boundVariables?.color?.resolvedCodeSyntax?.[r]).value; return t && (i = X(r && o.boundVariables?.offsetX?.resolvedCodeSyntax?.[r], o.boundVariables?.offsetX?.resolvedName, i) ?? i, s = X(r && o.boundVariables?.offsetY?.resolvedCodeSyntax?.[r], o.boundVariables?.offsetY?.resolvedName, s) ?? s, a = X(r && o.boundVariables?.radius?.resolvedCodeSyntax?.[r], o.boundVariables?.radius?.resolvedName, a) ?? a, l = X(r && o.boundVariables?.spread?.resolvedCodeSyntax?.[r], o.boundVariables?.spread?.resolvedName, l) ?? l), `inset ${i} ${s} ${a} ${l} ${c}` }).filter(o => !!o).join(", ") || void 0 } } function M0(e, t, r) { let n = e.find(i => i.type === "LAYER_BLUR"); if (!n) return { filter: void 0 }; let o = `${L(n.radius / 2)}px`; if (t) { let i = X(r && n.boundVariables?.radius?.resolvedCodeSyntax?.[r], n.boundVariables?.radius?.resolvedName, o); i && (o = i) } return { filter: `blur(${o})` } } function B0(e, t, r) { let n = e.find(i => i.type === "BACKGROUND_BLUR"); if (!n) return { backdropFilter: void 0 }; let o = `${L(n.radius / 2)}px`; if (t) { let i = X(r && n.boundVariables?.radius?.resolvedCodeSyntax?.[r], n.boundVariables?.radius?.resolvedName, o); i && (o = i) } return { backdropFilter: `blur(${o})` } } function LO(e = [], t, r) { return e.reduce((n, o) => { if (o.type === "INNER_SHADOW" || o.type === "BACKGROUND_BLUR") return n; if (o.type === "DROP_SHADOW") { let i = `${L(o.offset.x)}px`, s = `${L(o.offset.y)}px`, a = `${L(o.radius)}px`, l = dt.fromRGBA(o.color, t, o.boundVariables?.color?.resolvedName, r && o.boundVariables?.color?.resolvedCodeSyntax?.[r]).value; t && (i = X(r && o.boundVariables?.offsetX?.resolvedCodeSyntax?.[r], o.boundVariables?.offsetX?.resolvedName, i) ?? i, s = X(r && o.boundVariables?.offsetY?.resolvedCodeSyntax?.[r], o.boundVariables?.offsetY?.resolvedName, s) ?? s, a = X(r && o.boundVariables?.radius?.resolvedCodeSyntax?.[r], o.boundVariables?.radius?.resolvedName, a) ?? a), n.textShadow = `${n.textShadow?.length ? `${n.textShadow}, ` : ""}${i} ${s} ${a} ${l}` } else if (o.type === "LAYER_BLUR") { let i = `${L(o.radius / 2)}px`; t && (i = X(r && o.boundVariables?.radius?.resolvedCodeSyntax?.[r], o.boundVariables?.radius?.resolvedName, i) ?? i), n.filter = `blur(${i})` } return n }, {}) } function vr({ node: e, parent: t, context: r, children: n, zIndex: o, itemSpacing: i, codeSyntaxLanguage: s, options: a = { isFlattened: !1, canAnimate: !1, previousRotation: void 0 } }) { let l = Dh(e, ee.state?.renderOptions.rootNodeStyle), c = ee.state?.renderOptions.previewingCodeBehavior ?? !1, u; if (jt(e, t)) u = kO(e, t, r); else if (t === null) if (r?.renderedByCode || c) u = { ...Wh(e, t, a.shouldOutputVariables ?? !1, s, r), position: "relative", top: void 0, right: void 0, bottom: void 0, left: void 0 }; else if (l === "independent") u = A5(e); else if (l === "component") { let h = Wh(e, t, a.shouldOutputVariables ?? !1, s, r), { top: m, left: v, right: x, bottom: C, position: T, ...E } = h; u = E } else u = k5(e); else u = Wh(e, t, a.shouldOutputVariables ?? !1, s, r); u.mixBlendMode = r?.group?.mixBlendMode ?? Sl(e.blendMode); let d = bO(e, t, r, a?.canAnimate, a?.previousRotation), f; !a.isFlattened && EO(e) ? f = O0({ node: e, children: n, itemSpacing: i, shouldOutputVariables: a.shouldOutputVariables ?? !1, codeSyntaxLanguage: s }) : !a.isFlattened && (e.type === "CODE_INSTANCE" || e.type === "CODE_LAYER") && Wt(e) ? f = O0({ node: e, children: n, itemSpacing: e.itemSpacing, shouldOutputVariables: a.shouldOutputVariables ?? !1, codeSyntaxLanguage: s }) : e.type === "GROUP" ? (f = N5(e, t, r), f.display === "inline-grid" && (u.lineHeight = "0")) : f = { display: "block" }; let y = u.position === "sticky" && !jt(e, t), g; if (y) { let h = t?.size.y && typeof u.top == "number" ? t.size.y - u.top : u.top !== void 0 ? `calc(100% - ${u.top})` : t?.size.y; g = { position: "absolute", top: u.top, left: u.left, bottom: 0, right: u.right, height: h, pointerEvents: "none" }, u = { ...u, ...qh } } let S = { inner: f, outer: u, stickyWrapper: g, transform: d }; return O5(S, e, o), S } function k5(e) { let t = mt(e, null) === G.HUG_CONTENTS ? void 0 : e.size.y, n = Wt(e) ? void 0 : e.size.x; return { position: "relative", minWidth: "var(--content-min-width)", width: "100%", height: mt(e, null) === G.HUG_CONTENTS ? void 0 : "var(--content-min-height)", "--content-width": "calc(var(--content-width-scaled, 100%) - (var(--content-margin-x-scaled, 0px) * 2))", "--content-margin": "0 var(--content-margin-x-scaled, 0)", "--content-min-width": n ? `calc(max(var(--viewport-width-scaled, 100%), ${n}px) - (var(--content-margin-x-scaled, 0px) * 2))` : "calc(var(--viewport-width-scaled, 100%) - (var(--content-margin-x-scaled, 0px) * 2))", "--content-min-height": t ? `max(var(--viewport-height-scaled, var(--100dvh)), ${t}px)` : "var(--viewport-height-scaled, var(--100dvh))" } } function A5(e) { return { position: "relative", width: "100%", height: "100%" } } function N5(e, t, r) { let n = {}; return jt(e, t) || r?.group?.withinAutoLayout ? (n.display = "inline-grid", n.gridTemplateColumns = "max-content", n.gridTemplateRows = "max-content", n.justifyItems = "start", n.alignItems = "start") : n.display = "contents", n } function O5(e, t, r) { e.inner.whiteSpace = t.type === "TEXT" && t.textAutoResize === "WIDTH_AND_HEIGHT" ? "nowrap" : void 0, r !== void 0 && (e.outer.zIndex = r) } function bc(e, t, r) { if (r?.renderedByCode) return {}; if (t && "clipsContent" in e && e.clipsContent === !1) return {}; let n = yr(e), o = e.overflowDirection ?? "NONE", i = !n && (o === "HORIZONTAL_SCROLLING" || o === "HORIZONTAL_AND_VERTICAL_SCROLLING"), s = !n && (o === "VERTICAL_SCROLLING" || o === "HORIZONTAL_AND_VERTICAL_SCROLLING"), a = i ? "auto" : "clip"; return t ? { overflowX: a, overflowY: s ? "auto" : "clip" } : ee.state?.withBaseStyles ? { overflowX: i ? "auto" : "hidden" } : {} } function _O(e, t, r, n, o, i) { let { cursor: s, opacity: a, ...l } = r, c, u, d; e.effects && (c = _0(e.effects, o, i), u = M0(e.effects, o, i), d = B0(e.effects, o, i)); let f = Fi(e), p = { ...c }, y = f || n ? { ...p, ...Xp(e, t, n, o, i), pointerEvents: "none" } : void 0, g = lx(e), S = { borderTopLeftRadius: g.topLeft, borderTopRightRadius: g.topRight, borderBottomRightRadius: g.bottomRight, borderBottomLeftRadius: g.bottomLeft }, { borderTopLeftRadius: h, borderTopRightRadius: m, borderBottomRightRadius: v, borderBottomLeftRadius: x } = o ? cx(S, e, i) : S, C = { borderTopLeftRadius: h, borderTopRightRadius: m, borderBottomRightRadius: v, borderBottomLeftRadius: x, cursor: s, opacity: a, ...u, ...!f && p }, T = { ...l }, E = { ...d, borderTopLeftRadius: h, borderTopRightRadius: m, borderBottomRightRadius: v, borderBottomLeftRadius: x }; return { containerStyles: C, clipperStyles: T, borderStyles: y, sharedBackgroundStyles: E } } function V0(e, t, r, n) { let o = n ? Gp(t, r) : 0, i = Math.min(t.maxWidth || Number.POSITIVE_INFINITY, t.size.x); e.width = L(i + o) } function DO({ node: e, parent: t, context: r }) { let n = {}; if (yr(e) && ot(e, t, !1, r) === G.FIXED && !rn(e, t)) { let o = jt(e, t); V0(n, e, t, o) } return n } function Sr({ node: e, parent: t, children: r, context: n }) { let o = { position: "relative" }, i = ee.state?.renderOptions; if (!t && !i?.rootNodeStyle && !i?.previewingCodeBehavior) return o.width = "var(--content-width)", o.height = "100%", o.margin = "var(--content-margin)", o.minWidth = "var(--content-min-width)", o.minHeight = "var(--content-min-height)", o; let s = ot(e, t, !1, n); s !== G.HUG_CONTENTS && (o.width = "100%"); let a = mt(e, t, n); a !== G.HUG_CONTENTS && (o.height = "100%"); let l = jt(e, t), c = () => { let u = l ? $p(e, t) : 0, d = Math.min(e.maxHeight || Number.POSITIVE_INFINITY, e.size.y); o.height = L(d + u) }; return yr(e) ? e.type === "FRAME" && r?.some(d => ot(d, e, !1, n) === G.FILL_PARENT) && V0(o, e, t, l) : rn(e, t) || (s === G.FIXED && (e.targetAspectRatio && a !== G.FIXED ? o.aspectRatio = `${e.targetAspectRatio.x} / ${e.targetAspectRatio.y}` : V0(o, e, t, l)), a === G.FIXED && (e.targetAspectRatio && s !== G.FIXED ? o.aspectRatio = `${e.targetAspectRatio.x} / ${e.targetAspectRatio.y}` : c())), o } function uo(e, t) { let r = {}; return e.isDecorativeImage && (r.role = "presentation", r["aria-hidden"] = !0), e.accessibleLabel && !t && (r["aria-label"] = e.accessibleLabel), e.ariaAttributes?.ariaHidden !== void 0 && (r["aria-hidden"] = e.ariaAttributes.ariaHidden), e.ariaAttributes?.ariaRole !== void 0 && (r.role = e.ariaAttributes.ariaRole.join(" ")), e.ariaAttributes?.ariaCurrent !== void 0 && (r["aria-current"] = e.ariaAttributes.ariaCurrent), r } var rr = I(P()); var MO = (e, t, r) => Math.min(Math.max(r, e), t); var la = e => typeof e == "number"; var BO = e => Array.isArray(e) && !la(e[0]); var VO = (e, t, r) => { let n = t - e; return ((r - e) % n + n) % n + e }; function FO(e, t) { return BO(e) ? e[VO(0, e.length, t)] : e } var Qh = (e, t, r) => -r * e + r * t + e; var Td = e => e; var ca = (e, t, r) => t - e === 0 ? 1 : (r - e) / (t - e); function Zh(e, t) { let r = e[e.length - 1]; for (let n = 1; n <= t; n++) { let o = ca(0, t, n); e.push(Qh(r, 1, o)) } } function Ed(e) { let t = [0]; return Zh(t, e - 1), t } function F0(e, t = Ed(e.length), r = Td) { let n = e.length, o = n - t.length; return o > 0 && Zh(t, o), i => { let s = 0; for (; s < n - 2 && !(i < t[s + 1]); s++); let a = MO(0, 1, ca(t[s], t[s + 1], i)); return a = FO(r, s)(a), Qh(e[s], e[s + 1], a) } } var ua = e => typeof e == "function"; var Cd = e => typeof e == "string"; function z0(e, t) { return t ? e * (1e3 / t) : 0 } function Jh(e, t) { var r; return typeof e == "string" ? t ? ((r = t[e]) !== null && r !== void 0 || (t[e] = document.querySelectorAll(e)), e = t[e]) : e = document.querySelectorAll(e) : e instanceof Element && (e = [e]), Array.from(e || []) } function zO(e, t) { var r = {}; for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]); if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, n = Object.getOwnPropertySymbols(e); o < n.length; o++)t.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[o]) && (r[n[o]] = e[n[o]]); return r } var P5 = { any: 0, all: 1 }; function H0(e, t, { root: r, margin: n, amount: o = "any" } = {}) { if (typeof IntersectionObserver > "u") return () => { }; let i = Jh(e), s = new WeakMap, a = c => { c.forEach(u => { let d = s.get(u.target); if (u.isIntersecting !== Boolean(d)) if (u.isIntersecting) { let f = t(u); ua(f) ? s.set(u.target, f) : l.unobserve(u.target) } else d && (d(u), s.delete(u.target)) }) }, l = new IntersectionObserver(a, { root: r, rootMargin: n, threshold: typeof o == "number" ? o : P5[o] }); return i.forEach(c => l.observe(c)), () => l.disconnect() } var eg = new WeakMap, cs; function L5(e, t) { if (t) { let { inlineSize: r, blockSize: n } = t[0]; return { width: r, height: n } } else return e instanceof SVGElement && "getBBox" in e ? e.getBBox() : { width: e.offsetWidth, height: e.offsetHeight } } function _5({ target: e, contentRect: t, borderBoxSize: r }) { var n; (n = eg.get(e)) === null || n === void 0 || n.forEach(o => { o({ target: e, contentSize: t, get size() { return L5(e, r) } }) }) } function D5(e) { e.forEach(_5) } function M5() { typeof ResizeObserver > "u" || (cs = new ResizeObserver(D5)) } function HO(e, t) { cs || M5(); let r = Jh(e); return r.forEach(n => { let o = eg.get(n); o || (o = new Set, eg.set(n, o)), o.add(t), cs?.observe(n) }), () => { r.forEach(n => { let o = eg.get(n); o?.delete(t), o?.size || cs?.unobserve(n) }) } } var tg = new Set, bd; function B5() { bd = () => { let e = { width: window.innerWidth, height: window.innerHeight }, t = { target: window, size: e, contentSize: e }; tg.forEach(r => r(t)) }, window.addEventListener("resize", bd) } function WO(e) { return tg.add(e), bd || B5(), () => { tg.delete(e), !tg.size && bd && (bd = void 0) } } function jO(e, t) { return ua(e) ? WO(e) : HO(e, t) } var V5 = 50, UO = () => ({ current: 0, offset: [], progress: 0, scrollLength: 0, targetOffset: 0, targetLength: 0, containerLength: 0, velocity: 0 }), $O = () => ({ time: 0, x: UO(), y: UO() }), F5 = { x: { length: "Width", position: "Left" }, y: { length: "Height", position: "Top" } }; function GO(e, t, r, n) { let o = r[t], { length: i, position: s } = F5[t], a = o.current, l = r.time; o.current = e["scroll" + s], o.scrollLength = e["scroll" + i] - e["client" + i], o.offset.length = 0, o.offset[0] = 0, o.offset[1] = o.scrollLength, o.progress = ca(0, o.scrollLength, o.current); let c = n - l; o.velocity = c > V5 ? 0 : z0(o.current - a, c) } function KO(e, t, r) { GO(e, "x", t, r), GO(e, "y", t, r), t.time = r } function XO(e, t) { let r = { x: 0, y: 0 }, n = e; for (; n && n !== t;)if (n instanceof HTMLElement) r.x += n.offsetLeft, r.y += n.offsetTop, n = n.offsetParent; else if (n instanceof SVGGraphicsElement && "getBBox" in n) { let { top: o, left: i } = n.getBBox(); for (r.x += i, r.y += o; n && n.tagName !== "svg";)n = n.parentNode } return r } var YO = { Enter: [[0, 1], [1, 1]], Exit: [[0, 0], [1, 0]], Any: [[1, 0], [0, 1]], All: [[0, 0], [1, 1]] }; var rg = { start: 0, center: .5, end: 1 }; function W0(e, t, r = 0) { let n = 0; if (rg[e] !== void 0 && (e = rg[e]), Cd(e)) { let o = parseFloat(e); e.endsWith("px") ? n = o : e.endsWith("%") ? e = o / 100 : e.endsWith("vw") ? n = o / 100 * document.documentElement.clientWidth : e.endsWith("vh") ? n = o / 100 * document.documentElement.clientHeight : e = o } return la(e) && (n = t * e), r + n } var z5 = [0, 0]; function qO(e, t, r, n) { let o = Array.isArray(e) ? e : z5, i = 0, s = 0; return la(e) ? o = [e, e] : Cd(e) && (e = e.trim(), e.includes(" ") ? o = e.split(" ") : o = [e, rg[e] ? e : "0"]), i = W0(o[0], r, n), s = W0(o[1], t), i - s } var H5 = { x: 0, y: 0 }; function QO(e, t, r) { let { offset: n = YO.All } = r, { target: o = e, axis: i = "y" } = r, s = i === "y" ? "height" : "width", a = o !== e ? XO(o, e) : H5, l = o === e ? { width: e.scrollWidth, height: e.scrollHeight } : { width: o.clientWidth, height: o.clientHeight }, c = { width: e.clientWidth, height: e.clientHeight }; t[i].offset.length = 0; let u = !t[i].interpolate, d = n.length; for (let f = 0; f < d; f++) { let p = qO(n[f], c[s], l[s], a[i]); !u && p !== t[i].interpolatorOffsets[f] && (u = !0), t[i].offset[f] = p } u && (t[i].interpolate = F0(Ed(d), t[i].offset), t[i].interpolatorOffsets = [...t[i].offset]), t[i].progress = t[i].interpolate(t[i].current) } function W5(e, t = e, r) { if (r.x.targetOffset = 0, r.y.targetOffset = 0, t !== e) { let n = t; for (; n && n != e;)r.x.targetOffset += n.offsetLeft, r.y.targetOffset += n.offsetTop, n = n.offsetParent } r.x.targetLength = t === e ? t.scrollWidth : t.clientWidth, r.y.targetLength = t === e ? t.scrollHeight : t.clientHeight, r.x.containerLength = e.clientWidth, r.y.containerLength = e.clientHeight } function ZO(e, t, r, n = {}) { let o = n.axis || "y"; return { measure: () => W5(e, n.target, r), update: i => { KO(e, r, i), (n.offset || n.target) && QO(e, r, n) }, notify: ua(t) ? () => t(r) : j5(t, r[o]) } } function j5(e, t) { return e.pause(), e.forEachNative((r, { easing: n }) => { var o, i; if (r.updateDuration) n || (r.easing = Td), r.updateDuration(1); else { let s = { duration: 1e3 }; n || (s.easing = "linear"), (i = (o = r.effect) === null || o === void 0 ? void 0 : o.updateTiming) === null || i === void 0 || i.call(o, s) } }), () => { e.currentTime = t.progress } } var wd = new WeakMap, JO = new WeakMap, j0 = new WeakMap, eP = e => e === document.documentElement ? window : e; function Id(e, t = {}) { var { container: r = document.documentElement } = t, n = zO(t, ["container"]); let o = j0.get(r); o || (o = new Set, j0.set(r, o)); let i = $O(), s = ZO(r, e, i, n); if (o.add(s), !wd.has(r)) { let c = () => { let d = performance.now(); for (let f of o) f.measure(); for (let f of o) f.update(d); for (let f of o) f.notify() }; wd.set(r, c); let u = eP(r); window.addEventListener("resize", c, { passive: !0 }), r !== document.documentElement && JO.set(r, jO(r, c)), u.addEventListener("scroll", c, { passive: !0 }) } let a = wd.get(r), l = requestAnimationFrame(a); return () => { var c; typeof e != "function" && e.stop(), cancelAnimationFrame(l); let u = j0.get(r); if (!u || (u.delete(s), u.size)) return; let d = wd.get(r); wd.delete(r), d && (eP(r).removeEventListener("scroll", d), (c = JO.get(r)) === null || c === void 0 || c(), window.removeEventListener("resize", d)) } } var tP = { m00: 1, m01: 0, m02: 0, m10: 0, m11: 1, m12: 0 }; function wc(e, t, r = 1) { return { m00: r, m01: 0, m02: e, m10: 0, m11: r, m12: t } } var U5 = { FADE_IN: { opacity: 0, transform: tP }, SCALE_IN: { opacity: 0, transform: wc(0, 0, .5) }, SCALE_IN_BOTTOM: { opacity: 0, transform: wc(0, 50, .5) }, SLIDE_IN_TOP: { opacity: 0, transform: wc(0, -150) }, SLIDE_IN_BOTTOM: { opacity: 0, transform: wc(0, 150) }, SLIDE_IN_LEFT: { opacity: 0, transform: wc(-150, 0) }, SLIDE_IN_RIGHT: { opacity: 0, transform: wc(150, 0) }, NONE: { opacity: 1, transform: tP } }, G5 = .75, fo = { IN_CUBIC: [.55, .055, .675, .19], OUT_CUBIC: [.215, .61, .355, 1], INOUT_CUBIC: [.645, .045, .355, 1], LINEAR: [0, 0, 1, 1], IN_BACK_CUBIC: [.3, -.05, .7, -.5], OUT_BACK_CUBIC: [.45, 1.45, .8, 1], INOUT_BACK_CUBIC: [.7, -.4, .4, 1.4], GENTLE_SPRING: [1, 100, 15, 0], SPRING_PRESET_ONE: [1, 300, 20, 0], SPRING_PRESET_TWO: [1, 600, 15, 0], SPRING_PRESET_THREE: [1, 80, 20, 0] }, rP = { easingType: "OUT_CUBIC", easingFunction: fo.OUT_CUBIC, transitionDuration: .3 }, $5 = { ...rP, transitionDuration: .6 }, K5 = 50; function Ut(e, t) { if (!e) return {}; let r = t.transform ? qe.fromTransform(t.transform) : qe.identity(); r.multiply(X5(e.transform)); let n = r.toScale(), o = r.offset(), i = r.toDegrees(); return { opacity: e.opacity ?? t.opacity ?? 1, scaleX: n?.x ?? 1, scaleY: n?.y ?? 1, translateX: o?.x ?? 0, translateY: o?.y ?? 0, rotate: i ?? 0 } } function U0(e, t, r, n) { let o = { key: void 0, hasBehaviors: !1, variants: { visible: {} }, initial: "visible", appearBehaviorOtherLayer: void 0, scrollTransformOtherLayer: void 0, hasAppearLoadBehavior: !1, hasAppearScrollIntoViewBehavior: !1, hasAppearScrollDirectionBehavior: !1, hasHoverBehavior: !1, hasPressBehavior: !1, hasFocusBehavior: !1, hasScrollSpeedBehavior: !1, hasCursorBehavior: !1, transitionToVisible: void 0, transitionToExit: void 0, transitionToAndFromHover: void 0, transitionToAndFromPress: void 0, transitionToAndFromFocus: void 0, transitionBasedOnScrollDirection: void 0, scrollParallaxSpeed: 1, replayAppearBehavior: !0, hasScrollTransformOnScrollBehavior: !1, hasScrollTransformIntoViewBehavior: !1, scrollTransformTransition: void 0, replayScrollTransformBehavior: !0, cursorBehaviorInfo: void 0, hasEnterAnimation: !0, hasExitAnimation: !0 }; if (e.length === 0) return o; o.hasBehaviors = !0, o.variants = { visible: Ut({}, t) }; for (let i of e) { let s = i.behaviorType, a = !1; switch (s) { case Ye.Appear: { let l = i; if (!l || r?.[Ye.Appear]) break; let c = l.trigger; switch (c) { case "PAGE_LOAD": o.hasAppearLoadBehavior = !0, o.initial = "initial", o.variants.initial = Ut(i.enterState, t), o.transitionToVisible = on(i.enterTransition); break; case "THIS_LAYER_IN_VIEW": o.hasAppearScrollIntoViewBehavior = !0, o.initial = "initial", o.variants.initial = Ut(i.enterState, t), o.variants.exit = Ut(i.exitState ?? i.enterState, t), o.transitionToVisible = on(i.enterTransition), o.transitionToExit = on(i.exitTransition), o.replayAppearBehavior = !i.playsOnce; break; case "OTHER_LAYER_IN_VIEW": o.hasAppearScrollIntoViewBehavior = !0, o.initial = "initial", o.variants.initial = Ut(i.enterState, t), o.variants.exit = Ut(i.exitState ?? i.enterState, t), o.appearBehaviorOtherLayer = Je(i.otherLayer), o.transitionToVisible = on(i.enterTransition), o.transitionToExit = on(i.exitTransition), o.replayAppearBehavior = !i.playsOnce; break; case "SCROLL_DIRECTION": o.hasAppearScrollDirectionBehavior = !0, o.variants.scrollDirection = Ut(i.enterState, t), o.transitionBasedOnScrollDirection = on(i.enterTransition), o.replayAppearBehavior = !i.playsOnce; break; default: ye(c) }break } case Ye.ScrollTransform: { let l = i; if (!l || r?.[Ye.ScrollTransform]) break; a = l.fromState.opacity !== l.toState.opacity; let c = l.trigger; switch (c) { case "PAGE_HEIGHT": o.hasScrollTransformOnScrollBehavior = !0, o.initial = "initial", o.variants.initial = Ut(i.fromState, t), o.variants.exit = Ut(i.toState, t), o.scrollTransformTransition = on(i.transition); break; case "THIS_LAYER_IN_VIEW": o.hasScrollTransformIntoViewBehavior = !0, o.initial = "initial", o.variants.initial = Ut(i.fromState, t), o.variants.exit = Ut(i.toState, t), o.scrollTransformTransition = on(i.transition), o.replayScrollTransformBehavior = !i.playsOnce; break; case "OTHER_LAYER_IN_VIEW": o.hasScrollTransformIntoViewBehavior = !0, o.initial = "initial", o.variants.initial = Ut(i.fromState, t), o.variants.exit = Ut(i.toState, t), o.scrollTransformTransition = on(i.transition), o.scrollTransformOtherLayer = Je(i.otherLayer), o.replayScrollTransformBehavior = !i.playsOnce; break; default: ye(c) }break } case Ye.Hover: o.hasHoverBehavior = !r?.[Ye.Hover], o.variants.hover = Ut(i.state, t), o.transitionToAndFromHover = on(i.transition); break; case Ye.Press: o.hasPressBehavior = !r?.[Ye.Press], o.variants.press = Ut(i.state, t), o.transitionToAndFromPress = on(i.transition); break; case Ye.Focus: o.hasFocusBehavior = !r?.[Ye.Focus], o.variants.focus = Ut(i.state, t), o.transitionToAndFromFocus = on(i.transition); break; case Ye.ScrollParallax: o.hasScrollSpeedBehavior = !r?.[Ye.ScrollParallax], o.scrollParallaxSpeed = i.speed; break; case Ye.Cursor: o.hasCursorBehavior = !r?.[Ye.Cursor], o.cursorBehaviorInfo = { cursorGuid: Je(i.cursorGuid), cursorImage: n, cursorHotspot: { x: i.hotspotX, y: i.hotspotY } }; break; case Ye.Marquee: break; case Ye.Code: break; default: ye(s) }a && o.scrollTransformTransition && (o.scrollTransformTransition.repeatDelay = 1) } return o.key = JSON.stringify(o), o } function X5(e) { return Array.isArray(e) ? qe.fromNumbers(e[0][0], e[0][1], e[0][2], e[1][0], e[1][1], e[1][2]) : typeof e == "object" ? qe.fromNumbers(e.m00, e.m01, e.m02, e.m10, e.m11, e.m12) : qe.identity() } function on(e) { if (e) switch (e.easingType) { case "IN_CUBIC": return { ease: "easeIn", duration: e.transitionDuration, delay: e.delay }; case "OUT_CUBIC": return { ease: "easeOut", duration: e.transitionDuration, delay: e.delay }; case "INOUT_CUBIC": return { ease: "easeInOut", duration: e.transitionDuration, delay: e.delay }; case "LINEAR": return { ease: "linear", duration: e.transitionDuration, delay: e.delay }; case "IN_BACK_CUBIC": return { ease: fo.IN_BACK_CUBIC, duration: e.transitionDuration, delay: e.delay }; case "OUT_BACK_CUBIC": return { ease: fo.OUT_BACK_CUBIC, duration: e.transitionDuration, delay: e.delay }; case "INOUT_BACK_CUBIC": return { ease: fo.INOUT_BACK_CUBIC, duration: e.transitionDuration, delay: e.delay }; case "CUSTOM_CUBIC": return { ease: e.easingFunction, duration: e.transitionDuration, delay: e.delay }; case "GENTLE_SPRING": case "SPRING_PRESET_ONE": case "SPRING_PRESET_TWO": case "SPRING_PRESET_THREE": return { type: "spring", stiffness: fo[e.easingType][1], damping: fo[e.easingType][2], mass: fo[e.easingType][0], delay: e.delay }; case "CUSTOM_SPRING": { let t = e.easingFunction ?? fo.GENTLE_SPRING; return { type: "spring", stiffness: t[1], damping: t[2], mass: t[0], delay: e.delay } } default: return e.easingType, `${e.easingType}`, { ease: "easeOut", duration: e.transitionDuration } } } var Y5 = (...e) => ue() === "server" ? () => { } : (0, rr.useLayoutEffect)(...e); function sn(e, t, r, n, o) { let { disableBehaviors: i } = Ee(), s = (0, rr.useRef)(null), a = (0, rr.useRef)(null), { key: l, hasBehaviors: c, variants: u, initial: d, appearBehaviorOtherLayer: f, scrollTransformOtherLayer: p, hasAppearLoadBehavior: y, hasAppearScrollIntoViewBehavior: g, hasAppearScrollDirectionBehavior: S, hasHoverBehavior: h, hasPressBehavior: m, hasScrollTransformOnScrollBehavior: v, hasScrollTransformIntoViewBehavior: x, hasScrollSpeedBehavior: C, hasCursorBehavior: T, transitionToVisible: E, transitionToExit: w, transitionToAndFromHover: k, transitionToAndFromPress: R, transitionBasedOnScrollDirection: A, scrollParallaxSpeed: N, replayAppearBehavior: O, replayScrollTransformBehavior: D, scrollTransformTransition: b } = (0, rr.useMemo)(() => { let Oe = Object.entries(i ? {} : t ?? {}).map(([$, oe]) => ({ ...oe, behaviorType: $ })).filter($ => $.behaviorType !== "code"), Y = U0(Oe, n, o); return AI(Y), Y }, [i, t, n, o]), { scale: H } = zr(), B = v || x, z = (0, rr.useMemo)(() => B ? { fromState: u[le.INITIAL], toState: u[le.EXIT] } : null, [B, u]), Q = (0, rr.useCallback)(() => q5({ domElement: s.current, hasBehaviors: c, variants: u, hasAppearLoadBehavior: y, hasAppearScrollIntoViewBehavior: g, hasAppearScrollDirectionBehavior: S, hasHoverBehavior: h, hasPressBehavior: m, hasScrollTransformBehavior: B, hasScrollTransformOnScrollBehavior: v, hasScrollTransformIntoViewBehavior: x, hasScrollSpeedBehavior: C, scrollTransformState: z, transitionToVisible: E, transitionToExit: w, transitionToAndFromHover: k, transitionToAndFromPress: R, transitionBasedOnScrollDirection: A, scrollTransformTransition: b, appearBehaviorOtherLayer: f, scrollTransformOtherLayer: p, replayAppearBehavior: O, replayScrollTransformBehavior: D, scrollParallaxSpeed: N, scale: H }), [c, u, y, g, S, h, m, B, v, x, C, z, E, w, k, R, A, b, f, p, O, D, N, H]), se = (0, rr.useCallback)(xe => { s.current && a.current?.(), s.current = xe, a.current = Q?.(), xe ? Cx(e, xe) : bx(e) }, [e, Q]), he = (0, rr.useRef)(e); return Y5(() => { s.current && Cx(e, s.current), he.current !== e && (bx(he.current), he.current = e) }, [s, e]), qI({ ref: s, hasCursorBehavior: T, assets: r, behaviors: t }), (0, rr.useEffect)(() => { if (!(!s.current || !c)) return a.current = Q(), () => a.current?.() }, [Q, c]), c ? { ref: se, key: l, motionProps: { initial: d, variants: u } } : { ref: se, key: l, motionProps: {} } } function q5(e) { let { domElement: t, hasBehaviors: r, variants: n, hasAppearLoadBehavior: o, hasAppearScrollIntoViewBehavior: i, hasAppearScrollDirectionBehavior: s, hasHoverBehavior: a, hasPressBehavior: l, hasScrollTransformBehavior: c, hasScrollTransformOnScrollBehavior: u, hasScrollTransformIntoViewBehavior: d, hasScrollSpeedBehavior: f, scrollTransformState: p, transitionToVisible: y, transitionToExit: g, transitionToAndFromHover: S, transitionToAndFromPress: h, transitionBasedOnScrollDirection: m, scrollTransformTransition: v, appearBehaviorOtherLayer: x, scrollTransformOtherLayer: C, replayAppearBehavior: T, replayScrollTransformBehavior: E, scrollParallaxSpeed: w, scale: k } = e; if (!t || !r) return () => { }; let R = !1, A = [() => { R = !0 }]; if (o && gr(t, n[le.VISIBLE], y), i) { let N = O => { let D = !1, b; function H() { R || !t || !D || b || (b = gr(t, n[le.VISIBLE], y).then(() => { b = void 0, B() }), T || z()) } function B() { R || !t || D || b || (b = gr(t, n[le.EXIT] ?? n[le.VISIBLE], g).then(() => { b = void 0, gr(t, n[le.INITIAL] ?? n[le.VISIBLE], { duration: 0 }), H() })) } let z = H0(O, () => (D = !0, H(), () => { D = !1, B() })); A.push(z) }; x ? tm(x).then(O => { R || N(O) }) : t && N(t) } if (s) { let N = Id(O => { let D = O.y.velocity; D > 0 ? (gr(t, n[le.SCROLL_DIRECTION] ?? n[le.VISIBLE], m), T || N()) : D < 0 && gr(t, n[le.VISIBLE], m) }, { container: wx() }); A.push(N) } if (a) { let N = D => { D.pointerType !== "touch" && gr(t, n[le.HOVER] ?? n[le.VISIBLE], S) }, O = D => { D.pointerType !== "touch" && gr(t, n[le.VISIBLE], S) }; t.addEventListener("pointerenter", N), t.addEventListener("pointerleave", O), A.push(() => { t.removeEventListener("pointerenter", N), t.removeEventListener("pointerleave", O) }) } if (l) { let N = () => { gr(t, n[le.PRESS] ?? n[le.VISIBLE], h), window.addEventListener("pointerup", O), window.addEventListener("pointercancel", O) }, O = () => { gr(t, n[le.VISIBLE], h), window.removeEventListener("pointerup", O), window.removeEventListener("pointercancel", O) }; t.addEventListener("pointerdown", N), t.addEventListener("pointerup", O), t.addEventListener("pointercancel", O), A.push(() => { t.removeEventListener("pointerdown", N), t.removeEventListener("pointerup", O), t.removeEventListener("pointercancel", O), window.removeEventListener("pointerup", O), window.removeEventListener("pointercancel", O) }) } if (c) { let N = O => { let D = !1, b = Id(H => { if (D) return; let B = 0; if (u) B = H.y.scrollLength > 0 ? H.y.current / H.y.scrollLength : 1; else if (d) { let ve = H.y.current + H.y.containerLength, ie = H.y.targetOffset, Se = H.y.targetLength, Yt = (ve - ie) / Se; B = Math.min(1, Math.max(0, Yt)) } let { fromState: z, toState: Q } = p, se = os(B, [0, 1], [z.opacity, Q.opacity]), he = os(B, [0, 1], [z.scaleX, Q.scaleX]), xe = os(B, [0, 1], [z.scaleY, Q.scaleY]), Oe = os(B, [0, 1], [z.translateX, Q.translateX]), Y = os(B, [0, 1], [z.translateY, Q.translateY]), $ = os(B, [0, 1], [z.rotate, Q.rotate]); B === 1 && !E && (D = !0); let oe = () => { gr(t, { opacity: se, scaleX: he, scaleY: xe, translateX: Oe, translateY: Y, rotate: $ }, v) }; Z.postRender(oe) }, { container: Rx(O), target: O }); A.push(b) }; C ? tm(C).then(O => { R || N(O) }) : t && N(t) } if (f) { let N = Id(O => { if (w !== 1) { let D = O.y.current / k.get() * (1 - w); gr(t, { y: D }, { duration: 0 }) } }, { container: Rx(t), target: t }); A.push(N) } return () => { A.forEach(N => N()) } } var nP = (e, t) => (0, rr.useMemo)(() => { if (!(!e || !t)) return { transformTemplate: El(e) } }, [e, t]); var Q5 = { ALPHA: "alpha", LUMINANCE: "luminance", VECTOR: "alpha" }; function an({ node: e, context: t }) { let { masks: r } = t || {}; if (!r) return {}; let n = jh(e, t?.group?.withinAutoLayout), o = r.reduce((s, a) => { let l = a, c = Vo(l.assets, l.hash), u = ee.state.getAssetURL(c.url), { isolatedAbsoluteRenderBounds: d } = l, { absoluteBoundingBox: f } = e, p = jh(l); if (s.maskImage.push(`url("${u}")`), s.maskRepeat.push("no-repeat"), s.maskClip.push("no-clip"), s.maskComposite.push("intersect"), s.maskMode.push(l.maskType ? Q5[l.maskType] : "alpha"), d) { let y = d.x - f.x, g = d.y - f.y, S = [`${L(y)}px`, `${L(g)}px`], h = [`${L(d.width)}px`, `${L(d.height)}px`]; p.horizontal === Pn.LEFT_RIGHT && n.horizontal === p.horizontal && (S[0] = ut(y / f.width), h[0] = ut(d.width / f.width)), p.vertical === Ln.TOP_BOTTOM && n.vertical === p.vertical && (S[1] = ut(g / f.height), h[1] = ut(d.height / f.height)), s.maskPosition.push(S.join(" ")), s.maskSize.push(h.join(" ")) } else s.maskSize.push("auto"), s.maskPosition.push("0px 0px"); return s }, { maskImage: [], maskPosition: [], maskRepeat: [], maskClip: [], maskComposite: [], maskSize: [], maskMode: [] }), i = Object.fromEntries(Object.entries(o).map(([s, a]) => [s, a.join(", ")])); return i.WebkitMaskImage = i.maskImage, i.WebkitMaskPosition = i.maskPosition, i.WebkitMaskRepeat = i.maskRepeat, i.WebkitMaskClip = i.maskClip, i.WebkitMaskSize = i.maskSize, i } function xr(e, t = !1, r, n) { if (e === void 0) return {}; let o = L(e); if (t) { let i = X(n, r, o); if (i) return { opacity: i } } return o === 1 ? {} : { opacity: o } } function Nt(e, t) { let r = e?.group?.opacity ?? 1, n = t.opacity ?? 1; return r * n } var oP = I(P()); function ln(...e) { return (0, oP.useMemo)(() => t => { e.forEach(r => { if (r != null) { if (typeof r == "function") { r(t); return } try { r.current = t } catch { throw new te(`Cannot assign value '${JSON.stringify(t)}' to ref '${JSON.stringify(r)}'`) } } }) }, e) } function cn(e) { if (!(!$h() || /^(Frame|Rectangle|Polygon|Star|Group|Line|Ellipse|Vector|Arrow) \d+$/.test(e.name))) return e.name } function Z5(e, t, r, n) { return e ? r ? "div" : "a" : t ? r ? "div" : "button" : n ? "ul" : null } function J5(e) { switch (e) { case "ARTICLE": return "article"; case "ASIDE": return "aside"; case "FIGURE": return "figure"; case "FOOTER": return "footer"; case "HEADER": return "header"; case "MAIN": return "main"; case "NAV": return "nav"; case "SECTION": return "section"; case "OL": return "ol"; case "UL": return "ul"; case "IMG": case "VIDEO": case "AUTO": case "DIV": default: return "div" } } function us(e) { return e === "main" } function ng(e) { return e.semanticTag === "ol" || e.semanticTag === "ul" ? e.semanticTag : e.interactiveSemanticTag === "ul" ? "ul" : null } function ds(e, t, r, n, o) { return { interactiveSemanticTag: Z5(t, r, n, o), semanticTag: J5(e.accessibleHTMLTag) } } function og(e, t, r) { let n = e !== "div" && e !== "p", o = t != null, i = e, s = !1, a = !1; return n ? (i = e, o && (s = !0), r && (a = !0)) : r ? o ? (a = !0, i = t) : i = "li" : o ? i = t : i = e, { finalInnerSemanticTag: i, needsInteractiveWrapper: s, needsListWrapper: a } } var nr = I(W()), Jle = I(P()), Qo = I(un()); var Rc = I(W()), Kle = I(P()); var iP = I(P()); function eH() { return () => { } } function Ic() { return iP.useSyncExternalStore(eH, () => !0, () => !1) } function dn({ children: e, fallback: t = null }) { return Ic() ? (0, Rc.jsx)(Rc.Fragment, { children: e() }) : (0, Rc.jsx)(Rc.Fragment, { children: t }) } var Rd = I(W()), G0 = I(P()); var kc = (0, G0.forwardRef)(function ({ tag: t, children: r, needsMotion: n, motionProps: o, ...i }, s) { let a = t; if (!n) return (0, Rd.jsx)(a, { ref: s, ...i, children: r }); let l = tn[t]; return (0, Rd.jsx)(l, { ref: s, ...o, ...i, children: r }) }), sP = (0, G0.forwardRef)(function ({ needsMotion: t, motionProps: r, alt: n, ...o }, i) { return t ? (0, Rd.jsx)(tn.img, { ref: i, ...r, alt: n, ...o }) : (0, Rd.jsx)("img", { ref: i, alt: n, ...o }) }); function lP({ node: e, parent: t, backgroundInfo: r, sharedBackgroundStyles: n, smartAnimateType: o, transitionData: i }) { let s = kt(i), l = o === K.INSTANCE_SUBTREE && r.length === 0, c = {}; l ? c = n : r.length === 1 ? c = { ...r[0].backgroundStyles, ...n } : r.length > 1; let { motionTransitionProps: u, cssStyles: d } = bl(o, r.length === 0 ? 0 : 1, c, void 0, i, l ? void 0 : s), f = Mo(o, i, c.transform), p = de(e, "background"), y = M({ position: "absolute", inset: 0, pointerEvents: "none" }), g = M(d); if (r.length === 1 || l) { let S = o !== K.NONE, h = { ...u, ...f }; return r[0]?.imageProps ? (0, nr.jsx)(cP, { customClassname: (0, Qo.default)(y, g), id: p, imageProps: r[0].imageProps, styles: r[0].backgroundStyles, node: e, parent: t, needsMotion: S, motionProps: h }) : r[0]?.videoProps ? (0, nr.jsx)(iH, { customClassname: g, node: e, videoProps: r[0].videoProps, styles: r[0].backgroundStyles }) : (0, nr.jsx)(kc, { tag: "div", className: (0, Qo.default)(y, g), needsMotion: S, motionProps: h, id: p, "aria-hidden": !0 }) } else return r.length === 0 ? null : (0, nr.jsx)(tH, { id: p, sharedBackgroundStyles: n, backgroundDivClassName: y, backgroundInfo: r, node: e, parent: t }) } function tH({ id: e, sharedBackgroundStyles: t, backgroundDivClassName: r, backgroundInfo: n, node: o, parent: i }) { let { backdropFilter: s, ...a } = t; return (0, nr.jsx)("div", { id: e, "aria-hidden": !0, className: (0, Qo.default)(r, M(a)), children: n.map(({ backgroundStyles: l, imageProps: c }, u) => { let d = u === n.length - 1, f = { ...a, backdropFilter: d ? s : void 0, ...l }; return c ? (0, nr.jsx)(cP, { imageProps: c, styles: f, node: o, parent: i, needsMotion: !1, motionProps: {} }, u) : (0, nr.jsx)(rH, { styles: f, backgroundDivClassName: r }, u) }) }) } function rH({ styles: e, backgroundDivClassName: t }) { return (0, nr.jsx)("div", { className: (0, Qo.default)(M(e), t) }) } function cP({ styles: e, node: t, parent: r, customClassname: n, id: o, needsMotion: i, motionProps: s, imageProps: a }) { let { getAssetURL: l, renderOptions: { disableImageOptimization: c } } = re(), { url: u, cropDivInfo: d, size: f } = a, p = de(t, "image-cropper"), y = d ? { position: "absolute", width: ut(d.widthPercent), height: ut(d.heightPercent), top: ut(d.topPercent), left: ut(d.leftPercent), maxWidth: "none" } : { maxWidth: "none", ...e, position: "absolute", width: "100%", height: "100%" }, g = M(d ? { ...e, overflow: "hidden", position: "absolute", inset: 0 } : {}), S = M(y), h = d ? S : (0, Qo.default)(S, n), m = d ? (0, Qo.default)(g, n) : g, { srcset: v, sizes: x } = c ? { srcset: void 0, sizes: void 0 } : $0(l, t, r, u, f, d ? { x: d.widthPercent, y: d.heightPercent } : void 0), C = (0, nr.jsx)(sP, { loading: t.lazyLoad ? "lazy" : void 0, className: h, id: o || void 0, alt: t.accessibleLabel || "", src: l(u), srcSet: v, sizes: t.lazyLoad ? `auto,${x}` : x, needsMotion: i, motionProps: s }); return d ? (0, nr.jsx)("div", { id: p, className: m, children: C }) : C } var aP = [64, 128, 256, 512, 1024, 1536, 2048, 2560, 3072, 3584, 4096], nH = 3, oH = 512; function $0(e, t, r, n, o, i) { let s = ot(t, r) === G.FIXED && mt(t, r) === G.FIXED && !rn(t, r), a = i ?? { x: 1, y: 1 }, l = `${Math.ceil(a.x * 100)}vw`, c = oH, u = Math.max(o.x, o.y); if (s) { let f = { x: t.size.x * a.x, y: t.size.y * a.y }; l = `${f.x}px`, c = o.x >= o.y ? f.x : f.y, u = Math.min(u, c * nH) } let d = `${e(n)} ${Math.ceil(o.x)}w`; if (o.x >= o.y) for (let f of aP) { if (f < c) continue; if (f > u) break; let p = Math.ceil(f * a.x); d += `, ${e(n, { width: p })} ${p}w` } else for (let f of aP) { if (f < c) continue; if (f > u) break; let p = o.x / o.y, y = Math.ceil(f * a.y); d += `, ${e(n, { height: y })} ${Math.ceil(y * p)}w` } return { srcset: d, sizes: l } } function iH({ node: e, videoProps: t, styles: r, customClassname: n }) { let { getVideoURL: o, env: i } = re(), { cropDivInfo: s } = t, a = de(e, "video-cropper"), l = s ? { position: "absolute", width: ut(s.widthPercent), height: ut(s.heightPercent), top: ut(s.topPercent), left: ut(s.leftPercent), maxWidth: "none" } : { maxWidth: "none", ...r, position: "absolute", width: "100%", height: "100%" }, c = M(s ? { ...r, overflow: "hidden", position: "absolute", inset: 0 } : {}), u = M(l), d = s ? u : (0, Qo.default)(u, n), f = s ? (0, Qo.default)(c, n) : c; if (!["FRAME", "RECTANGLE"].includes(e.type)) return console.error("BackgroundNonTileVideo: node is not a frame or rectangle", e), null; let p = t.autoplay || t.muted, y = e.accessibleLabel || "", g = { autoPlay: t.autoplay, loop: t.mediaLoop, controls: t.showControls, muted: p, playsInline: t.autoplay }; i === "published" && matchMedia("(prefers-reduced-motion: reduce)").matches && (g.autoPlay = !1), t.isDecorative && (g.role = "presentation", g["aria-hidden"] = !0); let S = (0, nr.jsx)(dn, { children: () => (0, nr.jsx)("video", { ...g, controlsList: "nodownload", className: d, "aria-label": y, children: (0, nr.jsx)("source", { src: o(t.url, t.hash) }) }) }); return s ? (0, nr.jsx)("div", { id: a, className: f, children: S }) : S } var uP = I(W()), fce = I(P()), dP = I(un()); function fP({ node: e, smartAnimateType: t, nodeHasStrokes: r, transitionData: n, borderStyles: o }) { let i = kt(n), { motionTransitionProps: s, cssStyles: a } = bl(t, 1, o ?? {}, void 0, n, r ? i : void 0), l = Mo(t, n, o?.transform), c = de(e, "border"), u = M(a), d = (0, dP.default)(u); return (0, uP.jsx)(kc, { tag: "div", "aria-hidden": !0, needsMotion: t !== K.NONE, motionProps: { ...s, ...l }, id: c, className: d }) } var K0 = I(W()), ag = I(P()); function sg({ children: e, context: t = {} }) { let r = { ...t }, n = t?.masks; return e.sort((o, i) => o.scrollBehavior === "FIXED" && i.scrollBehavior !== "FIXED" ? -1 : 0), e.reduce((o, i) => ("isMask" in i ? i.isMask ?? !1 : !1) ? (r = { ...r, masks: n ? [...n, i] : [i] }, o) : (o.push([i, { key: i.key, context: r }]), o), []) } function pP(e) { let { childNodes: t, parent: r, context: n, reverseZIndex: o, parentRef: i, parentTransitionProps: s, onTransitionEnd: a } = e, c = (s?.smartAnimateType ?? K.NONE) === K.INSTANCE_SUBTREE, u = sg({ children: t, context: n }), d = c ? Px : ag.Fragment, f = c ? MI(s?.transitionData, a) : void 0; return ag.default.useMemo(() => (0, K0.jsx)(d, { ...f ?? {}, children: u?.length ? u.map(([y, { key: g, context: S }], h) => { let m = o ? u.length - h : void 0; return (0, K0.jsx)(lg, { name: "sites-layer", nodeId: y.id, childKey: g, node: y, parent: r, context: S, zIndex: m, codeBehaviorProps: { parentRef: i } }, g) }) : null }), [d, f, u, i, r, o]) } var X0 = I(W()), Fce = I(P()); var cg = I(W()), Rce = I(P()); var sH = e => { let t = e.layoutMode; if (e.type !== "FRAME" || !(t === "HORIZONTAL" || t === "VERTICAL")) return; let r; e.primaryAxisAlignItems === "MAX" ? r = "flex-end" : e.primaryAxisAlignItems === "CENTER" && (r = "center"); let n; if (e.counterAxisAlignItems === "MAX" ? n = "flex-end" : e.counterAxisAlignItems === "CENTER" && (n = "center"), !(!r && !n)) return { display: "flex", flexDirection: t === "VERTICAL" ? "column" : "row", alignItems: n, justifyContent: r } }; function mP({ node: e, children: t, style: r, innerTag: n = "div" }) { let o = de(e, "clipper"), { overflowX: i, overflowY: s, borderRadius: a, ...l } = r, { minWidth: c, minHeight: u, maxWidth: d, maxHeight: f } = r, p = M({ overflowX: i, overflowY: s, borderRadius: a, width: "100%", height: "100%", minWidth: c, minHeight: u, maxWidth: d, maxHeight: f, ...sH(e) }), y = M(l); return (0, cg.jsx)("div", { id: o, className: p, children: (0, cg.jsx)(n, { className: y, children: t }) }) } function hP({ node: e, style: t, children: r, innerTag: n = "div" }) { let o = de(e, "clipper"), i = M(t); return (0, cg.jsx)(n, { id: o, className: i, children: r }) } var gP = (e, t, r) => { if (r || !Wt(e)) return !1; let n = e.paddingLeft + e.paddingRight; if (n > 0) { let i = ot(e, t); switch (i) { case G.FILL_PARENT: return !0; case G.HUG_CONTENTS: break; case G.FIXED: if (n > e.size.x) return !0; break; default: ye(i) } } let o = e.paddingTop + e.paddingBottom; if (o > 0) { let i = mt(e); switch (i) { case G.FILL_PARENT: return !0; case G.HUG_CONTENTS: break; case G.FIXED: if (o > e.size.y) return !0; break; default: ye(i) } } return !1 }; function ug(e) { let { canSmartAnimate: t, hasChildNodes: r, isResponsiveScalingEnabled: n, parentClipsContent: o, parentHasStrokes: i, parentIncludesStrokesInLayout: s, parentHasAutoLayoutPadding: a, hasMarquee: l } = e; return r && i && o || a || s || n || t || l } var fs = I(W()), _e = I(P()), yP = I(un()); var aH = "left", lH = 6, cH = !1, dg = _e.default.forwardRef(function ({ node: t, style: r = {}, className: n = "", children: o }, i) { let s = t.behaviors?.marquee?.direction ?? aH, a = t.behaviors?.marquee?.speed ?? lH, l = t.behaviors?.marquee?.shouldLoopInfinitely ?? cH, [c, u] = (0, _e.useState)(0), [d, f] = (0, _e.useState)(0), [p, y] = (0, _e.useState)(1), [g, S] = (0, _e.useState)(!1), h = (0, _e.useRef)(null), m = i || h, v = (0, _e.useRef)(null), x = Zu(), C = (0, yP.default)("marquee", x ? "" : "reduced-motion"), T = (0, _e.useCallback)(N => { if (v.current && m.current) { let O = m.current.getBoundingClientRect(), D = v.current.getBoundingClientRect(), b = c === 0 ? O.width : c, H = D.width; if ((s === "UP" || s === "DOWN") && (b = O.height, H = D.height), l && b && H) { let B = H < b ? Math.ceil(b / H) : 1; y(B) } else y(1); f(H), (c === 0 || N) && u(O.width) } }, [l, m, c, s]); (0, _e.useEffect)(() => { if (g && (T(), v.current && m.current)) { let N = new ResizeObserver(() => { T(!0) }); return N.observe(m.current), N.observe(v.current), () => { N && N.disconnect() } } }, [T, m, g]), (0, _e.useEffect)(() => { T() }, [T, o]), (0, _e.useEffect)(() => { S(!0) }, []); let E = (0, _e.useMemo)(() => l ? d * p / a : d < c ? c / a : d / a, [l, c, d, p, a]), w = (0, _e.useMemo)(() => ({ ...r, ["--width"]: s === "UP" || s === "DOWN" ? "100vh" : "100%", ["--transform"]: s === "UP" ? "rotate(-90deg)" : s === "DOWN" ? "rotate(90deg)" : "none" }), [r, s]), k = (0, _e.useMemo)(() => ({ ["--direction"]: s === "LEFT" ? "normal" : "reverse", ["--duration"]: `${E}s`, ["--delay"]: "0s", ["--iteration-count"]: "infinite", ["--min-width"]: l ? "auto" : "100%", ["--timing-function"]: qS() ? "steps(3)" : "linear" }), [s, E, l]), R = (0, _e.useMemo)(() => ({ ["--transform"]: s === "UP" ? "rotate(90deg)" : s === "DOWN" ? "rotate(-90deg)" : "none" }), [s]), A = (0, _e.useCallback)((N, O) => [...Array(Number.isFinite(N) && N >= 0 ? N : 0)].map((D, b) => (0, fs.jsx)(_e.Fragment, { children: _e.Children.map(o, H => (0, fs.jsx)("div", { style: R, className: "marquee-child", "aria-hidden": O, children: H })) }, b)), [R, o]); return g ? (0, fs.jsxs)("div", { ref: m, style: w, className: "marquee-container " + n, children: [(0, fs.jsxs)("div", { className: C, style: k, children: [(0, fs.jsx)("div", { className: "marquee-initial-child-container", ref: v, children: A(1) }), A(p - 1, !0)] }), (0, fs.jsx)("div", { className: C, style: k, children: A(p, !0) })] }) : null }); var fg = I(W()), Bce = I(P()); function Hr({ children: e }) { return (0, fg.jsx)(fg.Fragment, { children: e }) } function vP(e) { let { parent: t, canSmartAnimate: r, hasChildNodes: n, isResponsiveScalingEnabled: o, parentClipsContent: i, parentHasStrokes: s, parentIncludesStrokesInLayout: a, parentHasAutoLayoutPadding: l, parentIsAutoLayout: c, parentSizeConstraints: u, children: d, listTag: f, styles: { clipperStyles: p, innerStyles: y, overflowStyles: g, borderDisplacement: S, wrapperSizeStyles: h, marqueeSizeStyles: m } } = e, v = uH(t), x = ug({ canSmartAnimate: r, hasChildNodes: n, isResponsiveScalingEnabled: o, parentClipsContent: i, parentHasStrokes: s, parentIncludesStrokesInLayout: a, parentHasAutoLayoutPadding: l, hasMarquee: v }), T = c && (l || v) ? mP : x ? hP : Hr, E = v ? dg : Hr, w = { ...h, ...m, ...g }, k = {}; return c && (u.minWidth && (k.minWidth = "inherit"), u.minHeight && (k.minHeight = "inherit"), u.maxWidth && (k.maxWidth = "inherit"), u.maxHeight && (k.maxHeight = "inherit")), x && (w = { ...w, ...p }), (0, X0.jsx)(E, { node: t, style: w, children: (0, X0.jsx)(T, { node: t, innerTag: f, style: { ...k, ...p, ...y, ...g, ...S, ...h, borderRadius: "inherit" }, children: d }) }) } function uH(e) { return yr(e) } var q0 = I(W()), Y0 = I(P()); function Q0(e) { return (e.effects || []).some(t => t.type === "INNER_SHADOW") } function SP({ node: e, parent: t, alwaysRenderBorderStyles: r }) { return Q0(e) ? (0, q0.jsx)(dH, { node: e, parent: t, alwaysRenderBorderStyles: r }) : null } function dH({ node: e, parent: t, alwaysRenderBorderStyles: r }) { let { shouldOutputVariables: n, codeSyntaxLanguage: o } = Ee(), i = Y0.useMemo(() => { let c = Fi(e) || r ? Xp(e, t, r, n, o) : void 0; return c ? { top: c.top, left: c.left, right: c.right, bottom: c.bottom } : {} }, [e, r, t, n, o]), s = Y0.useMemo(() => ({ position: "absolute", inset: 0, borderRadius: "inherit", pointerEvents: "none", ...D0(e.effects || [], n, o), ...i }), [e.effects, i, n, o]), a = de(e, "shadow"), l = M(s); return (0, q0.jsx)("div", { id: a, className: l }) } var mo = I(W()), GP = I(P()), Bd = I(un()); var Z0 = I(W()), J0 = I(P()), eT = J0.default.createContext(void 0); function Gt(e) { let { outerStyles: t, children: r } = e; return (0, Z0.jsx)(eT.Provider, { value: t, children: r }) } function Ac({ children: e }) { return (0, Z0.jsx)(eT.Provider, { value: void 0, children: e }) } function $t() { return J0.default.useContext(eT) } var pa = I(W()), hs = I(P()); var fH = { onMouseDown: "onMouseDown", onMouseUp: "onMouseUp", onMouseEnter: "onMouseEnter", onMouseLeave: "onMouseLeave", onClick: "onClick" }, tT = Object.values(fH); var Kt = I(W()), pn = I(P()), zP = I(P()), TH = I(nT()), EH = I(W()), CH = I(il()), bH = I(pp()), HP = I(un()); function ps(e) { let t = ue(); me(t !== "server", `${e} should never be rendered on the server.`) } var EP = I(W()), pg = I(P()), Nc = pg.createContext({ name: "", width: 0, height: 0 }); function oT({ name: e, width: t, height: r, children: n }) { let o = pg.useMemo(() => ({ name: e, width: t, height: r }), [e, t, r]); return (0, EP.jsx)(Nc.Provider, { value: o, children: n }) } var cT = I(W()), po = I(P()); var kd = class { backingComponentId; constructor(t) { this.backingComponentId = q(t) } get(t, r) { return t(this.backingComponentId) } set(t, r, n) { J().set(this.backingComponentId, n) } reset() { J().set(this.backingComponentId, null) } }, mg = class { variableState; nodeById; componentSetId = null; boundVariantProperties; unboundVariantProperties; boolMap = { true: !0, false: !1 }; constructor(t, r, n, o, i = []) { this.variableState = t, this.nodeById = r, this.componentSetId = n, this.boundVariantProperties = o.map(([s, a]) => [s, q(a)]), this.unboundVariantProperties = i.map(([s, a]) => [s, q(a)]) } get(t, r) { let n = this.boundVariantProperties.map(([s, a]) => [s, this._convertResolvedVariableValueToStringVariantValue(this.variableState.evaluateVariable(t, t(a).id, r))]), o = this.unboundVariantProperties.map(([s, a]) => [s, t(a)]), i = [...n, ...o]; return this._instanceIdFromVariantProperties(t, i) } set(t, r, n) { let o = Object.fromEntries(this._propertyValuesForVariant(t, n)); this.unboundVariantProperties.forEach(([i, s]) => { let a = o[i]; J().set(s, a) }), this.boundVariantProperties.forEach(([i, s]) => { let a = o[i]; let l = this.variableState.getVariableType(t(s).id, t, r), c = this._convertStringVariantValueToResolvedVariableType(l, a); this.variableState.setVariable(t(s).id, c, r) }) } _instanceIdFromVariantProperties(t, r) { if (this.componentSetId === null) return null; let n = t(this.nodeById.get(this.componentSetId)); return n.type, n.children.find(o => this._propertyValuesMatch(r, this._propertyValuesForVariant(t, o))) ?? null } _propertyValuesMatch(t, r) { let n = s => new Set(s.map(([a, l]) => JSON.stringify([a.toLowerCase(), l.toLowerCase()]))), o = n(t), i = n(r); return o.size === i.size && [...o].every(s => i.has(s)) } _propertyValuesForVariant(t, r) { return t(this.nodeById.get(r)).name.split(",").map(o => { let [i, s] = o.split("="); return [(i ?? "").trim(), (s ?? "").trim()] }) } _convertStringVariantValueToResolvedVariableType(t, r) { switch (t) { case "BOOLEAN": { let n = r.toLowerCase(); return n in this.boolMap, `${r}`, this.boolMap[n] ?? r } case "FLOAT": { let n = r.trim(), o = Number(n), i = n !== "" && Number.isFinite(o); return `${r}`, i ? o : r } case "COLOR": case "IMAGE": throw new te(`Cannot bind a variant property to a variable of type ${t}.`); case "STRING": case null: return r } } _convertResolvedVariableValueToStringVariantValue(t) { if (t === null) return "null"; switch (typeof t) { case "string": return t; case "boolean": case "number": return String(t); default: throw new te(`Cannot bind a variant property to a variable of type ${typeof t}.`) } } reset() { } }; var Ad = class { static parseModeId(t) { let r = t.split("/"); if (r.length < 2) return null; if (r.length === 3) { let n = r.slice(0, 2).join("/"), o = r[2]; return o ? { collectionId: n, modeGuid: o } : null } if (r.length === 2) { let n = r[0], o = r[1]; return !n || !o ? null : { collectionId: n, modeGuid: o } } return null } }; function mH(e) { let t = e.indexOf("/"); return t === -1 ? e : e.substring(0, t) } var iT = class { variableOverrideCache = new Map; createCacheKey(t, r, n) { return `${t}:${r}:${n}` } findVariableOrOverrideId(t, r, n, o) { let i = o.getAssetGuid(r), s = o.nodeById.get(i, o.disableVariableErrors), a = s && t(s); if (a?.type !== "VARIABLE") return null; let l = o.getCollectionInfo(t, a.variableCollectionId); if (!l) return null; let c = l.baseCollectionId || a.variableCollectionId, u = n[c], d = u && Ad.parseModeId(u); if (!d) return null; let f = this.createCacheKey(c, d.modeGuid, r), p = this.variableOverrideCache.get(f); if (p !== void 0) return n[p.resolvedCollectionId] = `${p.resolvedCollectionId}/${p.resolvedModeGuid}`, p.resultId === r ? null : p.resultId; let y = this.findVariableOverrideInCollectionHierarchy(t, r, d.collectionId, d.modeGuid, o), g = y?.overrideId || r; return this.variableOverrideCache.set(f, { resultId: g, resolvedCollectionId: y?.resolvedCollectionId, resolvedModeGuid: y?.resolvedModeGuid }), y ? (n[y.resolvedCollectionId] = `${y.resolvedCollectionId}/${y.resolvedModeGuid}`, y.overrideId) : null } findVariableOverrideInCollectionHierarchy(t, r, n, o, i) { let s = i.getAssetGuid(n), a = i.nodeById.get(s, i.disableVariableErrors); if (!a) return null; let l = t(a); if (l.type !== "VARIABLE_COLLECTION") return null; let c = l.relatedVariableIds?.[r]; if (c) { let u = i.getAssetGuid(c), d = i.nodeById.get(u, i.disableVariableErrors), f = d && t(d); if (f?.type === "VARIABLE" && f.valuesByMode?.[o] !== void 0) return { overrideId: c, resolvedCollectionId: n, resolvedModeGuid: o } } if (l.parentVariableCollectionId) { let u = this.getParentModeInfo(l, o); if (u) { let { parentCollectionId: d, parentModeId: f } = u; return this.findVariableOverrideInCollectionHierarchy(t, r, d, f, i) } } return null } getParentModeInfo(t, r) { if (!t.modes) return null; let n = t.modes.find(o => o.modeId.endsWith(`/${r}`)); if (!n || !n.parentModeId) return null; if (n.parentModeId.includes("/")) { let o = Ad.parseModeId(n.parentModeId); if (o) return { parentCollectionId: t.parentVariableCollectionId, parentModeId: o.modeGuid } } else return { parentCollectionId: t.parentVariableCollectionId, parentModeId: n.parentModeId }; return null } }, hg = class { map; nodeById; assetIdToGuid; assetIdToAssetKeyCache; disableVariableErrors; hierarchyResolver; constructor(t, r, n) { this.map = new WeakMap, this.nodeById = t, this.assetIdToGuid = r, this.assetIdToAssetKeyCache = new Map, this.disableVariableErrors = n ?? !1, this.hierarchyResolver = new iT } setVariable(t, r, n) { let o = J(), i = this.getVariable(t, o.get); i && o.get(i.atom).setModeValue(r, n) } evaluateVariable(t, r, n) { let o = this.hierarchyResolver.findVariableOrOverrideId(t, r, n, this) || r, i = this.getVariable(o, t); if (!i) return null; let s = t(i.atom), a = t(s.getModeValue(n)); return Bn({ get: t, variableState: this, modeContext: n }, a) } getVariableCodeSyntax(t, r) { let n = this.getVariable(r, t); return n ? t(n.atom).codeSyntax : {} } getVariableName(t, r) { let n = this.getVariable(r, t); return n ? t(n.atom).name : void 0 } getVariable(t, r) { let n = this.getAssetGuid(t), o = this.nodeById.get(n, this.disableVariableErrors); if (!o || r(o).type !== "VARIABLE") return null; let i = this.map.get(o); if (i) return i; let s = new sT(o, this, this.nodeById); return this.map.set(o, s), s } getVariableType(t, r, n) { let o = this.evaluateVariable(r, t, n); return o === null ? null : Ex(o) } getAssetKeyOrLocalGuid(t) { this.assetIdToAssetKeyCache.has(t) || this.assetIdToAssetKeyCache.set(t, mH(t)); let r = this.assetIdToAssetKeyCache.get(t); return me(r !== void 0, "assetKey is undefined"), r } getAssetGuid(t) { return this.assetIdToGuid.get(t, this.disableVariableErrors) || t } hasAssetId(t) { return this.assetIdToGuid.get(t, !0) !== void 0 } getCollectionInfo(t, r) { try { let n = this.getAssetGuid(r), o = this.nodeById.get(n, this.disableVariableErrors); if (!o) return null; let i = t(o); return i.type !== "VARIABLE_COLLECTION" ? null : i } catch { return null } } }, sT = class { atom; modeAtoms; constructor(t, r, n) { this.modeAtoms = new Map, this.atom = q(o => { let i = o(t), s = o(n.get(r.getAssetGuid(i.variableCollectionId), r.disableVariableErrors)), a = r.getAssetKeyOrLocalGuid(i.variableCollectionId), l = d => { let f = i.variableCollectionId, p = d?.[f] ?? d?.[a]; p || (p = s.defaultModeId); let g = Ad.parseModeId(p)?.modeGuid || p, S = this.modeAtoms.get(p); return S || (S = new hH(t, g), this.modeAtoms.set(p, S)), S }, c = d => l(d).atom, u = (d, f) => l(f).setValue(d); return { name: i.name, codeSyntax: i.codeSyntax ?? {}, getModeValue: c, setModeValue: u } }) } }, hH = class { valueAtom; atom; constructor(t, r) { this.valueAtom = q(void 0), this.atom = q(n => { let i = n(t).valuesByMode[r]; return n(this.valueAtom) ?? i }) } setValue(t) { J().set(this.valueAtom, t) } }; var aT = null, fn = class { instanceState; modeContextState = q({}); childNodeProps = new Map; transitionAtom = q(void 0); autoLayoutTransitionAtom = q(void 0); stateResetHandlers = []; variableState; cmsDataState = null; static createRoot(t, r, n, o) { (!aT || o) && (aT = new hg(t.nodeById, t.assetIdToGuid, n.disableVariableErrors)); let i = { backingComponentId: new kd(null), componentPropState: new Map }; return new fn(aT, r, i) } constructor(t, r, n) { this.variableState = t, this.cmsDataState = r, this.instanceState = n } resetComponentState = (t, r) => { this.instanceState.backingComponentId.reset(), this.stateResetHandlers.forEach(n => n(t, r)) }; getChildState(t, r, n) { let o = "componentSetId" in r && r.componentSetId ? r.componentSetId : null, i = this.childNodeProps.get(t), s; if (r.type === "INSTANCE") { let a = Object.entries(r.componentProperties).filter(([d, f]) => f.type === "VARIANT"), l = a.filter(([d, f]) => !f.boundVariables?.value).map(([d, f]) => [d, f.value]), c = a.filter(([d, f]) => !!f.boundVariables?.value).map(([d, f]) => [d, f.boundVariables.value]); s = { backingComponentId: c.length ? new mg(this.variableState, n, o, c, l) : new kd(null), componentPropState: new Map } } else s = this.instanceState; return i || (i = new fn(this.variableState, this.cmsDataState, s), this.childNodeProps.set(t, i), o && this.stateResetHandlers.push(i.resetComponentState)), i } }; var Tue = I(P()); function gH(e, t, r, n, o) { Object.entries(e).forEach(([i, s]) => { (!n || !n[i]) && (t[s] = a => { let l = r[i]; typeof a != typeof l && console.error(`Expected value of type ${typeof l} for property ${i}, but got ${typeof a}`), r[i] = a, o?.() }) }) } function lT(e) { let t = {}; if (!e) return t; for (let [r, n] of Object.entries(e)) n.setter && (t[r] = n.setter); return t } var CP = { src: "" }; function gg(e) { return e ?? !1 ? e : void 0 } function yg(e, t, r, n) { if (!n || !r) return CP; let o = e?.image ? t(n, e?.image) : void 0, s = (e?.animatedImage ? t(n, e.animatedImage) : void 0) ?? o; if (!s) return CP; let a = gg(s.size?.y) ?? e.originalImageHeight, l = gg(s.size?.x) ?? e.originalImageWidth; return { src: r(s.url), height: gg(a), width: gg(l), alt: e.altText } } var bP = new Map, yH = { renderedByCode: !0 }; function vH({ guid: e, modeContext: t, ...r }) { let n = re(), o = (0, po.useMemo)(() => n ? [{ key: e, nodeId: e, nodeById: n.websiteData.nodeById, assets: n.websiteData.assets, assetIdToGuid: n.websiteData.assetIdToGuid, guidToUrl: n.websiteData.guidToUrl, animateRootIds: n.websiteData.animateRootIds, stablePathToAssetHash: n.websiteData.stablePathToAssetHash, modeContext: t ?? {}, parentState: fn.createRoot(n.websiteData, null, n.renderOptions), parentStates: null }] : [], [e, n, t]), i = Qp(o), s = (0, po.useMemo)(() => { let a = Object.fromEntries(Object.entries(r).filter(([l]) => l.startsWith("data-"))); return { ...yH, style: r.style, className: r.className, dataAttributes: a } }, [r]); return i[0] ? (0, cT.jsx)(Fn, { node: i[0], parent: null, context: s }) : null } function IP(e, t, r) { let [, n] = (0, po.useReducer)(c => c + 1, 0), { variableState: o, modeContext: i } = e, s = re()?.getAssetURL, { finalProps: a, boundVariables: l } = (0, po.useMemo)(() => { let c = Object.fromEntries(Object.entries(OP(e.componentProperties, s, e.assets, r, i))), u = PP(e.componentProperties); return { finalProps: c, boundVariables: u } }, [e.componentProperties, r, i, s, e.assets]); if (o && i) for (let [c, u] of Object.entries(l)) { let d = t[c]; d && (a[d] = LP(u, o, i)), _P(u, c, o, a, i, n) } return Object.entries(t).forEach(([c, u]) => { l[c] || (a[u] = d => { let f = a[c]; typeof d != typeof f && console.error(`Expected value of type ${typeof f} for property ${c}, but got ${typeof d}`), a[c] = d, n() }) }), a } function RP(e) { let t = re(), { websiteData: r } = t ?? {}, n = J(), o = (0, po.useMemo)(() => !t || !r || !e?.length ? [] : e.map(i => { let s = i.codeComponentId, a = r.assetIdToGuid.get(s)?.toString(), l = a ? r.nodeById.get(a) : null, c = l ? n.get(l) : null; return c ? { codeNode: c, codeComponentId: s } : null }).filter(i => i !== null), [t, r, n, e]); return (0, po.useMemo)(() => o.map(i => i.codeNode), [o]) } function kP(e, t, r, n, o, i, s) { let [, a] = (0, po.useReducer)(p => p + 1, 0), { websiteData: l, getAssetURL: c } = re() ?? {}, u = l?.assetIdToGuid, { finalProps: d, boundVariables: f } = (0, po.useMemo)(() => { let p = Object.fromEntries(Object.entries(OP(e.componentPropertyDefinitions, c, s, i))), y = PP(e.componentPropertyDefinitions), g = (r ?? []).find(S => { let h = u?.get(S.codeComponentId); return e.id === h }); if (!g) return { finalProps: p, boundVariables: y }; for (let S of Object.keys(p)) S in g.assignments && g.assignments[S] !== void 0 && (typeof p[S] == "function" && typeof g.assignments[S] == "string" ? p[S] = NP(g.assignments[S]) : typeof g.assignments[S] == "object" && "image" in g.assignments[S] ? p[S] = yg(g.assignments[S], Vo, c, s) : p[S] = g.assignments[S]); return { finalProps: p, boundVariables: y } }, [e.id, e.componentPropertyDefinitions, u, c, s, i, r]); if (n && o) for (let [p, y] of Object.entries(f)) { let g = t[p]; g && (d[g] = LP(y, n, o)), _P(y, p, n, d, o, a) } return Object.entries(t).forEach(([p, y]) => { f[p] || (d[y] = g => { let S = d[p]; typeof g != typeof S && console.error(`Expected value of type ${typeof S} for property ${p}, but got ${typeof g}`), d[p] = g, a() }) }), d } var wP; (function (e) { e[e.None = 0] = "None", e[e.Mouse = 1] = "Mouse", e[e.Motion = 2] = "Motion", e[e.Uncategorized = 3] = "Uncategorized", e[e.TextOnly = 4] = "TextOnly" })(wP || (wP = {})); function AP(e) { let t = r => { let { category: n, nodeTypes: o } = r.codeBehaviorData, i = 0; switch (n) { case "mouse": i = 1; break; case "motion": i = 2; break; default: i = 3; break }return o && o.includes("TEXT") && (i = 4), i }; return [...e].sort((r, n) => t(r) - t(n)) } function NP(e, t) { let r = bP.get(e); return r || (r = function (o) { return e ? (0, cT.jsx)(vH, { guid: e, modeContext: t, ...o }) : null }, bP.set(e, r), r) } function OP(e, t, r, n, o) { let i = {}; if (!e) return i; for (let s in e) { let a = e[s], l = s.substring(0, s.lastIndexOf("#")); if (l && a && "type" in a) if (a.type === "INSTANCE_SWAP") if ("value" in a && a.value !== "-1:-1") i[l] = NP(a.value, o); else if (n?.[l]?.defaultValue) { let c = n[l].defaultValue; i[l] = c ?? (() => null) } else i[l] = () => null; else if (a.type === "TEXT") { let c = "value" in a ? a.value : a.defaultValue; i[l] = c.characters } else if (a.type === "IMAGE") if ("value" in a && a.value !== null && a.value.image) i[l] = yg(a.value, Vo, t, r); else if (n?.[l]?.defaultValue) { let c = n[l].defaultValue; i[l] = typeof c == "string" ? { src: c } : Mw(c) } else i[l] = { src: "" }; else i[l] = "value" in a ? a.value : "defaultValue" in a ? a.defaultValue : void 0 } return i } function PP(e) { let t = {}; if (!e) return t; for (let r in e) { let n = e[r], o = r.substring(0, r.lastIndexOf("#")); if (o && n && "boundVariables" in n && n.boundVariables) { let i = n.boundVariables; i.value && (t[o] = i.value.id) } } return t } function LP(e, t, r) { let n = J().get; return o => { let i = t.evaluateVariable(n, e, r); if (typeof o != typeof i && console.error(`Expected value of type ${typeof i} for variable ${e}, but got ${typeof o}`), typeof o == "function") { console.error("Cannot set function as variable value"); return } if (typeof o == "object" && "src" in o) { console.error("Cannot set image prop as variable value"); return } t.setVariable(e, o, r) } } function _P(e, t, r, n, o, i) { let s = J(), a = s.get, l = r.getVariable(e, a); if (l?.atom) { let u = s.get(l.atom).getModeValue(o), d = r.evaluateVariable(a, e, o); return n[t] = d, s.sub(u, () => { let p = r.evaluateVariable(a, e, o); n[t] = p, i() }) } } async function vg(e, t) { let r = (t || "default").split("."); if (r.length === 0) throw new te(`Code export name ${t} is empty`); let [n, o] = r; if (typeof e != "object") throw new te(`Code export ${t} is not an object`); let s = e[n]; if (r.length === 1) { if (s == null) throw new te(`Code export ${t} (${n}) is nullish`); return s } if (typeof s != "function") throw new te(`Code export ${t} (${n}) is not an function`); let a = await s(); if (typeof a != "object") throw new te(`Code export ${t} (${o}) is not an object`); let l = a[o]; if (l == null) throw new te(`Code export ${t} (${o}) is nullish`); return l } function DP(e) { let t = {}; if (!e) return t; for (let [r, n] of Object.entries(e)) n.setter && (t[r] = n.setter); return t } var Oc = (e, t, r) => { let n = new Rt(r); n.errorDetail = `sourceCodeHash: ${e}`, ke.reportError(n), console.error(r, t) }; var uT = I(P()); var SH = class MP { renderHooks; constructor(t = []) { this.renderHooks = t } cloneWithAdditionalHook(t) { return new MP([...this.renderHooks, t]) } }, da = uT.createContext(new SH), xH = class BP { renderHooks; constructor(t = []) { this.renderHooks = t } cloneWithAdditionalHooks(t) { return new BP([...this.renderHooks, t]) } }, fa = uT.createContext(new xH); function Nd() { let [e, t] = A0(); return [e, async (n, o, i) => n ? await t(n, o, i) : Promise.resolve()] } function Od(e, t) { if (e && t.name) { let r = e.querySelectorAll(`[${Zo}*="${t.name}"]`); return Array.from(r) } return [] } function Pd(e, t) { return e && t.name ? e.querySelector(`[${Zo}*="${t.name}"]`) : null } var VP = I(P()), Ld = VP.createContext({ isSnapshot: !1, snapshot: () => { }, enableManualSnapshot: () => { } }); var FP = I(W()), Sg = I(P()); var Pc = Sg.createContext({ shouldReduceMotion: !1 }); function dT({ children: e }) { let t = rm(), r = Sg.useMemo(() => ({ shouldReduceMotion: t }), [t]); return (0, FP.jsx)(Pc.Provider, { value: r, children: e }) } var WP = pn.forwardRef(({ children: e, tag: t, outerStyles: r }, n) => { let o = M({ display: "flex", ...r }), i = (0, HP.default)(o, "tailwind", "code-behavior-wrapper"); return (0, Kt.jsx)(t ?? "div", { ref: n, className: i, children: e }) }); WP.displayName = "CodeWrapperDiv"; var _d = pn.forwardRef(({ children: e, codeBehaviors: t, variableState: r, modeContext: n, assets: o }, i) => { let s = $t(), a = co(); return (0, Kt.jsx)(Ac, { children: (0, Kt.jsx)(lo, { children: (0, Kt.jsx)(dn, { children: () => (0, Kt.jsx)(WP, { tag: a, ref: i, outerStyles: s, children: (0, Kt.jsx)(fT, { codeBehaviors: t, variableState: r, modeContext: n, assets: o, children: e }) }) }) }) }) }); _d.displayName = "CodeBehaviorWrapper"; function wH({ node: e, Component: t, codeBehaviors: r, variableState: n, modeContext: o, children: i, assets: s }) { let a = IH(t), l = DP(a), u = { ...kP(e, l, r, n, o, a, s), children: i }; return (0, Kt.jsx)(t, { ...u }) } function fT({ children: e, codeBehaviors: t, variableState: r, modeContext: n, assets: o }) { ps("CodeComponentContent"); let i = Ic(), s = re(), a = re().getAssetURL, [l, c] = pn.useState([]); globalThis.__GLOBALS__ = { React: pn, ReactJSXRuntime: EH, ReactJSXDevRuntime: TH, ReactDOM: CH, ReactDOMClient: bH, SnapshotContext: Ld, NewRenderHooksContext: fa, RenderHooksContext: da, useAnimateNode: Nd, getChildNode: Pd, getChildNodes: Od, ActiveBreakpointContext: Nc, WebsiteSettingsContext: Pc, getAssetURL: a }; let u = pn.useMemo(() => AP(t), [t]), d = RP(u), f = re().websiteData.sourceCodeHash, p = ge(f), y = pn.useRef({}); return pn.useEffect(() => { if (!s || !d.length) return; let g = d.filter(S => !y.current[S.id]); g.length !== 0 && Promise.all(g.map(async S => { try { let m = await import(s.getCodeComponentURL(S)), x = await vg(m, S.codeExportName); return y.current[S.id] = x, x } catch (h) { return Oc(p, h, "Failed to import code behavior module"), null } })).then(S => { S.some(h => h !== null) && c(d.map(h => y.current[h.id] || null)) }).catch(S => { Oc(p, S, "Failed to load code behavior") }) }, [d, s, p]), !d.length || !s || !i ? (0, Kt.jsx)(Kt.Fragment, { children: e }) : l.length !== d.length || l.some(g => g === null) ? (0, Kt.jsx)(Kt.Fragment, { children: e }) : (0, Kt.jsx)(Kt.Fragment, { children: [...d].reverse().reduce((g, S, h) => { let m = l.length - 1 - h, v = l[m]; return v ? (0, Kt.jsx)(wH, { node: S, Component: v, codeBehaviors: t, variableState: r, modeContext: n, assets: o, children: g }, S.id) : g }, e) }) } function IH(e) { return e ? e[Symbol.for("figma.react.props")] ?? {} : null } function xg() { let e = (0, zP.useRef)(null); return { codeBehaviorWrapperRef: e, updateStyles: (r, n) => { e.current && (e.current.style.setProperty(as, `${n}`), e.current.style.setProperty(ls, `${r}`)) } } } function RH(e) { return e.type === "FRAME" || e.type === "RECTANGLE" } function Dd(e) { return e.type === "TEXT" } function kH(e) { return e.type === "IMAGE" || e.type === "SVG" } function AH(e) { return RH(e) || kH(e) || Dd(e) } var NH = 0, OH = 1; function jP(e, t) { if (!AH(e)) return !1; let r = e.behaviors?.code; return !r || r.length === 0 ? !1 : (r.length, r[0]?.codeBehaviorData.apiVersion === t) } function Md(e) { return jP(e, NH) } function PH(e) { return jP(e, OH) } function Lc(e) { return function (r) { let { layerRef: n, node: o } = r; return PH(o) ? (0, pa.jsx)(dn, { children: () => (0, pa.jsx)(fT, { codeBehaviors: o.behaviors.code, variableState: o.variableState, modeContext: o.modeContext, assets: o.assets, children: (0, pa.jsx)(LH, { LayerComponent: e, ...r }) }) }) : (0, pa.jsx)(e, { ...r, ref: n }) } } function ms(e, t) { return t in e } function LH(e) { let { layerRef: t, LayerComponent: r, codeBehaviorProps: n } = e, o = hs.useContext(fa), i = e.node, s = null, a = {}, l = { ...n, usingNewAPI: !0 }; if (o.renderHooks.length) for (let d of o.renderHooks) { ms(d, "renderText") && Dd(i) && (i = { ...i, renderTextHook: d }), ms(d, "renderTextCharacter") && Dd(i) && (i = { ...i, renderTextCharacterHook: d }), ms(d, "renderTextLine") && Dd(i) && (i = { ...i, renderTextLineHook: d }), ms(d, "renderTextWord") && Dd(i) && (i = { ...i, renderTextWordHook: d }), ms(d, "nodeRef") && (s = d.nodeRef), ms(d, "style") && (l = { ...l, style: d.style }), ms(d, "childrenStyles") && (a.childrenStyles = d.childrenStyles); for (let f of tT) ms(d, f) && (l = { ...l, [f]: d[f] }) } let c = ln(t, s), u = { ...e, node: i, codeBehaviorProps: l }; return (0, pa.jsx)(zn.Provider, { value: a, children: (0, pa.jsx)(r, { ...u, ref: c }) }) } var zn = hs.createContext(void 0), Zo = "data-figma-animate-name"; function _c() { let e = hs.useContext(zn); return Boolean(e) } function _H(e, t) { let r = hs.useContext(zn); if (e) return; let n = r?.childrenStyles?.find(s => t.includes(s.nodeName)); if (!n) return; let { nodeName: o, ...i } = n; return i } function UP(e, t) { let r = hs.useContext(zn), n = _H(!!t?.usingNewAPI, e); if (!r) return; let o = t?.style; if (!(!o && !n)) return { ...n, ...o } } function Dc(e, t) { if (!hs.useContext(zn) || !t) return; let n = {}; for (let o of tT) o in t && (n[o] = t[o]); if (Object.keys(n).length !== 0) return n } var ho = GP.default.forwardRef(function (t, r) { let { children: n, wrapperSizeStyles: o, semanticTagInfo: i, nodeName: s, context: a, styles: l, additionalClassName: c, transitionProps: u, tabIndex: d, needsMotionForCodeBehavior: f, codeBehaviorProps: p, ...y } = t, { semanticTag: g, interactiveSemanticTag: S } = i, h = $t() ?? o, { ignoreEmptyAbsoluteElements: m } = Ee(), { finalInnerSemanticTag: v, needsInteractiveWrapper: x, needsListWrapper: C } = og(g, S, Yh()), T = C || x ? l : { ...h, ...l }, E = Mo(u.smartAnimateType, u.transitionData, T.transform), { motionTransitionProps: w, cssStyles: k } = bl(u.smartAnimateType, u.opacity, T, u.behaviorProps?.variants, u.transitionData, u.onTransitionEnd), R = nP(T.transform, u.behaviorProps?.variants), A = UP(s, p), N = f ? { transformTemplate: T.transform ? El(T.transform) : void 0, ...A ? { style: { ...A } } : {} } : void 0; PI([u.behaviorProps, R, w, E]); let O = M(h, a?.renderedByCode), D = M(k, a?.renderedByCode), b = (0, Bd.default)(c, D, a?.className), H = M({ width: "100%", height: "100%", display: "block" }), z = u.smartAnimateType !== K.NONE || Object.keys(u.behaviorProps).length > 0 || f ? tn[v] : v, Q = { ...u.behaviorProps, ...E, ...w, ...R, ...N, ref: r }; if (C) if (x) { let he = S, { href: xe, role: Oe, target: Y, rel: $, onMouseDown: oe, onClick: ve, onKeyDown: ie, ...Se } = y; return (0, mo.jsx)("li", { className: O, children: (0, mo.jsx)(he, { className: H, href: xe, target: Y, role: Oe, rel: $, tabIndex: d, onMouseDown: oe, onClick: ve, onKeyDown: ie, children: (0, mo.jsx)(z, { className: (0, Bd.default)(H, b), tabIndex: us(v) ? -1 : void 0, ...Q, ...Se, children: n }) }) }) } else return (0, mo.jsx)("li", { className: O, children: (0, mo.jsx)(z, { className: (0, Bd.default)(H, b), tabIndex: us(v) ? -1 : d, ...Q, ...y, children: n }) }); if (x) { let { href: he, role: xe, target: Oe, rel: Y, onMouseDown: $, onClick: oe, onKeyDown: ve, ...ie } = y; return (0, mo.jsx)(S, { className: O, href: he, target: Oe, role: xe, rel: Y, tabIndex: d, onMouseDown: $, onClick: oe, onKeyDown: ve, children: (0, mo.jsx)(z, { className: (0, Bd.default)(H, b), tabIndex: us(v) ? -1 : void 0, ...Q, ...ie, children: n }) }) } let se = { ...Q, ...y }; return m && Yp(k) && !c && !a?.className && se.style === void 0 && (z = Hr), (0, mo.jsx)(Ac, { children: (0, mo.jsx)(z, { className: b, tabIndex: us(v) ? -1 : d, ...se, children: n }) }) }); var $P = I(W()), Tg = I(P()); function KP({ node: e }) { return (0, Tg.useMemo)(() => Tl().stateSwapNodeToMonitor === e.id, []) ? (0, $P.jsx)(DH, { node: e }) : null } function DH({ node: e }) { return (0, Tg.useEffect)(() => { e.id === Uw() && (Bi("timerEvent", { timerName: "swap-state", eventName: "timer_stop" }), Rp(void 0)) }, [e]), null } var mn = I(W()), hT = I(P()); var gs = I(W()), Ide = I(P()); function pT(e) { let { parent: t, node: r, children: n } = e; return _h(r, t) ? (0, gs.jsx)(MH, { node: r, parent: t, children: n }) : (0, gs.jsx)(gs.Fragment, { children: n }) } function MH(e) { let { node: t, parent: r, children: n } = e, o = de(t, "fillWrapper"), { order: i, ...s } = $t() ?? {}, a = M({ display: "flex", flex: s.flex, flexDirection: r.layoutMode === "HORIZONTAL" ? "row" : "column", alignSelf: "stretch", alignItems: P0(r.counterAxisAlignItems), order: i }), l = co(); return (0, gs.jsx)(Gt, { outerStyles: s, children: (0, gs.jsx)(lo, { children: (0, gs.jsx)(l, { id: o, className: a, children: n }) }) }) } var Eg = I(W()), Cg = I(P()); var _de = I(P()); function XP(e, t, r, n, o) { return r ? t.getLayerRef({ layerRef: r, parentRef: o, Component: () => null }) : n(e) || null } function Vd(e, t) { return t in e } function bg({ renderNode: e, node: t, codeBehaviorProps: r }) { let n = Cg.useContext(da), o = Cg.useRef(null), i = r?.transformRef || o, s = r?.parentRef; if (!n.renderHooks.length) return e(t) || (0, Eg.jsx)(Eg.Fragment, {}); let a = t; for (let l of n.renderHooks) if (Vd(l, "renderText")) a = { ...a, renderTextHook: l }; else if (Vd(l, "renderTextCharacter")) a = { ...a, renderTextCharacterHook: l }; else if (Vd(l, "renderTextLine")) a = { ...a, renderTextLineHook: l }; else if (Vd(l, "renderTextWord")) a = { ...a, renderTextWordHook: l }; else if (Vd(l, "getLayerRef")) XP(a, l, i, e, s); else throw new te("Render hook not supported."); return e(a) || null } var or = I(W()), Ae = I(P()); function wg(e, t) { let r = (0, Ae.useRef)(null); (0, Ae.useLayoutEffect)(() => { if (!e || !e.current) return; let n = new ResizeObserver(o => { for (let i of o) if (e.current === i.target) { let s = i.contentRect.width, a = i.contentRect.height; if (r && r.current && r.current.width === s && r.current.height === a) continue; let c = { width: i.contentRect.width, height: i.contentRect.height }; r.current = c, t && t(c) } }); return n.observe(e.current), () => n.disconnect() }, [e, t]) } function mT({ outerStyles: e, childWrapperStyles: t, innerState: r }) { let o = M({ ...e, ...{ display: "flex", alignItems: "center", justifyContent: "center" } }); return { inner: M({ flex: "0 0 auto", ...t, ...r }), outer: o } } var Ig = Ae.default.forwardRef(function (t, r) { let n = $t() ?? { height: "100%", width: "100%" }; return (0, or.jsx)(Ac, { children: (0, or.jsx)(dn, { fallback: (0, or.jsx)(FH, { outerStyles: n, ...t }), children: () => t.canAnimate ? (0, or.jsx)(VH, { ref: r, outerStyles: n, ...t }) : (0, or.jsx)(BH, { ref: r, outerStyles: n, ...t }) }) }) }), BH = Ae.default.forwardRef(function ({ node: t, parent: r, context: n, children: o, outerStyles: i, childWrapperStyles: s, transitionData: a, smartAnimateType: l, transformRef: c, onOuterWrapperSizeChange: u }, d) { let f = de(t, "transform-wrapper-outer"), p = de(t, "transform-wrapper-inner"), y = (0, Ae.useRef)(null), g = c || y, S = ln(d, g), h = (0, Ae.useRef)(null), m = (0, Ae.useMemo)(() => _r(Zr(n?.group?.relativeTransform, t.relativeTransform)), [n?.group?.relativeTransform, t.relativeTransform]), v = (0, Ae.useMemo)(() => rn(t, r), [t, r]), { disableConstraintsBasedSizing: x } = Ee(), C = (0, Ae.useCallback)(O => { let D = O.width, b = O.height; if (!x && rn(t, r)) { let { width: H, height: B, transform: z } = Mh(D, b, m, t.size, t.absoluteBoundingBox); me(h.current !== null, "TransformWrapperStatic innerRef not set when setting outer size"), h.current.style.setProperty("width", `${H}px`), h.current.style.setProperty("height", `${B}px`), h.current.style.setProperty("transform", z) } else h.current?.style.removeProperty("width"), h.current?.style.removeProperty("height"), h.current?.style.removeProperty("transform") }, [t, m, r, x]), T = (0, Ae.useCallback)(O => { if (me(g.current !== null, "TransformWrapperStatic outerRef not set when setting inner size"), v || !Ec(m)) return; let D = parseFloat(g.current.style.getPropertyValue(as)), b = parseFloat(g.current.style.getPropertyValue(ls)); rt(D, O.width, 1e-4) || (g.current.style.setProperty(as, `${O.width}`), u?.(O.height, O.width)), rt(b, O.height, 1e-4) || (g.current.style.setProperty(ls, `${O.height}`), u?.(O.height, O.width)) }, [g, v, m, u]); wg(g, C), wg(h, T), (0, Ae.useLayoutEffect)(() => { g.current && C({ width: g.current.clientWidth, height: g.current.clientHeight }), h.current && T({ width: h.current.clientWidth, height: h.current.clientHeight }) }, []), (0, Ae.useLayoutEffect)(() => { if (g.current) { let O = g.current.getBoundingClientRect(), D = O.width, b = O.height; C({ width: D, height: b }) } }, [t.id]); let { inner: E, outer: w } = mT({ outerStyles: i, childWrapperStyles: s }), k = kt(a), { motionTransitionProps: R } = FI(l ?? K.NONE, a, k), A = Mo(l ?? K.NONE, a, i.transform), N = co(); return (0, or.jsx)(lo, { children: (0, or.jsx)(kc, { tag: N, needsMotion: !!l && l !== K.NONE, motionProps: { ...R, ...A }, id: f, ref: S, className: w, children: (0, or.jsx)("div", { id: p, ref: h, className: E, children: o }) }) }) }), VH = Ae.default.forwardRef(function ({ node: t, parent: r, context: n, children: o, outerStyles: i, childWrapperStyles: s, transitionData: a, previousRotation: l, transformRef: c, onOuterWrapperSizeChange: u }, d) { let f = de(t, "transform-wrapper-outer"), p = de(t, "transform-wrapper-inner"), y = (0, Ae.useRef)(null), g = c || y, S = ln(d, g), h = (0, Ae.useRef)(null), m = (0, Ae.useRef)(!1), v = (0, Ae.useRef)(!1), x = m.current && v.current, [C, T] = (0, Ae.useState)(void 0), [E, w] = (0, Ae.useState)(void 0), k = rn(t, r), R = (0, Ae.useCallback)(Y => { let $ = Y.width, oe = Y.height; if (m.current = !0, k) { let ve = _r(Zr(n?.group?.relativeTransform, t.relativeTransform)), { width: ie, height: Se, transform: Yt } = Mh($, oe, ve, t.size, t.absoluteBoundingBox, !0, l); me(h.current !== null, "TransformWrapperAnimate innerRef not set when setting outer size"), T({ width: ie, height: Se, transform: Yt }) } else T(void 0) }, [t, n?.group?.relativeTransform, k, l]), A = (0, Ae.useCallback)(Y => { v.current = !0, (!E || !rt(E.width, Y.width, 1e-4) || !rt(E.height, Y.height, 1e-4)) && (w({ width: Y.width, height: Y.height }), u?.(Y.height, Y.width)) }, [E, u]); wg(g, R), wg(h, A), (0, Ae.useLayoutEffect)(() => { if (g.current) { let Y = g.current.getBoundingClientRect(), $ = Y.width, oe = Y.height; E && !(rt($, E?.width ?? 0, 1e-4) && rt(oe, E?.height ?? 0, 1e-4)) && R({ width: $, height: oe }) } }, [t.id]); let { transform: N, ...O } = s, D = C ? { width: C.width, height: C.height } : void 0; if (!C?.transform && !N) { let Y = N0(l.current, 0); l.current = l.current + Y } let b = `rotate(${l.current}deg) skewX(0deg) skewY(0deg) scaleX(1) scaleY(1)`, H = ""; k ? H = C?.transform ?? N ?? b : H = N ?? C?.transform ?? b; let { inner: B, outer: z } = mT({ outerStyles: i, childWrapperStyles: O, innerState: D }), Q = { [as]: E?.width ?? 0, [ls]: E?.height ?? 0 }, se = kt(a), { motionTransitionProps: he } = VI(Q, x, a, x ? se : void 0), xe = Mo(K.INSTANCE_SUBTREE, a, i.transform), Oe = OO(); return (0, or.jsx)(lo, { children: (0, or.jsx)(Oe, { id: f, ref: S, className: z, ...he, ...xe, children: (0, or.jsx)(tn.div, { id: p, layout: !0, layoutDependency: a?.id ?? ZS, className: B, ref: h, transition: a ? { duration: a.durationSeconds, ...a.motionAnimationData } : { duration: 0 }, initial: { transform: H }, animate: { transform: H }, onAnimationComplete: x ? se : void 0, onLayoutAnimationComplete: x ? se : void 0, transformTemplate: (Y, $) => Y && Y.transform ? `${$} ${Y.transform}` : $, children: o }) }) }) }); function FH({ children: e, outerStyles: t, childWrapperStyles: r }) { let { inner: n, outer: o } = mT({ outerStyles: t, childWrapperStyles: r }), i = co(); return (0, or.jsx)(lo, { children: (0, or.jsx)(i, { className: o, children: (0, or.jsx)("div", { className: n, children: e }) }) }) } function hn(e) { let { node: t, parent: r, context: n, children: o, transitionProps: i, styles: s, layerRef: a, outerRef: l, previousRotation: c, codeBehaviorProps: u } = e; return HH({ node: t, parent: r, context: n, transitionProps: i }) ? (0, mn.jsx)(zH, { node: t, parent: r, context: n, layerRef: a, outerRef: l, previousRotation: c, transitionProps: i, codeBehaviorProps: u, styles: s, children: o }) : (0, mn.jsx)(xd, { node: t, stickyWrapperStyles: s.stickyWrapper, children: (0, mn.jsx)(pT, { node: t, parent: r, children: o }) }) } function zH(e) { let { children: t, context: r, node: n, layerRef: o, codeBehaviorProps: i, outerRef: s, parent: a, previousRotation: l, styles: { transform: c, stickyWrapper: u }, transitionProps: d } = e, { codeBehaviorWrapperRef: f, updateStyles: p } = xg(), y = YP({ node: n, parent: a, context: r, transitionProps: d }), g = Md(n), S = d?.transitionData, h = d?.smartAnimateType ?? K.NONE, m = h === K.INSTANCE_SUBTREE, v = n.type !== "WIDGET" && Bo(h, n.maybeAnimateRotation), x = hT.default.useMemo(() => y ? (0, mn.jsx)(Ig, { ref: v || m ? o : null, context: r, node: n, parent: a, childWrapperStyles: { ...c }, transitionData: S, canAnimate: v, smartAnimateType: h, previousRotation: l, transformRef: s, onOuterWrapperSizeChange: p, children: t }) : (0, mn.jsx)(mn.Fragment, { children: t }), [v, m, r, n, a, c, S, h, l, o, s, p, t, y]), C = hT.default.useMemo(() => () => x, [x]); if (g) { let T = n.behaviors.code; return (0, mn.jsx)(_d, { codeBehaviors: T, variableState: n.variableState, modeContext: n.modeContext, ref: f, assets: n.assets, children: (0, mn.jsx)(bg, { node: n, renderNode: C, codeBehaviorProps: { ...i, transformRef: s } }) }) } return (0, mn.jsx)(xd, { node: n, stickyWrapperStyles: u, children: (0, mn.jsx)(pT, { node: n, parent: a, children: x }) }) } function HH(e) { return YP(e) || Md(e.node) } function YP(e) { let { context: t, node: r, parent: n, transitionProps: o } = e, i = aa(r, n, t); if (r.type === "GROUP") return i && jt(r, n); { let s = r.type !== "WIDGET" && Bo(o?.smartAnimateType ?? K.NONE, r.maybeAnimateRotation); return aa(r, n, t) || s } } var gT = "data-width", yT = "data-height", vT = (0, Xt.forwardRef)(function ({ node: t, parent: r, children: n, context: o, zIndex: i, interactionHandlers: s, transitionProps: a, codeBehaviorProps: l }, c) { let u = ue(), d = Ee(), { useFigmaClipContentsForOverflow: f, minimizeAutoLayoutWrappers: p, disableBackgroundDivs: y, rootNodeStyle: g, shouldOutputVariables: S, codeSyntaxLanguage: h, dontUseChildDivForBorderStyles: m } = d, v = a?.smartAnimateType ?? K.NONE, x = AO(t, r, n), C = Bo(v, t.maybeAnimateRotation), T = wl(), E = vr({ node: t, parent: r, context: o, zIndex: i, children: n, itemSpacing: x, codeSyntaxLanguage: h, options: { canAnimate: C, previousRotation: T, shouldOutputVariables: S } }), w = zr().scalingMode === "SCALE", k = an({ node: t, context: o }), R = Nt(o, t), A = Fp(t.fills, t.assets, { width: t.size.x, height: t.size.y }, d, { isDecorativeImage: t.isDecorativeImage ?? !1 }), N = a?.transitionData, O = kt(N), D = t.interactions ?? [], b = Dc(t.name, l), H = go(D, b), B = Hn(D), z = yr(t), Q = Wp(ml()), se = A.some(gt => gt.imageProps), he = A.some(gt => gt.videoProps), xe = uo(t, se || he), Oe = Xt.default.useMemo(() => ({ opacity: R, transform: Jr(E.outer.transform) }), [R, E.outer.transform]), Y = nn(t, o), { motionProps: $, key: oe, ref: ve } = sn(t.id, t.behaviors, t.assets, Oe, Y), ie = (0, Xt.useRef)(null), Se = ln(ve, ie), Yt = ln(c, Se), li = { ...xr(R, S, t.boundVariables?.opacity?.resolvedName, h && t.boundVariables?.opacity?.resolvedCodeSyntax?.[h]), ...zi(t, b) }, yn = t.scrollBehavior === "FIXED" || t.scrollBehavior === "STICKY_SCROLLS", Er = v === K.INSTANCE_SUBTREE, vo = o?.withinInteractiveElement || Object.keys($).length > 0 || Er || !!b?.onClick, vn = ds(t, B, H, vo, Q && z), sr = gn(D, s, vo, u, b), Cr = ng(vn), Sn = Cr !== null, Lt = Xt.default.useMemo(() => n?.every(gt => gt.layoutAlign === "STRETCH") ?? !0, [n]), Ie = Xt.default.useMemo(() => ({ group: void 0, isInStickyOrFixedTree: yn || (o?.isInStickyOrFixedTree ?? !1), negativeItemSpacing: x && x < 0 ? x : void 0, withinInteractiveElement: o?.withinInteractiveElement || B || H, parentIsList: Sn, allChildrenAreFillWidth: Lt }), [o?.isInStickyOrFixedTree, o?.withinInteractiveElement, B, H, yn, x, Sn, Lt]), Ra = de(t), ci = cn(t), ui = Xt.default.useContext(zn), br = Xt.default.useMemo(() => { let gt = { "data-name": ci }; return ui && (gt[Zo] = t.name), o?.dataAttributes && Object.entries(o.dataAttributes).forEach(([L_, __]) => { gt[L_] = __ }), gt }, [ci, o?.dataAttributes, ui, t.name]), xn = Fi(t), Tn = "clipsContent" in t && t.clipsContent, So = eR(t, r), bs = Er, { clipperStyles: di, containerStyles: En, borderStyles: Cn, sharedBackgroundStyles: Qg } = _O(t, r, li, bs, S, h), fE = Sr({ node: t, parent: r, children: n }), w_ = DO({ node: t, parent: r, context: o }), ka = Xt.default.useMemo(() => n?.length ? bc(t, r, o) : {}, [n, t, r, o]); r || (f ? ka = { overflow: Tn && (En.borderRadius || En.borderTopLeftRadius || En.borderTopRightRadius || En.borderBottomLeftRadius || En.borderBottomRightRadius) ? "clip" : void 0 } : g === "independent" ? ka = { overflow: Tn ? "clip" : void 0 } : o?.renderedByCode || ee.state?.withBaseStyles && (br["data-page-overflowx"] = ka.overflowX, ka = { overflow: "clip" })); let Zg = Wt(t), pE = Zg && gP(t, r, p), mE = Xt.default.useMemo(() => ({ minWidth: typeof t.minWidth == "number", minHeight: typeof t.minHeight == "number", maxWidth: typeof t.maxWidth == "number", maxHeight: typeof t.maxHeight == "number" }), [t.minWidth, t.minHeight, t.maxWidth, t.maxHeight]), hE = Xt.default.useMemo(() => ({ hasChildNodes: !!n?.length, parentHasStrokes: xn, parentClipsContent: Tn, parentIsAutoLayout: Zg, parentHasAutoLayoutPadding: pE, parentSizeConstraints: mE, parentIncludesStrokesInLayout: r?.strokesIncludedInLayout ?? !1, canSmartAnimate: Er, isResponsiveScalingEnabled: w, hasMarquee: z }), [n?.length, xn, Tn, Zg, pE, r, Er, w, mE, z]), zc = ug(hE), gE = Xt.default.useMemo(() => !m && Cn ? (0, Tr.jsx)(fP, { node: t, smartAnimateType: v, nodeHasStrokes: xn, transitionData: N, borderStyles: Cn }) : null, [m, Cn, t, v, xn, N]), I_ = Xt.default.useMemo(() => (0, Tr.jsx)(lP, { node: t, parent: r, sharedBackgroundStyles: { ...Qg, ...So }, backgroundInfo: A, smartAnimateType: v, transitionData: N }), [t, r, Qg, So, A, v, N]), R_ = t.effects && t.effects.some(gt => gt.type === "BACKGROUND_BLUR") && t.effects.some(gt => gt.type === "LAYER_BLUR"), Jg = A.length > 1 || A.some(gt => gt.needsBackgroundDiv) || !y && (Er || R_ || xn || Q0(t)); Jg || (E.outer.mixBlendMode ||= A[0]?.backgroundStyles?.mixBlendMode); let { mixBlendMode: JW, ...k_ } = A[0]?.backgroundStyles ?? {}, yE = {}; m && Cn && (yE = Object.fromEntries(Object.entries({ ...Cn }).filter(gt => rR.includes(gt[0])))); let ey = { ...yE, ...En, ...zc ? {} : E.inner, ...E.stickyWrapper ? qh : {}, ...zc ? {} : di, ...zc ? {} : ka, ...!Jg && ee.state?.withBaseStyles ? { ...Qg, ...k_ } : {}, ...k, ...o?.style || {} }; sr.onClick && E.stickyWrapper && ey.display === void 0 && (ey.display = "block"); let A_ = t.type === "FRAME" && t.isBreakpointFrame, N_ = (0, Xt.useRef)(null), vE = (0, Tr.jsx)(vP, { ...hE, parent: t, listTag: zc && Sn ? Cr : void 0, styles: { clipperStyles: di, innerStyles: E.inner, overflowStyles: ka, borderDisplacement: So, wrapperSizeStyles: fE, marqueeSizeStyles: w_ }, children: (0, Tr.jsx)(pP, { parent: t, childNodes: n, context: Ie, reverseZIndex: t.type !== "RECTANGLE" && "itemReverseZIndex" in t && t.itemReverseZIndex, parentRef: ie, parentTransitionProps: t.transitionProps, onTransitionEnd: O }) }), O_ = _c(), P_ = Ap(); return A_ && (br[qp] = qo(t.id), br[ux] = "true", br[gT] = t.size.x, br[yT] = t.size.y, P_) ? (0, Tr.jsx)(Tr.Fragment, { children: vE }) : (0, Tr.jsx)(Gt, { outerStyles: E.outer, children: (0, Tr.jsxs)(hn, { node: t, parent: r, context: o, transitionProps: a, codeBehaviorProps: l, layerRef: c, outerRef: N_, previousRotation: T, styles: { transform: E.transform, stickyWrapper: E.stickyWrapper }, children: [(0, Tr.jsx)(KP, { node: t }), (0, Tr.jsxs)(ho, { semanticTagInfo: { semanticTag: zc && Sn ? "div" : vn.semanticTag, interactiveSemanticTag: z && vn.interactiveSemanticTag === "ul" ? null : vn.interactiveSemanticTag }, wrapperSizeStyles: fE, context: o, styles: ey, ref: C ? Se : Yt, id: Ra, ...sr, ...br, ...xe, nodeName: t.name, needsMotionForCodeBehavior: O_, codeBehaviorProps: l, transitionProps: { opacity: R, smartAnimateType: v, behaviorProps: $, transitionData: N, onTransitionEnd: O }, children: [Jg && I_, Tn ? null : gE, vE, (0, Tr.jsx)(SP, { node: t, parent: r, alwaysRenderBorderStyles: bs }), Tn ? gE : null] }, oe)] }) }) }), ST = Lc(vT); var Fd = "responsive-scaler", Jo = "--viewport-scale", xT = "--viewport-width", TT = "--viewport-height", ET = "--layout-width", CT = "--layout-height", bT = "--content-width-unscaled", qP = "data-min-layout-width", QP = "data-max-layout-width", Rg = { scalingMode: "REFLOW", scalingMinLayoutWidth: 320, scalingMaxLayoutWidth: 2048, scalingMinFontSize: 6, scalingMaxFontSize: 288 }, ZP = ei.default.createContext({ ...Rg, scale: ft(1), viewportWidth: ft("0"), viewportHeight: ft("0"), layoutWidth: ft("0"), layoutHeight: ft("0"), contentWidth: ft("0") }); function zr() { return ei.default.useContext(ZP) } function JP({ children: e, materializedChildren: t }) { let r = ue(), n = ei.default.useRef(!0), o = Di(), { scalingMode: i, scalingMinLayoutWidth: s, scalingMaxLayoutWidth: a, scalingMinFontSize: l, scalingMaxFontSize: c } = Rg; i = o?.scalingMode ?? i, s = o?.scalingMinLayoutWidth ?? s, a = o?.scalingMaxLayoutWidth ?? a, l = o?.scalingMinFontSize ?? l, c = o?.scalingMaxFontSize ?? c; let u = 1, d = "0", f = "0", p = "0", y = "0", g = "0"; if (r === "published" && n.current) { n.current = !1; let k = document.querySelector(`#${Fd}`); if (k) { let R = k.computedStyleMap(); u = parseFloat(R.get(Jo)?.toString() ?? "1"), d = R.get(xT)?.toString() ?? "0", f = R.get(TT)?.toString() ?? "0", p = R.get(ET)?.toString() ?? "0", y = R.get(CT)?.toString() ?? "0", g = R.get(bT)?.toString() ?? "0" } } let S = ns(u), h = ns(d), m = ns(f), v = ns(p), x = ns(y), C = ns(g), T = gp(), E = (0, ei.useMemo)(() => q(k => { let R = k(fl); if (!R.width || !R.height) return {}; let A = t[0]; if (!A || A.type !== "FRAME" || A.type === "FRAME" && !A.isBreakpointFrame) return {}; let N = R.width, O = R.height, D = A.size.x, b = A.size.y; if (i === "REFLOW") return { viewportWidth: N, viewportHeight: O, layoutWidth: D, layoutHeight: b, contentWidth: D, scale: 1 }; let H = Math.max(Math.min(N, a), s); return { scale: H / D, viewportWidth: N, viewportHeight: O, layoutWidth: D, layoutHeight: b, contentWidth: H } }), [t, a, s, i]); (0, ei.useEffect)(() => { function k() { let R = T.get(E); R.scale && S.set(R.scale), R.viewportWidth && h.set(R.viewportWidth + "px"), R.viewportHeight && m.set(R.viewportHeight + "px"), R.layoutWidth && v.set(R.layoutWidth + "px"), R.layoutHeight && x.set(R.layoutHeight + "px"), R.contentWidth && C.set(R.contentWidth + "px") } return k(), T.sub(E, () => { k() }) }, [T, E, h, m, v, x, S, C]); let w = (0, ei.useMemo)(() => ({ scalingMode: i, scalingMinLayoutWidth: s, scalingMaxLayoutWidth: a, scalingMinFontSize: l, scalingMaxFontSize: c, viewportWidth: h, viewportHeight: m, layoutWidth: v, layoutHeight: x, contentWidth: C, scale: S }), [C, x, v, S, c, a, l, s, i, m, h]); return (0, Mc.jsx)(ZP.Provider, { value: w, children: e }) } function eL({ children: e }) { let { scalingMode: t, scalingMinLayoutWidth: r, scalingMaxLayoutWidth: n, scalingMinFontSize: o, scalingMaxFontSize: i, viewportWidth: s, viewportHeight: a, contentWidth: l, scale: c, layoutWidth: u, layoutHeight: d } = zr(); WH(t); let f = M({ width: "var(--viewport-width-scaled)", minHeight: "var(--viewport-height-scaled)", height: "100%", display: "block", position: "absolute", top: "0px", transformOrigin: "top left", "--max-layout-width": n + "px", "--min-layout-width": r + "px", "--max-font-size": i + "px", "--min-font-size": o + "px", "--viewport-width-scaled": `calc(var(--100dvw) / var(${Jo}))`, "--viewport-height-scaled": `calc(var(--100dvh) / var(${Jo}))`, "--content-width-scaled": `calc(var(--content-width-unscaled) / var(${Jo}))`, "--content-margin-x-scaled": `max(calc((var(--viewport-width) - var(--max-layout-width)) / var(${Jo}) / 2), 0px)` }), p = { [xT]: s, [TT]: a, [ET]: u, [CT]: d, [Jo]: c, [bT]: l, scale: c }; if (t === "REFLOW") return (0, Mc.jsx)(Mc.Fragment, { children: e }); let y = { [qP]: r, [QP]: n }; return (0, Mc.jsx)(tn.div, { suppressHydrationWarning: !0, ...y, id: Fd, className: f, style: p, children: e }) } function WH(e) {
  let t = ue(), r = tI(); t === "server" && e === "SCALE" && r({
    elId: "scaler-script", script: `
      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;
      const scalerEl = document.querySelector('#${Fd}');
      let breakpointEl = null;
      const breakpointEls = scalerEl?.childNodes || [];

      breakpointEls.forEach((el) => {
        const style = window.getComputedStyle(el)
        if (style.display !== 'none') {
          breakpointEl = el;
          return false;
        }
      });

      if (scalerEl && breakpointEl) {
        const minWidth = parseInt(scalerEl.getAttribute('${qP}') || '${Rg.scalingMinLayoutWidth}');
        const maxWidth = parseInt(scalerEl.getAttribute('${QP}') || '${Rg.scalingMaxLayoutWidth}');
        const width = parseInt(breakpointEl.getAttribute('${gT}') || '0');
        const height = parseInt(breakpointEl.getAttribute('${yT}') || '0');
        const contentWidth = Math.max(Math.min(windowWidth, maxWidth), minWidth)
        const scale = parseFloat((contentWidth / width).toFixed(5));
        scalerEl.style.transform = 'scale(' + scale + ')';
        scalerEl.style.setProperty('${Jo}', scale);
        scalerEl.style.setProperty('${xT}', windowWidth + 'px');
        scalerEl.style.setProperty('${TT}', windowHeight + 'px');
        scalerEl.style.setProperty('${ET}', width + 'px');
        scalerEl.style.setProperty('${CT}', height + 'px');
        scalerEl.style.setProperty('${bT}', contentWidth);
      }
    `})
} var ti, jH = (ti = class { activeHoverRects = new Map; hoverRectCounter = 0; constructor() { } static getInstance() { } showHoverTargetRectangle(t, r) { let n = `hover-debug-rect-${this.hoverRectCounter++}`, o = document.createElement("div"); o.style.position = "fixed", o.style.left = `${t.left}px`, o.style.top = `${t.top}px`, o.style.width = `${t.width}px`, o.style.height = `${t.height}px`, o.style.border = `2px solid ${r || "red"}`, o.style.pointerEvents = "none", o.style.zIndex = "9999", o.style.opacity = "0.5", o.style.transition = "opacity 200ms ease-out", document.body.appendChild(o); let i = window.setTimeout(() => { o.style.opacity = "0", window.setTimeout(() => { document.body.removeChild(o), this.activeHoverRects.delete(n) }, 200) }, 200); return this.activeHoverRects.set(n, { id: n, element: o, timeoutId: i }), n } }, Ir(ti, "instance"), ti), kg = () => jH.getInstance(); var wT; function Ng() { return wT || (wT = new Map), wT } function UH(e) { let t = Ng(), r = t.get(e) || { reverseStateInfo: [] }; r.reverseStateInfo.push([]), t.set(e, r) } function GH(e) { let r = Ng().get(e.target); let n = r.reverseStateInfo[r.reverseStateInfo.length - 1]; n.push(e) } function $H(e) { let t = Ng(), r = t.get(e.target); let n = r.reverseStateInfo[r.reverseStateInfo.length - 1]; let o = n.pop(); n.length === 0 && (r.reverseStateInfo.pop(), r.reverseStateInfo.length === 0 && t.delete(e.target)) } function KH(e, t, r, n) { let { variableState: o } = n, i = n.backingComponentIdState, s = [], a = l => { if (l.connectionType === "CONDITIONAL") { if (l.conditionalActions) for (let c of l.conditionalActions) { let u = c.condition ? Ol(c.condition) : void 0; if (u === null) break; if (u === void 0 || Bn({ get: e, variableState: o, modeContext: {} }, u)) { c.actions && Cp(c.actions).forEach(a); break } } return } if (l.connectionType === "INTERNAL_NODE" && l.navigationType === "SWAP_STATE") { l.transitionNodeID; let c = AT(l, n); let u = i.get(e, n.modeContext), d = u; u || n.node.type === "INSTANCE" && (d = n.node.mainComponentId); let { sessionID: f, localID: p } = l.transitionNodeID, y = `${f}:${p}`; (t.event?.interactionType === "ON_HOVER" || t.event?.interactionType === "ON_PRESS") && s.push({ oldBackingComponentId: d, newBackingComponentId: y, oldBackingComponentIdStateContents: u, target: c, interactionId: Je(t.id), triggerType: t.event.interactionType, action: l, modeContext: n.modeContext, get: e }) } }; return r.forEach(a), s } var Ag = class { executedReversibleInteractions; hoverInteractionCalc; constructor(t, r, n, o, i) { if (this.executedReversibleInteractions = KH(t, r, n, o), this.executedReversibleInteractions.length > 0) if (r.event?.interactionType === "ON_HOVER") { let s = i.currentTarget.offsetParent; this.hoverInteractionCalc = { origin: i.currentTarget, originSize: i.currentTarget.getBoundingClientRect(), parentDeltaStack: [{ target: i.currentTarget, delta: { x: 0, y: 0 } }] }; let a = this.hoverInteractionCalc.parentDeltaStack; for (; s !== null && s instanceof HTMLElement;) { let l = a[a.length - 1]; if (a.push({ target: s, delta: { x: l.delta.x + l.target.offsetLeft, y: l.delta.y + l.target.offsetTop } }), s.id !== Fd) s = s.offsetParent; else { let c = parseFloat(window.getComputedStyle(s).getPropertyValue(Jo) || "1"); for (let u of a) u.delta = { x: u.delta.x * c, y: u.delta.y * c }; s = null } } this.hoverInteractionCalc.parentDeltaStack.shift() } else r.event?.interactionType } completeTracking(t, r) { if (!this.executedReversibleInteractions) return; let n = new Map; for (let o of this.executedReversibleInteractions) n.has(o.target) || n.set(o.target, []), n.get(o.target)?.push(o); for (let o of n.keys()) { UH(o); let i = n.get(o); for (let s of i) { let a = () => { let l = s.target, c = l?.get(t, r.modeContext); l && c === s.newBackingComponentId && (kT(t, r, s.action, s.newBackingComponentId, s.oldBackingComponentId), s.oldBackingComponentIdStateContents ? l.set(t, r.modeContext, s.oldBackingComponentIdStateContents) : l.reset()), $H(s) }; s.triggerType === "ON_HOVER" ? (this.hoverInteractionCalc, s.undoInfo = { type: "ON_HOVER", ...this.hoverInteractionCalc, undo: a }) : s.triggerType === "ON_PRESS" && (s.undoInfo = { type: "ON_PRESS", undo: a }), GH(s) } } } }, IT = new Map; function RT() { return IT || (IT = new Map), IT } function tL(e, t) { let r = RT(); r.has(e) || r.set(e, []); let n = r.get(e); n.push(t) } function rL(e, t) { let n = RT().get(e); let o = n.indexOf(t); o !== -1 && n.splice(o, 1) } function Bc(e) { let r = RT().get(e.nativeEvent.type) || []; for (let n of r) n(e.nativeEvent) } function oL() { (0, nL.useEffect)(() => { let e = t => { Ng().forEach(n => { let o = () => { if (n.reverseStateInfo.length === 0) return; let i = n.reverseStateInfo[n.reverseStateInfo.length - 1]; if (i.length === 0) return; let s = i[i.length - 1].undoInfo; if (s.type === "ON_HOVER") { let a; for (let l = s.parentDeltaStack.length - 1; l >= 0; l--) { let c = s.parentDeltaStack[l].target; if (!document.contains(c)) break; if (window.getComputedStyle(c).overflow !== "visible") { let f = c.getBoundingClientRect(); if (t.clientX <= f.left || t.clientX >= f.right || t.clientY <= f.top || t.clientY >= f.bottom) { kg()?.showHoverTargetRectangle(f, "red"), a = !1; break } } } if (a === void 0) for (let { target: l, delta: c } of s.parentDeltaStack) { if (!document.contains(l)) continue; let u = l.getBoundingClientRect(), d = [u.left + c.x, u.top + c.y], f = [u.left + c.x + s.originSize.width, u.top + c.y + s.originSize.height], p = new DOMRect(d[0], d[1], s.originSize.width, s.originSize.height); kg()?.showHoverTargetRectangle(p, "blue"), t.clientX > d[0] && t.clientX < f[0] && t.clientY > d[1] && t.clientY < f[1] ? a = !0 : (kg()?.showHoverTargetRectangle(u, "green"), a = !1); break } a === !1 && (s.undo(), o()); return } else if (s.type === "ON_PRESS") { t.buttons === 0 && (s.undo(), o()); return } }; o() }) }; return window.addEventListener("mousemove", e), tL("mousemove", e), window.addEventListener("mouseup", e), tL("mouseup", e), () => { window.removeEventListener("mousemove", e), rL("mousemove", e), window.removeEventListener("mouseup", e), rL("mouseup", e) } }, []) } var XH = .8; function zd(e, t, r) { t === void 0 && (t = !0); let n = r === "preview" || t ? "_blank" : "_self"; try { return new URL(e), { url: e, target: n } } catch { return { url: "https://" + e, target: n } } } function YH(e, t) { if (!e.startsWith("/")) return e; if (t === "published") return window.location.host + e } function qH(e, t) { return e?.filter(r => r.event?.interactionType === t)?.map(r => r.id)?.filter(r => r != null)?.map(r => Je(r)) ?? [] } function Og(e, t, r, n) { let { variableState: o } = n; for (let i of r) switch (i.connectionType) { case "INTERNAL_NODE": t3(e, n, i); break; case "URL": if (i.connectionURL) { let s = YH(i.connectionURL, ee.state.env); if (!s) ee.state.setLocation({ url: i.connectionURL }); else { let { url: a, target: l } = zd(s, i.openUrlInNewTab, ee.state.env); window.open(a, l)?.focus() } } break; case "SET_VARIABLE": if (i.targetVariable && i.targetVariable.id && i.targetVariableData) { let s = Ol(i.targetVariableData), a = s !== null ? Bn({ get: e, variableState: o, modeContext: n.modeContext }, s) : null; a !== null ? o.setVariable(i.targetVariable.id, a, n.modeContext) : console.warn("Error evaluating variable data", i.targetVariableData) } break; case "CONDITIONAL": if (i.conditionalActions) for (let s of i.conditionalActions) { let a = s.condition ? Ol(s.condition) : void 0; if (a === null) break; if (a === void 0 || Bn({ get: e, variableState: o, modeContext: n.modeContext }, a)) { if (s.actions) { let l = Cp(s.actions); Og(e, t, l, n) } break } } break; case "BACK": ee.state.history.back(); break; default: console.warn("unknown action type", i) } } function QH(e, t) { return r => { let n = Xu(); if (n?.onAnimationComplete) { n.onAnimationComplete(); return } let o = t.transitionAtom; e(o)?.id === r && (iL(r), J().set(o, void 0)); let i = t.autoLayoutTransitionAtom; i && e(i)?.id === r && J().set(i, void 0) } } var ZH = 0; function JH(e, t, r) { if (e?.transitionType === "SMART_ANIMATE") return { id: ZH++, durationSeconds: e.transitionDuration ?? NI, onTransitionEnd: QH(t, r), motionAnimationData: OI(e) } } function e3(e, t) { e.type === "COMPONENT" && t.type; let r = e.size, n = t.size; return r.x !== n.x || r.y !== n.y } function kT(e, t, r, n, o) { let i = e(t.nodeById.get(n)), s = e(t.nodeById.get(o)), a = e3(i, s), l = i3(r, t, a), c = JH(r, e, l); J().set(l.transitionAtom, c), l.autoLayoutTransitionAtom && J().set(l.autoLayoutTransitionAtom, c ? { ...c, layout: !0 } : void 0) } async function t3(e, t, r) { switch (r.navigationType) { case "NAVIGATE": NT(r.connectionURL, r.transitionType, r.transitionDuration); break; case "SWAP_STATE": { r.transitionNodeID; let n = t.node.id; kR(n, e, t.nodeById); let o = hx(e, t), i = qH(o, "AFTER_TIMEOUT"), s = AT(r, t); let a = o3(e, s, t); let { sessionID: l, localID: c } = r.transitionNodeID, u = `${l}:${c}`, d = e(t.nodeById.get(u)); if (!d || d.id === LS.id) break; if (Tl().stateSwapNodeToMonitor === t.node.id && (Rp(t.node.id), await Bi("timerEvent", { timerName: "swap-state", eventName: "timer_start" })), kT(e, t, r, a, u), s.set(e, t.modeContext, u), r.transitionResetInteractiveComponents) { let f = r.stateGroupContext ? t.parentStates?.get(r.stateGroupContext) : null; f && f.stateResetHandlers.forEach(p => p(e, t.modeContext)) } sL(t.node.id, i); break } case "SCROLL_TO": { r.transitionNodeID; let n = r.transitionNodeID, o = r.extraScrollOffset || { x: 0, y: 0 }, i = !!r.transitionType && r.transitionType !== "INSTANT_TRANSITION", s = PR(e); n3(t, n, o, i && !s); break } default: console.warn("unknown navigation type", r); break } } function r3(e, t) { let r = []; r.push(e); let n = t.sourceStablePath; if (n.includes("I")) { let o = n.split(";"); for (let i = 0; i < o.length; i++) { let a = `${o.slice(0, i + 1).join(";")};${e}`; r.push(a) } } return r } function n3(e, t, r, n) { if (!t) return; let { sessionID: o, localID: i } = t, s = `${o}:${i}`, a = r3(s, e); NR(a).then(l => { if (l) { let c = MR(l); if (!c) return; let u = c === Ix(), d = _R(c), f = DR(c) || u, p = l.getBoundingClientRect(), y = c.getBoundingClientRect(), g = p.top - y.top, S = p.left - y.left, h = { x: d ? c.scrollLeft + S + r.x : c.scrollLeft, y: f ? c.scrollTop + g + r.y : c.scrollTop }; (u ? window : c).scrollTo({ top: h.y, left: h.x, behavior: n ? "smooth" : "instant" }) } }) } function NT(e, t, r) { let n = t === "SMART_ANIMATE" && r ? { duration: r } : void 0; me(!!e, "No URL provided for internal navigation"); let o = ee.state.setLocation; o({ url: e, transition: n }) } function o3(e, t, r) { let n = t.get(e, r.modeContext); return n || (r.node.type === "INSTANCE" ? r.node.mainComponentId : null) } function AT(e, t) { let { backingComponentIdState: r, parentStates: n } = t, o = e.stateGroupContext; return (o ? n?.get(o) : null)?.backingComponentIdState ?? r } function i3(e, t, r) { let { transitionAtom: n, parentStates: o } = t, i = e.stateGroupContext, s = i ? o?.get(i) : null, a = { transitionAtom: s?.transitionAtom ?? n }; return r && s?.parentAutoLayoutTransitionAtom && (a.autoLayoutTransitionAtom = s.parentAutoLayoutTransitionAtom), a } function hx(e, t) { let { node: r } = t; if (!("interactions" in r) || !r.interactions) return; let n = r.interactions, o = n.filter(f => f.event?.interactionType === "ON_PRESS"); if (!o.length) return n; let i; for (let f of o) if (i = f.actions?.find(p => p.navigationType === "SWAP_STATE" && p.connectionType === "INTERNAL_NODE"), i) break; if (!i || !i.transitionNodeID) return n; n = n.filter(f => f.event?.interactionType !== "ON_CLICK"); let { sessionID: s, localID: a } = i.transitionNodeID, l = `${s}:${a}`, { nodeById: c } = t, u = e(c.get(l)); if (!("interactions" in u) || !u.interactions) return n; let d = u.interactions.find(f => f.event?.interactionType === "ON_CLICK"); return d ? [...n, d] : n } function yR(e, t, r) { let n = {}, o = [], i = []; for (let s of r) { let a = s.event?.interactionType; if (a) { if (a === "ON_KEY_DOWN") { o.push(s); continue } if (a === "AFTER_TIMEOUT") { i.push(s); continue } n[a] = s3(e, t, s) } } return o.length > 0 && (n.ON_KEY_DOWN = a3(e, t, o)), i.length > 0 && (n.AFTER_TIMEOUT = i.map(s => { let a = s.event.transitionTimeout || XH; return { callback: () => { Og(e, s, s.actions || [], t) }, delayMilliseconds: a * 1e3, interactionGuid: Je(s.id) || Hs, nodeId: t.node.id } })), n } function vR(e, t, r) { let n = e(t); return n || e(r) } function s3(e, t, r) { return { mouseCallback: n => { let o = new Ag(e, r, r.actions || [], t, n); Og(e, r, r.actions || [], t), o.completeTracking(e, t) } } } function a3(e, t, r) { return { keyCallback: n => { for (let o of r) FR(o, n) && Og(e, o, o.actions || [], t) } } } function Hn(e) { return e.some(t => t.event?.interactionType === "ON_CLICK" && t.actions?.some(r => r.connectionType === "URL" || r.connectionType === "INTERNAL_NODE" && r.navigationType === "NAVIGATE")) } function go(e, t) { return (e.some(r => r.event?.interactionType === "ON_CLICK") || !!t?.onClick) && !Hn(e) } function SR(e) { if (!(!("accessibleHTMLTag" in e) || !e.accessibleHTMLTag) && "interactions" in e && e.accessibleHTMLTag === "BUTTON" && !e.interactions.find(r => r.event?.interactionType === "ON_CLICK")) { let r = { event: { interactionType: "ON_CLICK" }, actions: [{ noop: !0 }] }; e.interactions ? e.interactions.push(r) : e.interactions = [r] } } var aL = !0; setTimeout(() => { aL = !1 }, 200); var l3 = class { persistentTimeouts = new Map; nextId = 0; getPersistentTimeouts() { return this.persistentTimeouts } registerPersistentTimeout(t, r, n, o) { let i = `${t}:${r}`, s = this.persistentTimeouts.get(i); if (s) { if (s.isMounted = !0, s.delayMilliseconds === o) return -1; clearTimeout(s.timeoutHandle), this.persistentTimeouts.delete(i) } let a = this.reserveTimeoutId(), l = Date.now(), c = setTimeout(() => { n(), this.persistentTimeouts.delete(i) }, o + (aL ? 200 : 0)); return this.persistentTimeouts.set(i, { timeoutHandle: c, startTime: l, delayMilliseconds: o, callback: n, isMounted: !0 }), a } markTimeoutsAsUnmounted(t) { for (let [r, n] of this.persistentTimeouts) r.startsWith(`${t}:`) && (n.isMounted = !1) } cleanupUnmountedTimeouts(t, r) { if (r) { let n = []; for (let o of r) { let i = `${t}:${o}`, s = this.persistentTimeouts.get(i); s && !s.isMounted && (clearTimeout(s.timeoutHandle), n.push(i)) } n.forEach(o => this.persistentTimeouts.delete(o)) } } clearTimeoutsByInteractionGuidsAndNodeId(t, r) { let n = []; for (let o of r) { let i = `${t}:${o}`, s = this.persistentTimeouts.get(i); s && (clearTimeout(s.timeoutHandle), n.push(i)) } n.length > 0 && n.forEach(o => this.persistentTimeouts.delete(o)) } reserveTimeoutId() { return this.nextId++ } }, c3 = new l3, ys = c3; var u3 = (e, t = [], r, n, o) => { let i = t.find(s => s.event?.interactionType === "ON_CLICK"); if (!i?.actions && !o?.onClick) { i && i.actions; return } for (let s of i?.actions ?? []) if (s.connectionType === "URL" || s.connectionType === "INTERNAL_NODE" && s.navigationType === "NAVIGATE") return Lg(e, s.connectionType, s.connectionURL, s.openUrlInNewTab, r, n); return (i?.actions?.length ?? 0) > 0 || o?.onClick ? d3(e, r) : void 0 }; function gn(e = [], t, r, n, o) { if (!t && !o) return {}; let i = {}, s = a => !!a && !!a.mouseCallback; if (s(t?.ON_CLICK) || o?.onClick) { let a = Ws(c => { t?.ON_CLICK?.mouseCallback?.(c), o?.onClick?.(c), c.preventDefault(), c.stopPropagation() }, "onClick"), l = u3(a, e, r, n, o); i = { onClick: a, ...i, ...l } } return (s(t?.MOUSE_ENTER) || o?.onMouseEnter) && (i.onMouseEnter = Ws(a => { t?.MOUSE_ENTER?.mouseCallback?.(a), o?.onMouseEnter?.(a), Bc(a), a.stopPropagation() }, "onMouseEnter")), (s(t?.MOUSE_LEAVE) || o?.onMouseLeave) && (i.onMouseLeave = Ws(a => { t?.MOUSE_LEAVE?.mouseCallback?.(a), o?.onMouseLeave?.(a), Bc(a), a.stopPropagation() }, "onMouseLeave")), (s(t?.MOUSE_DOWN || t?.ON_PRESS) || o?.onMouseDown) && (i.onMouseDown = Ws(a => { t?.MOUSE_DOWN?.mouseCallback?.(a), t?.ON_PRESS?.mouseCallback?.(a), o?.onMouseDown?.(a), Bc(a), a.preventDefault(), a.stopPropagation() }, "onMouseDown")), (s(t?.MOUSE_UP) || o?.onMouseUp) && (i.onMouseUp = Ws(a => { t?.MOUSE_UP?.mouseCallback?.(a), o?.onMouseUp?.(a), Bc(a), a.stopPropagation() }, "onMouseUp")), s(t?.ON_HOVER) && (i.onMouseMove = Ws(a => { t?.ON_HOVER?.mouseCallback?.(a), Bc(a), a.stopPropagation() }, "onMouseMove")), i } var Pg = {}; function lL(e, t) { let r = []; return e?.AFTER_TIMEOUT && e.AFTER_TIMEOUT.forEach(({ callback: o, delayMilliseconds: i, interactionGuid: s, nodeId: a }) => { let l = ys.reserveTimeoutId(), c = Pg[t] ?? []; c.push({ callback: o, delayMilliseconds: i, interactionGuid: s, nodeId: a }), Pg[t] = c, r.push(l) }), r } function iL(e) { let t = Pg[e]; t && t.length && (t.forEach(({ callback: r, delayMilliseconds: n, interactionGuid: o, nodeId: i }) => { ys.registerPersistentTimeout(i, o, r, n) }), delete Pg[e]) } function cL(e, t) { let r = [], n = 0; return t?.AFTER_TIMEOUT && t.AFTER_TIMEOUT.forEach(({ callback: i, delayMilliseconds: s, interactionGuid: a }) => { let l = ys.registerPersistentTimeout(e, a, i, s); l !== -1 ? r.push(l) : n++ }), { timeoutIds: r, persistentTimeoutCount: n } } function sL(e, t) { t && ys.clearTimeoutsByInteractionGuidsAndNodeId(e, t) } function Lg(e, t, r, n, o, i) { let s = a => { a.key === "Enter" && e(a) }; if ((t === "INTERNAL_NODE" || t === "NODE") && r) { let a = () => { ee.state.preloadLocation(r) }; return o || i === "preview" ? { onClick: e, onKeyDown: s, onMouseDown: a, role: "link", tabIndex: 0 } : { href: r, target: n ? "_blank" : "_self", onMouseDown: a } } if (t === "URL" && r) { let { url: a, target: l } = zd(r, n, i); return o ? { role: "link", tabIndex: 0, onClick: e, onKeyDown: s } : { href: a, target: l } } } function d3(e, t) { return t ? { role: "button", tabIndex: 0, onClick: e, onKeyDown: n => { (n.key === "Enter" || n.key === " ") && e(n) } } : {} } function uL(e, t) { let r = null; return (...n) => { r !== null && clearTimeout(r), r = setTimeout(() => { e(...n) }, t) } } var ma = I(W()), yo = I(P()), _g = I(P()); var dL = new Map, f3 = yo.forwardRef(function ({ node: t, parent: r, interactionHandlers: n, context: o, zIndex: i, transitionProps: s, codeBehaviorProps: a }, l) { let c = ue(), u = s?.smartAnimateType ?? K.NONE, d = Bo(u, t.maybeAnimateRotation), f = wl(), p = vr({ node: t, parent: r, context: o, zIndex: i, children: [], options: { isFlattened: !0, canAnimate: d, previousRotation: f } }), y = an({ node: t, context: o }), g = t?.interactions ?? [], S = t.type === "SVG" ? o?.group?.opacity ?? 1 : Nt(o, t), h = yo.useMemo(() => ({ opacity: S, transform: Jr(p.outer.transform) }), [S, p.outer.transform]), m = nn(t, o), { motionProps: v, key: x, ref: C } = sn(t.id, t.behaviors, t.assets, h, m), T = ln(l, C), E = Dc(t.name, a), w = o?.withinInteractiveElement || Object.keys(v).length > 0 || u === K.INSTANCE_SUBTREE || !!E?.onClick, k = gn(g, n, w, c, E), R = go(g, E), A = Hn(g), N = ds(t, A, R, w, !1), O = uo(t, !0), D = s?.transitionData, b = kt(D), H = Sr({ node: t, parent: r }), { shouldOutputVariables: B, codeSyntaxLanguage: z } = Ee(), Q = { ...p.inner, ...t.type === "IMAGE" ? PO(t.effects, B, z) : {}, ...xr(S, B, t.boundVariables?.opacity?.resolvedName, z && t.boundVariables?.opacity?.resolvedCodeSyntax?.[z]), ...zi(t, E), ...y, ...o?.style || {} }, se = de(t), he = cn(t), { disableDataAttributes: xe } = Ee(), Oe = (0, _g.useRef)(null), Y = (0, _g.useContext)(zn), $ = _c(); return (0, ma.jsx)(Gt, { outerStyles: p.outer, children: (0, ma.jsx)(hn, { node: t, parent: r, context: o, transitionProps: s, codeBehaviorProps: a, layerRef: l, outerRef: Oe, previousRotation: f, styles: { transform: p.transform, stickyWrapper: p.stickyWrapper }, children: (0, ma.jsx)(ho, { semanticTagInfo: N, context: o, wrapperSizeStyles: H, ref: d ? C : T, id: se, styles: Q, transitionProps: { opacity: S, smartAnimateType: u, behaviorProps: v, transitionData: D, onTransitionEnd: b }, nodeName: t.name, codeBehaviorProps: a, needsMotionForCodeBehavior: $, ...k, ...O, "data-name": he, "data-isimage": xe ? void 0 : !0, ...Y ? { [Zo]: t.name } : {}, ...o?.dataAttributes || {}, children: (0, ma.jsx)(p3, { node: t, parent: r }, t.id) }, x) }) }) }); function p3({ node: e, parent: t }) { let r = Vo(e.assets, e.hash); me(r.type === "GENERATED_ASSET", "Expected asset to be a generated asset"); let { url: n, offsets: o, size: i } = r, s = re().getAssetURL, a = s(n), l = yo.useRef(null), c = e.accessibleLabel || "", u = yo.useCallback(T => { if (l.current) { l.current.replaceChildren(T.cloneNode(!0)); let E = l.current.querySelector("svg"); E && (c ? (E.setAttribute("aria-label", c), E.setAttribute("role", "img")) : E.setAttribute("role", "presentation")) } }, [c]), d = dL.get(e.hash), f = !1; e.type === "SVG" && e.isDynamic && (f = !0); let { disableInlineSvgGeneration: p, disableImageOptimization: y, ignoreEmptyAbsoluteElements: g } = Ee(); yo.useEffect(() => { if (!f || p) return; if (d && l.current) { u(d); return } if (!a) return; let T = new AbortController, E = async () => { try { let k = await fetch(a, { signal: T.signal }); w(await k.text()) } catch (k) { if (console.error("Error loading SVG", k), k.name !== "AbortError") throw new Rt("Error loading SVG", k) } }, w = k => { if (k === "") return; if (!k) { console.warn("No SVG URL provided for", e.id); return } let R = new DOMParser().parseFromString(k, "image/svg+xml"), A = R.querySelector("svg"), N = R.querySelector("parsererror"); if (!A || N) { console.error("Unable to load SVG", N); return } dL.set(e.hash, A), u(A) }; return E(), () => { T.abort() } }, [a, e.hash, d, e.id, e.type, f, u, p]); let S = { position: "absolute", top: Fu(o.top), left: Fu(o.left), right: Fu(o.right), bottom: Fu(o.bottom) }, h = M({ width: "100%", height: "100%", display: "block", maxWidth: "none" }), m, v; if (i && !y && e.type === "IMAGE") { let { srcset: T, sizes: E } = $0(s, e, t, n, i, void 0); m = T, v = e.lazyLoad ? `auto,${E}` : E } let x = {}; f && e.type === "SVG" && (e.fills.forEach((T, E) => { T.type === "SOLID" && (x[`--fill-${E}`] = `rgba(${Math.round(T.color.r * 255)}, ${Math.round(T.color.g * 255)}, ${Math.round(T.color.b * 255)}, ${L(T.color.a)})`) }), e.strokes.forEach((T, E) => { T.type === "SOLID" && (x[`--stroke-${E}`] = `rgba(${Math.round(T.color.r * 255)}, ${Math.round(T.color.g * 255)}, ${Math.round(T.color.b * 255)}, ${L(T.color.a)})`) })); let C = g && Object.keys(x).length === 0 && Yp(S) ? Hr : "div"; return (0, ma.jsx)(C, { className: M(S), style: x, ref: l, children: (0, ma.jsx)("img", { loading: e.lazyLoad ? "lazy" : void 0, src: a, alt: c, width: e.type === "IMAGE" && i ? L(i.x) : void 0, height: e.type === "IMAGE" && i ? L(i.y) : void 0, className: h, srcSet: m, sizes: v }) }) } var fL = Lc(f3); var ne = I(W()), gL = I(P()), ri = I(P()), Dg = I(un()); var m3 = { TOP: "flex-start", BOTTOM: "flex-end", CENTER: "center" }, h3 = { NONE: "none", UNDERLINE: "underline", STRIKETHROUGH: "line-through" }, g3 = { ORIGINAL: "none", SMALL_CAPS: "none", SMALL_CAPS_FORCED: "none", UPPER: "uppercase", LOWER: "lowercase", TITLE: "capitalize" }, y3 = { ORIGINAL: "normal", SMALL_CAPS: "small-caps", SMALL_CAPS_FORCED: "all-small-caps", UPPER: "normal", LOWER: "normal", TITLE: "normal" }, v3 = { SUPER: "0.55em", SUB: "-0.25em", NORMAL: void 0 }; function ga(e, t, r, n, o, i) { let { shouldOutputVariables: s, codeSyntaxLanguage: a } = i, { fallbackFonts: l, fontFamily: c, fontVariations: u, fontSize: d, fontStyle: f, textCase: p, opentypeFlags: y, letterSpacingUnit: g, letterSpacingValue: S } = e.style, h = "fills" in e.style && e.style.fills || "fills" in e && e.fills || [], m = {}, v; if (c) { let T = `${c}:${f}`, E = S3(T, l ?? []); if (s) { let D = "boundVariables" in e ? e.boundVariables : null, b = X(a && D?.fontFamily?.[0]?.resolvedCodeSyntax?.[a], D?.fontFamily?.[0]?.resolvedName, E); m.fontFamily = b ?? E } else m.fontFamily = E; m.wordBreak = "break-word"; let w = r.get(T), k = l?.map(D => r.get(`${D.fontFamily}:${D.fontStyle}`)).filter(D => D?.variationAxes) ?? [], R = w?.variationAxes?.length, A = k.length > 0, N = R || A, O = w?.variationAxes ?? k[0]?.variationAxes ?? []; if (N) { let D = [...O, { name: "OpticalSize", value: void 0, tag: "opsz" }].filter(b => u?.[b.name] !== void 0 || b.value !== void 0).filter(b => b.tag === "wght" ? !R && A ? !0 : (m.fontWeight = u?.[b.name] ?? b.value, !1) : b.tag === "slnt" ? b.value === 0 ? (m.fontStyle = "normal", !1) : u && b.name in u : !0); D.length > 0 ? m.fontVariationSettings = D.map(b => { let H = u?.[b.name] ?? b.value; return `"${b.tag}" ${H}` }).join(", ") : m.fontVariationSettings = "normal", w?.italic && (m.fontStyle = "italic") } else m.fontStyle = w?.italic ? "italic" : "normal" } let x = h.filter(T => T.visible !== !1 && T.type === "SOLID"), C = h.filter(T => T.visible !== !1 && T.type !== "SOLID"); if (x.length > 0) { let T = $u(x.map(E => new dt(E.color, E.opacity, ct, s, E.boundVariables?.color?.resolvedName, a && E.boundVariables?.color?.resolvedCodeSyntax?.[a]))); m.color = T.value } if (C.length) { let T = Fp(h, t, o, i, { isDecorativeImage: !1, disableImageTag: !0 })[0].backgroundStyles; T && Object.keys(T).length && (Object.assign(m, T), v = "textClip") } if (p) { let T = g3[p] || "none"; T !== "none" && (m.textTransform = T); let E = y3[p] || "normal"; E !== "normal" && (m.fontVariantCaps = E) } if (y && (m.fontFeatureSettings = Object.entries(y).map(([T, E]) => `"${T.toLowerCase()}" ${E}`).join(", ")), d && (n === "REFLOW" ? m.fontSize = e.style.responsiveTextStyleVariants?.length && !i.optimizeForTailwindConversion ? `var(--responsive-font-size,${L(d)}px)` : `${L(d)}px` : n === "SCALE" ? m.fontSize = `clamp(calc(var(--min-font-size) / var(--viewport-scale)), ${L(d)}px, calc(var(--max-font-size) / var(--viewport-scale)))` : ye(n)), g && S !== void 0) { let T = g === "PIXELS" ? `${L(S, 4)}px` : `${L(S / 100 * (d ?? 16), 4)}px`; m.letterSpacing = e.style.responsiveTextStyleVariants?.length && !i.optimizeForTailwindConversion ? `var(--responsive-letter-spacing,${T})` : T } if (e.style.responsiveTextStyleVariants?.length) { let T = e.style.responsiveTextStyleVariants.sort((E, w) => E.minWidth - w.minWidth); m.media = Object.fromEntries(T.map(E => { let { style: w } = ga({ ...e, style: E.style }, t, r, n, o, i), k = {}; if (!i.optimizeForTailwindConversion) { if (E.style.fontSize !== void 0 && (k["--responsive-font-size"] = `${L(E.style.fontSize)}px`), E.style.letterSpacing !== void 0) { let H = E.style.letterSpacingUnit === "PIXELS" ? `${L(E.style.letterSpacing, 4)}px` : `${L(E.style.letterSpacing / 100 * (E.style.fontSize ?? 16), 4)}px`; k["--responsive-letter-spacing"] = H } let b = ha(E, s, a); b && (k["--responsive-line-height"] = b) } let { fontSize: R, letterSpacing: A, lineHeight: N, ...O } = w, D = { ...O, ...k }; return [`(min-width: ${E.minWidth}px)`, D] })) } if (s) { let T = "boundVariables" in e ? e.boundVariables : null; m.fontStyle && (m.fontStyle = X(a && T?.fontStyle?.[0]?.resolvedCodeSyntax?.[a], T?.fontStyle?.[0]?.resolvedName, m.fontStyle) ?? m.fontStyle), m.fontWeight && (m.fontWeight = X(a && T?.fontWeight?.[0]?.resolvedCodeSyntax?.[a], T?.fontWeight?.[0]?.resolvedName, m.fontWeight) ?? m.fontWeight), m.fontSize && (m.fontSize = X(a && T?.fontSize?.[0]?.resolvedCodeSyntax?.[a], T?.fontSize?.[0]?.resolvedName, m.fontSize) ?? m.fontSize), m.letterSpacing && (m.letterSpacing = X(a && T?.letterSpacing?.[0]?.resolvedCodeSyntax?.[a], T?.letterSpacing?.[0]?.resolvedName, m.letterSpacing) ?? m.letterSpacing) } return { style: m, className: v } } function pL(e, t) { let r = {}; return e.textAlignHorizontal && e.textAlignHorizontal !== "LEFT" && (r.textAlign = e.textAlignHorizontal === "JUSTIFIED" ? "justify" : e.textAlignHorizontal?.toLowerCase()), e.textAlignVertical !== "TOP" && (r.display = "flex", r.flexDirection = "column", r.justifyContent = m3[e.textAlignVertical || "TOP"]), t.leadingTrim === "CAP_HEIGHT" && (r.textBoxTrim = "both", r.textBoxEdge = "cap alphabetic"), r } function OT(e, t, r, n, o) { return ga(t, e.assets, r, n, { width: e.size.x, height: e.size.y }, o) } function PT(e, t, r, n, o, i) { let { shouldOutputVariables: s, codeSyntaxLanguage: a } = i, { style: l, className: c } = ga(r, e.assets, n, o, { width: e.size.x, height: e.size.y }, i); function u(m) { return r.style[m] ?? t.style[m] ?? e.style[m] } let d = u("textDecoration"), f = u("textDecorationThicknessUnit"), p = u("textDecorationThicknessValue"); if (d && d !== vp.NONE && p !== 0) { l.textDecorationLine = r.characters.length > 0 ? h3[d] : void 0; let m = u("textDecorationSkipInk"), v = u("textUnderlineOffsetUnit"), x = u("textUnderlineOffsetValue"), C = u("textDecorationStyle"), T = u("textDecorationFills"); if (m !== void 0 && (l.textDecorationSkipInk = m ? void 0 : "none"), x !== void 0 ? l.textUnderlineOffset = `${x}${v === "PIXELS" ? "px" : "%"}` : l.textUnderlinePosition = "from-font", p !== void 0 ? l.textDecorationThickness = `${p}${f === "PIXELS" ? "px" : "%"}` : l.textDecorationThickness = "from-font", C !== void 0 && (l.textDecorationStyle = C), T !== void 0) { let E = $u(T.filter(w => w.type === "SOLID").map(w => new dt(w.color, w.opacity, ct, s, w.boundVariables?.color?.resolvedName, a && w.boundVariables?.color?.resolvedCodeSyntax?.[a]))); l.textDecorationColor = E.value } } let y = r.style.fontVariantPosition ?? t.style.fontVariantPosition ?? e.style.fontVariantPosition; if (y && (l.verticalAlign = v3[y], y !== "NORMAL")) { let m = u("fontSize"); l.fontSize = `${(m || 0) * .645}px` } let g = ha(r, s, a), S = g ?? ha(t, s, a) ?? ha(e, s, a) ?? "normal", h = g ? r.style.responsiveTextStyleVariants : e.style.responsiveTextStyleVariants; return l.lineHeight = LT({ responsiveTextStyleVariants: h, shouldOutputVariables: s, codeSyntaxLanguage: a, defaultLineHeight: S, renderOptions: i }), (r.style.hyperlink || t.style.hyperlink || e.style.hyperlink) && (l.cursor = "pointer"), { style: l, className: c } } var mL = (e, t) => { if (!(e === "NONE" || e === "UNORDERED")) return t === 2 || t === 5 ? "lower-alpha" : t === 3 ? "lower-roman" : "decimal" }, LT = ({ responsiveTextStyleVariants: e, shouldOutputVariables: t, codeSyntaxLanguage: r, defaultLineHeight: n, renderOptions: o }) => e?.some(s => ha(s, t, r)) && !o.optimizeForTailwindConversion ? `var(--responsive-line-height,${n})` : n, ha = (e, t, r) => { let n = e.style.lineHeightUnit === "INTRINSIC_%" ? e.style.lineHeightPercent === void 0 || e.style.lineHeightPercent === 100 ? void 0 : `${e.style.lineHeightPercent}%` : e.style.lineHeightUnit === "FONT_SIZE_%" ? `${L((e.style.lineHeightPercentFontSize ?? 100) / 100)}` : e.style.lineHeightUnit === "PIXELS" && e.style.lineHeightPx !== void 0 ? `${L(e.style.lineHeightPx)}px` : void 0; if (t && n) { let o = "boundVariables" in e ? e.boundVariables : null; return X(r && o?.lineHeight?.[0]?.resolvedCodeSyntax?.[r], o?.lineHeight?.[0]?.resolvedName, n) ?? n } return n }; function S3(e, t) { return [`"${e}"`, ...t.map(r => `"${r.fontFamily}:${r.fontStyle}"`), "sans-serif"].join(", ") } var hL = I(P()); function x3(e, t) {
  if (t) {
    e.stack += `

React stack:`+ t.componentStack; let r = new Error("React component stack where the error occurred"); r.stack = t.componentStack, e.cause = r
  }
} var vs = class extends hL.default.Component { state = { hasError: !1, error: null, errorInfo: null }; componentDidCatch(t, r) { this.setState({ error: t, errorInfo: r }), x3(t, r), this.context.reportError(t, { "error-boundary-name": this.props.name }), this.context.setMaterializationError(this.props.nodeId, { nodeName: this.props.name, nodeId: this.props.nodeId, errorMessage: t.stack }) } componentWillUnmount() { this.context.setMaterializationError(this.props.nodeId) } render() { return this.state.error ? null : this.props.children } }; Ir(vs, "contextType", Ku); var Ss = vs; var T3 = { fontFamily: '"Inter:Regular"', fontSize: "11px", fontWeight: "400", lineHeight: "1.5" }, yL = { cursor: "pointer", textDecorationLine: "underline" }, ya = (0, ri.createContext)({ getRichTextBlockStyle: e => ({}), getRichTextSpanStyle: (e, t) => ({}) }); function va(e) { let t = {}; return (e.format || e.format !== "") && (t.textAlign = e.format), e.direction && (t.direction = e.direction), t } function vL(e) { switch (e.tag) { case "h1": return "HEADING1"; case "h2": return "HEADING2"; case "h3": return "HEADING3"; case "h4": return "HEADING4"; case "h5": return "HEADING5"; case "h6": return "HEADING6"; default: ye(e.tag) } } function E3({ lexicalNode: e, parentStyleClass: t }) { let { getRichTextSpanStyle: r } = (0, ri.useContext)(ya), n = { ...r(t ?? "PARAGRAPH", e), whiteSpace: "pre-wrap" }, o = M(n), i = (0, Dg.default)(o); return (0, ne.jsx)("span", { className: i, children: e.text }) } function C3({ lexicalNode: e, children: t }) { let { getRichTextBlockStyle: r } = (0, ri.useContext)(ya), n = { ...va(e), ...r(vL(e)) }, o = M(n); switch (e.tag) { case "h1": return (0, ne.jsx)("h1", { className: o, children: t }); case "h2": return (0, ne.jsx)("h2", { className: o, children: t }); case "h3": return (0, ne.jsx)("h3", { className: o, children: t }); case "h4": return (0, ne.jsx)("h4", { className: o, children: t }); case "h5": return (0, ne.jsx)("h5", { className: o, children: t }); case "h6": return (0, ne.jsx)("h6", { className: o, children: t }); default: ye(e.tag) } } function b3({ lexicalNode: e, children: t }) { let { getRichTextBlockStyle: r } = (0, ri.useContext)(ya), n = { ...va(e), ...r("PARAGRAPH") }, o = M(n); return e.children.length === 0 ? (0, ne.jsx)("p", { className: o, children: (0, ne.jsx)("br", {}) }) : (0, ne.jsx)("p", { className: o, children: t }) } function w3({ lexicalNode: e, children: t }) { let { getRichTextBlockStyle: r } = (0, ri.useContext)(ya), n = { ...va(e), ...r("PARAGRAPH") }, o = M(n), i = (0, Dg.default)(o); return (0, ne.jsx)("blockquote", { className: i, children: (0, ne.jsx)("p", { children: t }) }) } function I3({ lexicalNode: e, children: t }) { let r = re(), n = { ...va(e), ...yL }, o = M(n), i = e.url, s = e.target ?? "", a = r?.env; if (a) { let l = e.target === "_blank", c = zd(e.url, l, a); i = c.url, s = c.target } return (0, ne.jsx)("a", { className: o, href: i, rel: e.rel ?? "", target: s, title: e.title ?? "", children: t }) } function R3(e, t, r) { return e ? t && r ? `${e}/${r}` : e : null } function k3({ lexicalNode: e, children: t }) { let r = re(), n = { ...va(e), ...yL }, o = M(n), i = e.cmsTarget?.cmsItemId, s = i ? r?.cmsBundleData?.slugByItemId.get(i) : void 0, a = r?.websiteData.guidToUrl.get(e.nodeId); if (i && !r?.cmsBundleData) return (0, ne.jsx)(ne.Fragment, { children: t }); let l = R3(a, i, s); if (!l) return (0, ne.jsx)(ne.Fragment, { children: t }); let c = r?.env, u = () => { r?.preloadLocation && r.preloadLocation(l) }; return (0, ne.jsx)("a", { className: o, ...c === "preview" ? { role: "link", tabIndex: 0, onClick: f => { f.preventDefault(), r?.setLocation({ url: l }) }, onMouseDown: u } : { href: l, target: "_self", onMouseDown: u }, children: t }) } function A3({ lexicalNode: e }) { let t = re(), { getAssetURL: r } = t || {}, n = J().get, o = { maxWidth: "100%", height: "auto", display: "inline-block" }; e.isFillWidth && (o.width = "100%"); let i = M(o), s = ""; if (r && t) { let l = t.websiteData?.assets?.get(e.hash), c = l ? n(l) : null; c?.url && (s = r(c.url)) } return (0, ne.jsx)("img", { className: i, src: s, alt: e.altText, loading: "lazy" }) } function N3({ lexicalNode: e, children: t }) { let { getRichTextBlockStyle: r } = (0, ri.useContext)(ya), n = { ...va(e), listStyleType: e.listType === "number" ? "decimal" : "circle", ...r("PARAGRAPH") }, o = M(n), i = e.tag, s = (0, Dg.default)(o); return i === "ol" ? (0, ne.jsx)("ol", { className: s, children: t }) : (0, ne.jsx)("ul", { className: s, children: t }) } function O3({ lexicalNode: e, children: t }) { let { getRichTextBlockStyle: r } = (0, ri.useContext)(ya), n = { ...va(e), ...r("PARAGRAPH") }, o = M(n); return (0, ne.jsx)("li", { className: o, children: t }) } function SL({ lexicalNode: e, parentStyleClass: t }) { let r = e.type; if (!t) switch (r) { case "heading": t = vL(e); break; case "paragraph": t = "PARAGRAPH"; break }let n = "children" in e ? e.children.map((o, i) => (0, ne.jsx)(SL, { lexicalNode: o, parentStyleClass: t }, i)) : []; switch (r) { case "root": return (0, ne.jsx)("div", { className: "root", children: n }); case "heading": return (0, ne.jsx)(C3, { lexicalNode: e, children: n }); case "paragraph": return (0, ne.jsx)(b3, { lexicalNode: e, children: n }); case "linebreak": return (0, ne.jsx)("br", {}); case "text": return (0, ne.jsx)(E3, { lexicalNode: e, parentStyleClass: t }); case "link": return (0, ne.jsx)(I3, { lexicalNode: e, children: n }); case "internal-link": return (0, ne.jsx)(k3, { lexicalNode: e, children: n }); case "image": return (0, ne.jsx)(A3, { lexicalNode: e }); case "quote": return (0, ne.jsx)(w3, { lexicalNode: e, children: n }); case "list": return (0, ne.jsx)(N3, { lexicalNode: e, children: n }); case "listitem": return (0, ne.jsx)(O3, { lexicalNode: e, children: n }); default: ye(r) } } function P3({ node: e, websiteContext: t }) { let r = J().get, n = Zn(), { scalingMode: o } = zr(), i = Ee(), s = u => u ? ga(u, void 0, n, o, { width: 0, height: 0 }, i).style : {}, a = u => { if (!t) return null; let d = e.cmsRichTextStyleMap, f = t.websiteData.assetIdToGuid, p = t.websiteData.nodeById, y = d[u]; if (y) { let g = y.textStyleId, S = f.get(g); if (S) { let h = p.get(S), m = r(h); if (m && m.style) { let v = Po(m.style); return v.fills = e.fills, { spans: [], indentation: 0, startOffset: 0, style: v, startsWithPunctuation: !1 } } } } return null }; return { getRichTextBlockStyle: u => { let d = a(u); if (d) { let f = s(d), p = !1, y = void 0, g = ha({ style: d.style }, p, y) || "normal"; return f.lineHeight = LT({ responsiveTextStyleVariants: d.style.responsiveTextStyleVariants, shouldOutputVariables: p, codeSyntaxLanguage: y, defaultLineHeight: g, renderOptions: i }), f } return T3 }, getRichTextSpanStyle: (u, d) => { let f = a(u), p = {}, y = 1, g = 1 << 1, S = 1 << 2, h = 1 << 3; return d.format & y && (p.fontWeight = "bold"), d.format & g && (p.fontStyle = "italic", f?.style.fontStyle && (f.style.fontStyle = "italic")), d.format & S && (p.textDecorationLine = "line-through"), d.format & h && (p.textDecorationLine = "underline"), { ...p, ...s(f) } } } } function L3(e, t, r, n, o, i) { let s = e.interactions ?? [], a = uo(e), l = gL.useMemo(() => ({ opacity: Nt(t, e), transform: Jr(r.outer.transform) }), [t, e, r.outer.transform]), c = nn(e, t), { motionProps: u, key: d, ref: f } = sn(e.id, e.behaviors, e.assets, l, c), p = gn(s, n, !0, o), y = i?.smartAnimateType ?? K.NONE, g = Nt(t, e), S = i?.transitionData, h = kt(S); return { accessibilityProps: a, behaviorProps: u, interactionProps: p, behaviorsRef: f, key: d, transitionProps: { opacity: g, smartAnimateType: y, behaviorProps: u, transitionData: S, onTransitionEnd: h } } } function xL({ node: e, parent: t, context: r, zIndex: n, interactionHandlers: o, transitionProps: i }) { let s = re(), a = ue(), { getRichTextBlockStyle: l, getRichTextSpanStyle: c } = P3({ node: e, websiteContext: s }), u = vr({ node: e, parent: t, context: r, zIndex: n, children: [], options: { isFlattened: !0 } }), d = an({ node: e, context: r }), f = Sr({ node: e, parent: t }), y = { ...{ width: f.width, height: f.height }, ...u.inner, mixBlendMode: Sl(e.blendMode), ...xr(Nt(r, e)), ...bc(e, t, r), ...d, ...r?.style || {} }, g = de(e), S = cn(e), { accessibilityProps: h, interactionProps: m, behaviorsRef: v, key: x, transitionProps: C } = L3(e, r, u, o, a, i); if (!e.richText || !s) return null; let T = Bw(JSON.parse(e.richText)); return (0, ne.jsx)(Ss, { name: "cms-rich-text", nodeId: e.id, children: (0, ne.jsx)(Gt, { outerStyles: u.outer, children: (0, ne.jsx)(hn, { node: e, parent: t, context: r, transitionProps: C, styles: { transform: u.transform, stickyWrapper: u.stickyWrapper }, children: (0, ne.jsx)(ho, { ref: v, semanticTagInfo: { semanticTag: "div", interactiveSemanticTag: null }, wrapperSizeStyles: f, context: r, styles: y, id: g, "data-name": S, nodeName: e.name, transitionProps: C, ...m, ...h, children: T.root ? (0, ne.jsx)(ya.Provider, { value: { getRichTextBlockStyle: l, getRichTextSpanStyle: c }, children: (0, ne.jsx)(SL, { lexicalNode: T.root, parentStyleClass: null }) }) : null }, x) }) }) }) } var xs = I(W()), Ca = I(P()), H3 = I(nT()), W3 = I(W()), j3 = I(il()), U3 = I(pp()); var Wn = I(W()), Ea = I(P()), _T = I(un()); var xa = I(W()); var Sa = I(W()), TL = (0, Sa.jsx)("svg", { width: "24", height: "24", fill: "none", viewBox: "0 0 24 24", children: (0, Sa.jsx)("path", { fill: "#191919", fillRule: "evenodd", d: "M7 7c0 1.043.533 1.963 1.341 2.5A3 3 0 0 0 7 12c0 1.043.533 1.963 1.341 2.5A3 3 0 1 0 13 17v-2.764A3 3 0 1 0 16.659 9.5 3 3 0 0 0 15 4h-5a3 3 0 0 0-3 3m8 2a2 2 0 1 0 0-4h-2v4zm-2 3a2 2 0 1 0 4 0 2 2 0 0 0-4 0m-1 2h-2a2 2 0 1 1 0-4h2zm-2 1h2v2a2 2 0 1 1-2-2m2-6h-2a2 2 0 1 1 0-4h2z", clipRule: "evenodd" }) }), Mg = (0, Sa.jsx)("svg", { width: "24", height: "24", fill: "none", viewBox: "0 0 24 24", children: (0, Sa.jsx)("path", { fill: "#191919", fillRule: "evenodd", d: "M6.5 6a.5.5 0 0 1 .5.5V7h10a1 1 0 0 1 1 1v7a1 1 0 0 1-1 1H7v2.5a.5.5 0 0 1-1 0v-12a.5.5 0 0 1 .5-.5M7 8v7h10V8zm6.854 1.446a.5.5 0 0 1 0 .707L12.707 11.3l1.147 1.146a.5.5 0 0 1-.708.707L12 12.007l-1.146 1.146a.5.5 0 0 1-.708-.707l1.147-1.146-1.147-1.147a.5.5 0 0 1 .708-.707L12 10.593l1.146-1.147a.5.5 0 0 1 .708 0", clipRule: "evenodd" }) }), EL = (0, Sa.jsx)("svg", { width: "24", height: "24", fill: "none", viewBox: "0 0 24 24", children: (0, Sa.jsx)("path", { fill: "#FFFFFF", d: "M13.992 12a.5.5 0 0 1 .5.507l-.002.172c-.049 1.564-.265 2.983-.598 4.064-.189.615-.425 1.149-.71 1.54-.276.38-.67.717-1.182.717-.513 0-.906-.337-1.183-.717-.284-.391-.52-.925-.71-1.54l-.055-.185c-.09-.322.175-.626.508-.605a.52.52 0 0 1 .467.375l.036.121c.173.561.369.98.563 1.246.2.276.333.305.374.305s.172-.028.374-.305c.194-.266.39-.685.562-1.246.3-.977.507-2.304.554-3.799l.002-.158a.5.5 0 0 1 .5-.492M7.44 10.054c.322-.091.625.173.606.506a.52.52 0 0 1-.374.467l-.122.037c-.56.172-.98.368-1.246.562-.277.202-.304.335-.304.374 0 .04.027.172.304.374.267.194.685.39 1.246.563.977.3 2.304.506 3.8.553l.157.002a.5.5 0 0 1-.015 1l-.171-.003c-1.564-.049-2.983-.264-4.065-.596-.614-.19-1.148-.426-1.54-.71C5.336 12.906 5 12.513 5 12s.336-.906.716-1.183c.392-.284.926-.52 1.54-.71zm5.238-.543c1.564.048 2.983.264 4.065.596.615.19 1.149.426 1.54.71.38.277.717.67.717 1.183s-.337.906-.717 1.183c-.391.284-.925.52-1.54.71q-.09.027-.185.053c-.322.09-.625-.174-.605-.508a.52.52 0 0 1 .374-.465l.122-.037c.561-.172.98-.368 1.246-.562.277-.202.305-.335.305-.374 0-.04-.028-.172-.305-.374-.267-.194-.685-.39-1.246-.562-.977-.301-2.304-.508-3.799-.554l-.158-.002a.5.5 0 0 1 .015-1zM12 5c.512 0 .906.337 1.182.717.285.391.521.925.71 1.54q.028.09.054.183a.484.484 0 0 1-.508.606.52.52 0 0 1-.467-.375l-.035-.12c-.172-.561-.368-.98-.562-1.246C12.172 6.028 12.039 6 12 6c-.04 0-.174.029-.374.305-.194.266-.39.685-.563 1.246-.31 1.01-.52 2.393-.558 3.949A.51.51 0 0 1 10 12a.49.49 0 0 1-.495-.5c.038-1.634.257-3.12.602-4.243.19-.615.426-1.149.71-1.54.277-.38.67-.717 1.183-.717" }) }); var _3 = () => { let e = M({ display: "flex", width: "100%", height: "var(--banner-height)", padding: "8px", flexDirection: "row", alignItems: "center", justifyContent: "space-between", flexShrink: 0, position: "fixed", top: "calc(var(--banner-height) * -1)", left: "0", right: "0", zIndex: 999, borderBottomWidth: "1px", borderBottomStyle: "solid", borderBottomColor: "#e1e2e2", backgroundColor: "#FFFFFF" }), t = M({ display: "flex", padding: "4px", alignItems: "center", borderRadius: "5px", border: "1px solid #e1e2e2" }), r = M({ display: "flex", padding: "4px", alignItems: "center", borderRadius: "5px" }), n = M({ display: "flex", minHeight: "32px", padding: "4px", paddingRight: "12px", alignItems: "center", borderRadius: "5px", background: "#1E1E1E", color: "#FFFFFF", textAlign: "center", fontFamily: "Inter, sans-serif", fontSize: "11px", fontStyle: "normal", fontWeight: "450", lineHeight: "16px", letterSpacing: "0.055px" }), o = M({ display: "flex", alignItems: "center", flexDirection: "row", gap: "12px" }); return { bannerStyles: e, reportButtonStyles: t, figmaLogoStyles: r, remixButtonStyles: n, rightContentStyles: o } }; function CL({ bannerUrlsAndStrings: e }) { let { bannerStyles: t, reportButtonStyles: r, figmaLogoStyles: n, remixButtonStyles: o, rightContentStyles: i } = _3(); return (0, xa.jsxs)("div", { className: t, children: [(0, xa.jsx)("a", { className: n, href: e.figma_logo_url, children: TL }), (0, xa.jsxs)("div", { className: i, children: [(0, xa.jsx)("a", { target: "_blank", className: r, href: e.report_abuse_url, rel: "noreferrer", title: e.report_button_text, "aria-label": e.report_button_text, children: Mg }), (0, xa.jsxs)("a", { target: "_blank", className: o, href: e.hub_file_url, rel: "noreferrer", children: [EL, e.remix_button_text] })] })] }) } var it = I(W()), Ta = I(P()), bL = I(un()); var D3 = (0, it.jsx)("svg", { width: "24", height: "24", fill: "none", viewBox: "0 0 24 24", children: (0, it.jsx)("path", { fill: "currentColor", d: "M13.992 12a.5.5 0 0 1 .5.507l-.002.172c-.049 1.564-.265 2.983-.598 4.064-.189.615-.425 1.149-.71 1.54-.276.38-.67.717-1.182.717-.513 0-.906-.337-1.183-.717-.284-.391-.52-.925-.71-1.54l-.055-.185c-.09-.322.175-.626.508-.605a.52.52 0 0 1 .467.375l.036.121c.173.561.369.98.563 1.246.2.276.333.305.374.305s.172-.028.374-.305c.194-.266.39-.685.562-1.246.3-.977.507-2.304.554-3.799l.002-.158a.5.5 0 0 1 .5-.492M7.44 10.054c.322-.091.625.173.606.506a.52.52 0 0 1-.374.467l-.122.037c-.56.172-.98.368-1.246.562-.277.202-.304.335-.304.374 0 .04.027.172.304.374.267.194.685.39 1.246.563.977.3 2.304.506 3.8.553l.157.002a.5.5 0 0 1-.015 1l-.171-.003c-1.564-.049-2.983-.264-4.065-.596-.614-.19-1.148-.426-1.54-.71C5.336 12.906 5 12.513 5 12s.336-.906.716-1.183c.392-.284.926-.52 1.54-.71zm5.238-.543c1.564.048 2.983.264 4.065.596.615.19 1.149.426 1.54.71.38.277.717.67.717 1.183s-.337.906-.717 1.183c-.391.284-.925.52-1.54.71q-.09.027-.185.053c-.322.09-.625-.174-.605-.508a.52.52 0 0 1 .374-.465l.122-.037c.561-.172.98-.368 1.246-.562.277-.202.305-.335.305-.374 0-.04-.028-.172-.305-.374-.267-.194-.685-.39-1.246-.562-.977-.301-2.304-.508-3.799-.554l-.158-.002a.5.5 0 0 1 .015-1zM12 5c.512 0 .906.337 1.182.717.285.391.521.925.71 1.54q.028.09.054.183a.484.484 0 0 1-.508.606.52.52 0 0 1-.467-.375l-.035-.12c-.172-.561-.368-.98-.562-1.246C12.172 6.028 12.039 6 12 6c-.04 0-.174.029-.374.305-.194.266-.39.685-.563 1.246-.31 1.01-.52 2.393-.558 3.949A.51.51 0 0 1 10 12a.49.49 0 0 1-.495-.5c.038-1.634.257-3.12.602-4.243.19-.615.426-1.149.71-1.54.277-.38.67-.717 1.183-.717" }) }), M3 = (0, it.jsx)("svg", { width: "24", height: "24", fill: "none", viewBox: "0 0 24 24", children: (0, it.jsx)("path", { fill: "currentColor", d: "M6 10.5C6.82843 10.5 7.5 11.1716 7.5 12C7.5 12.8284 6.82843 13.5 6 13.5C5.17157 13.5 4.5 12.8284 4.5 12C4.5 11.1716 5.17157 10.5 6 10.5ZM12 10.5C12.8284 10.5 13.5 11.1716 13.5 12C13.5 12.8284 12.8284 13.5 12 13.5C11.1716 13.5 10.5 12.8284 10.5 12C10.5 11.1716 11.1716 10.5 12 10.5ZM18 10.5C18.8284 10.5 19.5 11.1716 19.5 12C19.5 12.8284 18.8284 13.5 18 13.5C17.1716 13.5 16.5 12.8284 16.5 12C16.5 11.1716 17.1716 10.5 18 10.5Z" }) }), B3 = (0, it.jsx)("svg", { width: "24", height: "24", fill: "none", viewBox: "0 0 24 24", children: (0, it.jsx)("path", { fill: "currentColor", d: "M16.6465 6.64648C16.8417 6.45122 17.1583 6.45122 17.3535 6.64648C17.5488 6.84175 17.5488 7.15825 17.3535 7.35352L12.707 12L17.3535 16.6465C17.5488 16.8417 17.5488 17.1583 17.3535 17.3535C17.1583 17.5488 16.8417 17.5488 16.6465 17.3535L12 12.707L7.35352 17.3535C7.15825 17.5488 6.84175 17.5488 6.64648 17.3535C6.45122 17.1583 6.45122 16.8417 6.64648 16.6465L11.293 12L6.64648 7.35352C6.45127 7.15825 6.45124 6.84173 6.64648 6.64648C6.84173 6.45129 7.15827 6.45129 7.35352 6.64648L12 11.293L16.6465 6.64648Z" }) }), V3 = () => { let e = M({ backgroundColor: "#ffffff", boxSizing: "border-box", display: "flex", gap: "8px", alignItems: "center", overflow: "visible", paddingLeft: "8px", paddingTop: "0px", paddingBottom: "0px", borderRadius: "13px", boxShadow: "0px 0px 0.5px 0px rgba(0,0,0,0.3), 0px 1px 3px 0px rgba(0,0,0,0.15)", width: "fit-content", height: "var(--banner-height-v2)", position: "fixed", bottom: "20px", right: "40px", zIndex: 999 }), t = M({ color: "rgba(0, 0, 0, 0.9)" }), r = M({ boxSizing: "border-box", display: "flex", alignItems: "center", paddingLeft: "4px", paddingRight: "4px", paddingTop: "8px", paddingBottom: "8px", fontFamily: "Inter, sans-serif", fontWeight: "550", fontStyle: "normal", fontSize: "11px", color: "rgba(0, 0, 0, 0.9)", lineHeight: "16px", letterSpacing: "0.055px" }), n = M({ display: "flex", flexDirection: "row", alignItems: "center", alignSelf: "stretch", boxSizing: "border-box", height: "100%", justifyContent: "flex-end", position: "relative", flexShrink: 0 }), o = M({ backgroundColor: "#4D49FC", color: "#ffffff", border: "1px solid rgba(0, 0, 0, 0.1)", borderRadius: "0.3125rem", padding: "0 0.5rem", fontSize: "11px", fontFamily: "Inter, sans-serif", fontWeight: "450", lineHeight: "16px", letterSpacing: "0.055px", cursor: "pointer", display: "flex", alignItems: "center", minHeight: "24px", textDecoration: "none", marginRight: "0.5rem" }), i = M({ borderLeft: "1px solid rgba(0, 0, 0, 0.1)", boxSizing: "border-box", display: "flex", height: "100%", alignItems: "center", paddingLeft: "0px", paddingRight: "0px", paddingTop: "0px", paddingBottom: "0px", position: "relative", flexShrink: 0 }), s = M({ background: "none", border: "none", cursor: "pointer", padding: "0.5rem", display: "flex", alignItems: "center", justifyContent: "center", color: "rgba(0, 0, 0, 0.5)", borderRadius: "4px" }), a = M({ backgroundColor: "#ffffff", borderRadius: "11px", boxShadow: "0px 0px 0.5px 0px rgba(0,0,0,0.3), 0px 1px 3px 0px rgba(0,0,0,0.15)", position: "absolute", bottom: "100%", right: "0px", marginBottom: "8px", width: "fit-content", zIndex: 1e3, padding: "8px", boxSizing: "border-box" }), l = M({ display: "flex", alignItems: "center", gap: "4px", width: "100%", backgroundColor: "transparent", border: "none", textAlign: "right", cursor: "pointer", fontSize: "11px", fontFamily: "Inter, sans-serif", fontWeight: "400", color: "rgba(0, 0, 0, 0.9)", lineHeight: "20px" }); return { container: e, iconStyles: t, textWrapStyles: r, ctaRailContainerStyles: n, remixButtonStyles: o, dividerStyles: i, iconButtonStyles: s, popupMenuStyles: a, menuItemStyles: l } }; function wL({ bannerUrlsAndStrings: e }) { let { container: t, iconStyles: r, textWrapStyles: n, ctaRailContainerStyles: o, remixButtonStyles: i, dividerStyles: s, iconButtonStyles: a, popupMenuStyles: l, menuItemStyles: c } = V3(), [u, d] = (0, Ta.useState)(!1), [f, p] = (0, Ta.useState)(!1), y = (0, Ta.useRef)(null); return (0, Ta.useEffect)(() => { let g = S => { y.current && !y.current.contains(S.target) && p(!1) }; return f && document.addEventListener("mousedown", g), () => { document.removeEventListener("mousedown", g) } }, [f]), u ? null : (0, it.jsxs)("div", { className: (0, bL.default)(t, "banner-v2-container"), children: [(0, it.jsx)("div", { className: r, children: D3 }), (0, it.jsx)("div", { className: n, children: (0, it.jsx)("p", { children: e.banner_v2_text }) }), (0, it.jsxs)("div", { className: o, children: [(0, it.jsx)("a", { target: "_blank", className: i, href: e.hub_file_url, rel: "noreferrer", children: e.remix_button_text }), (0, it.jsxs)("div", { className: s, ref: y, children: [(0, it.jsx)("button", { className: a, onClick: () => p(!f), title: e.more_options_text, "aria-label": e.more_options_text, children: M3 }), f && (0, it.jsx)("div", { className: l, children: (0, it.jsxs)("a", { target: "_blank", className: c, href: e.report_abuse_url, rel: "noreferrer", title: e.report_button_text, "aria-label": e.report_button_text, children: [Mg, " ", e.report_button_text] }) })] }), (0, it.jsx)("div", { className: s, children: (0, it.jsx)("button", { className: a, "aria-label": e.close_text, title: e.close_text, onClick: () => d(!0), children: B3 }) })] })] }) } var Bg = q(!1); function F3({ isLoading: e, bannerUrlsAndStrings: t }) { return e || !t ? null : t.banner_version === "2" ? (0, Wn.jsx)(wL, { bannerUrlsAndStrings: t }) : (0, Wn.jsx)(CL, { bannerUrlsAndStrings: t }) } var z3 = () => { let e = M({ transitionProperty: "transform", transitionDuration: "0.2s", transitionTimingFunction: "ease-in-out" }), t = M({ transform: "translateY(var(--banner-height))", height: "var(--full-height-with-banner)" }), r = M({ height: "var(--full-height-with-banner)", position: "fixed", inset: "0", overflow: "auto" }); return { wrapperStyles: e, wrapperShowBannerStyles: t, siteWrapperShowBannerStyles: r } }; function IL({ children: e }) { let t = ge(Bg), { wrapperShowBannerStyles: r, siteWrapperShowBannerStyles: n } = z3(), [o, i] = (0, Ea.useState)(!1), s = sw(Bg), [a, l] = (0, Ea.useState)(null), [c, u] = (0, Ea.useState)(!0); (0, Ea.useEffect)(() => (i(!0), () => { i(!1) }), []), (0, Ea.useEffect)(() => { o && (async () => { try { u(!0); let p = await fetch("/_api/community_published_banner_details", { redirect: "follow" }); if (p.status === 200) { let y = await p.json(); y.meta && (l(y.meta), s(!0)) } } catch (p) { console.error("Error fetching hub file URL:", p) } finally { u(!1) } })() }, [o, s]); let d = a?.banner_version === "2"; return o ? (0, Wn.jsxs)("div", { className: (0, _T.default)({ [r]: t && !d, "wrapper-with-banner": t && !d }), children: [(0, Wn.jsx)(vs, { name: "banner-error-boundary", nodeId: "banner", children: (0, Wn.jsx)(F3, { isLoading: c, bannerUrlsAndStrings: a }) }), (0, Wn.jsx)("div", { className: (0, _T.default)({ [n]: t && !d }), children: e })] }) : (0, Wn.jsx)(Wn.Fragment, { children: e }) } var Vg = I(W()), RL = I(P()), kL = I(un()); var AL = RL.default.forwardRef(function (t, r) { let { children: n, wrapperSizeStyles: o, semanticTag: i, context: s, styles: a, additionalClassName: l, tabIndex: c, ...u } = t, f = { ...$t() ?? o, ...a }, p = M(f, s?.renderedByCode), y = (0, kL.default)(l, p, s?.className), g = M({ width: "100%", height: "100%" }), { finalInnerSemanticTag: S, needsListWrapper: h } = og(i, null, Yh()), m = S; return h ? (0, Vg.jsx)("li", { className: y, children: (0, Vg.jsx)(m, { tabIndex: us(S) ? -1 : c, className: g, ...u, ref: r, children: n }) }) : (0, Vg.jsx)(m, { tabIndex: us(S) ? -1 : c, className: y, ...u, ref: r, children: n }) }); function NL({ node: e, parent: t, interactionHandlers: r, context: n, zIndex: o }) { let i = vr({ node: e, parent: t, context: n, zIndex: o, children: [], options: { isFlattened: !0 } }), s = Nt(n, e), a = nn(e, n), l = Ca.useMemo(() => ({ opacity: s, transform: Jr(i.outer.transform) }), [s, i.outer.transform]), { motionProps: c, key: u, ref: d } = sn(e.id, e.behaviors, e.assets, l, a), f = ue(), p = Ap(), y = e.interactions ?? [], g = go(y), S = Hn(y), h = n?.withinInteractiveElement ?? !1, m = gn(y, r, h, f), { semanticTag: v } = ds(e, S, g, h, !1), x = v, C = ge(Bg), T = an({ node: e, context: n }), E = Sr({ node: e, parent: t }), w = { ...i.inner, ...xr(Nt(n, e)), ...bc(e, t, n), ...T, ...n?.style || {}, ...p ? { height: C ? "var(--full-height-with-banner)" : "100dvh" } : {} }, k = de(e); return (0, xs.jsx)(Gt, { outerStyles: i.outer, children: (0, xs.jsx)(hn, { node: e, parent: t, context: n, styles: { transform: i.transform, stickyWrapper: i.stickyWrapper }, children: (0, xs.jsx)(AL, { semanticTag: x, wrapperSizeStyles: E, id: k, styles: w, additionalClassName: "tailwind", ref: d, ...c, ...m, children: (0, xs.jsx)(dn, { children: () => (0, xs.jsx)(G3, { node: e }) }) }, u) }) }) } function G3({ node: e }) { ps("CodeComponentContent"); let t = Ic(), r = re().getAssetURL, [n, o] = Ca.useState(null); globalThis.__GLOBALS__ = { React: Ca, ReactJSXRuntime: W3, ReactJSXDevRuntime: H3, ReactDOM: j3, ReactDOMClient: U3, SnapshotContext: Ld, RenderHooksContext: da, NewRenderHooksContext: fa, useAnimateNode: Nd, getChildNode: Pd, getChildNodes: Od, ActiveBreakpointContext: Nc, WebsiteSettingsContext: Pc, getAssetURL: r }; let i = re().getCodeComponentURL(e), s = re().websiteData.sourceCodeHash, a = ge(s); Ca.useEffect(() => { (async () => { let f; try { f = await import(i) } catch (p) { Oc(a, p, "Failed to import code layer module"); return } try { let p = await vg(f, e.codeExportName); o(() => p) } catch (p) { Oc(a, p, "Failed to execute code layer") } })() }, [e.codeExportName, i, a]); let l = $3(n), c = lT(l), u = IP(e, c, l); return t && n ? (0, xs.jsx)(Ss, { name: "code-component", nodeId: e.id, children: (0, xs.jsx)(n, { ...u }) }) : null } function $3(e) { return e ? e[Symbol.for("figma.react.props")] ?? {} : null } var DT = I(W()), OL = I(P()); function PL({ node: e, children: t, context: r }) { let n = de(e), o = cn(e), i = OL.default.useMemo(() => { let s = { "data-name": o }; return r?.dataAttributes && Object.entries(r.dataAttributes).forEach(([a, l]) => { s[a] = l }), s }, [o, r?.dataAttributes]); return (0, DT.jsx)("div", { id: n, "data-name": o, ...i, children: t.map(s => (0, DT.jsx)(Fn, { node: s, parent: null }, s.id)) }) } var Hd = I(W()), Fg = I(P()); var K3 = [[1, 0, 0], [0, 1, 0]]; function LL({ node: e, parent: t, children: r, interactionHandlers: n, context: o, zIndex: i, transitionProps: s }) { let a = ue(), l = o?.group, c = jt(e, t), u = c ? K3 : e.relativeTransform, d = l?.withinAutoLayout || c, f = !d, p = Nt(o, e), y = e.scrollBehavior === "FIXED" || e.scrollBehavior === "STICKY_SCROLLS", g = vr({ node: e, parent: t, context: o, zIndex: i, children: r ?? null }), S = e.interactions ?? [], h = Wp(ml()) && yr(e), m = go(S), v = Hn(S), x = uo(e), C = Fg.default.useMemo(() => ({ opacity: p, transform: Jr(g.transform.transform) }), [p, g.transform.transform]), T = nn(e, o), { motionProps: E, key: w, ref: k } = sn(e.id, e.behaviors, e.assets, C, T), R = Sr({ node: e, parent: t }), { shouldOutputVariables: A, codeSyntaxLanguage: N } = Ee(), O = { ...g.inner, ...f ? {} : xr(p, A, e.boundVariables?.opacity?.resolvedName, N && e.boundVariables?.opacity?.resolvedCodeSyntax?.[N]), ...zi(e) }, D = s?.smartAnimateType ?? K.NONE, b = kt(s?.transitionData), H = o?.withinInteractiveElement || Object.keys(E).length > 0 || D === K.INSTANCE_SUBTREE, B = gn(S, n, H, a), z = ds(e, v, m, H, h), Q = ng(z) !== null, se = de(e), he = cn(e), xe = (0, Fg.useRef)(null), Oe = { group: { withinAutoLayout: d, relativeTransform: _r(Zr(l?.relativeTransform, u)), opacity: f ? p : void 0, mixBlendMode: d ? void 0 : Sl(e.blendMode) }, parentIsList: Q, masks: o?.masks, isInStickyOrFixedTree: y || (o?.isInStickyOrFixedTree ?? !1), withinInteractiveElement: o?.withinInteractiveElement }, Y = sg({ children: r, context: Oe }); return (0, Hd.jsx)(Gt, { outerStyles: g.outer, children: (0, Hd.jsx)(hn, { node: e, parent: t, context: o, styles: { transform: g.transform, stickyWrapper: g.stickyWrapper }, outerRef: xe, transitionProps: s, children: (0, Hd.jsx)(ho, { semanticTagInfo: z, context: o, wrapperSizeStyles: R, ref: k, id: se, styles: O, nodeName: e.name, "data-name": he, transitionProps: { opacity: p, smartAnimateType: D, behaviorProps: E, transitionData: s?.transitionData, onTransitionEnd: b }, ...B, ...x, children: Y?.map(([$, { key: oe, context: ve }]) => (0, Hd.jsx)(lg, { name: "sites-layer", nodeId: $.id, childKey: oe, node: $, parent: e, context: ve }, oe)) }, w) }) }) } var Es = I(W()), Wye = I(P()), JT = I(un()); var Ct = I(W()), ir = I(P()); var X3 = { url: "" }; var zg = "reset-css"; function MT(e = !0) { return jp` @layer figreset,figoverridable,reset,theme,base,figutils,components,utilities;@layer figreset{:root{--100dvw:100vw;--100dvh:100vh;--banner-height:48px;--banner-height-v2:40px;--full-height-with-banner:calc(100dvh - var(--banner-height));font-synthesis:none;text-align:left;button{text-align:left}}@supports (width:100dvw){:root{--100dvw:100dvw;--100dvh:100dvh}}}@media (max-width:600px){.banner-v2-container{left:0 !important;right:0 !important;margin:0 auto !important}}.wrapper-with-banner .min-h-screen{min-height:var(--full-height-with-banner)}.wrapper-with-banner .h-screen{height:var(--full-height-with-banner)}${e ? q3 : ""}` } var q3 = `
  @layer figreset {
    /* Modelled after Tailwind's Preflight CSS */
    /* When adding new styles, consider scoping them down to '#container .helperClass' in order to avoid conflicts with CSS styles applied to Code Layers */

    /* Global */

    :root {
      /* Default styling for code nodes. */
      font-family: var(--default-font-family, ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji");
    }

    *,
    *:before,
    *:after {
      box-sizing: border-box; /* Prevent padding and border from affecting element width */
    }

    /* HTML */

    html {
      -webkit-text-size-adjust: 100%; /* Prevent adjustments of font size after orientation changes in iOS. */
      -webkit-tap-highlight-color: transparent; /* Disable tap highlights on iOS */
      -webkit-font-smoothing: antialiased; /* Improve font rendering on macOS. */

      width: 100%;
    }

    html:has(#responsive-scaler) {
      scrollbar-width: none;
      -ms-overflow-style: none;
    }

    /* Body */

    body {
      margin: 0; /* Remove default margin */
      width: 100%;
    }

    body:has([data-page-overflowx='hidden']) {
      overflow-x: hidden;
    }

    body:has([data-page-overflowx='auto']) {
      overflow-x: auto;
    }

    /* Container */

    #container {
      width: 100%;
    }

    /* Links */

    a {
      color: inherit;
      text-decoration: none;
    }

    button {
      border: none;
      background: none;
      padding: 0;
    }

    /* Text */

    h1,
    h2,
    h3,
    h4,
    h5,
    h6,
    p {
      font-size: inherit;
      font-weight: inherit;
    }

    /* Remove the default margins */

    blockquote,
    dl,
    dd,
    h1,
    h2,
    h3,
    h4,
    h5,
    h6,
    hr,
    figure,
    p,
    pre {
      margin: 0;
    }

    ol, ul, menu {
      list-style: none;
      margin: 0;
      padding-inline-start: 0;
    }

    /* Keep textContents and textClip in sync with cleanResetText() in preprocess_css.ts */
    #container .textContents {
      /* Text is transparent by default, in case of no fills. */
      color: #ffffff00;
    }

    /**
     * Applies text as a background clip when non-solid fills are present.
     *
     * The !important is used to prevent the selector below (.textClip > *) from overriding this value.
     *
     * Keep in sync with cleanResetText() in preprocess_css.ts.
     **/
      #container .textClip {
        background-clip: text;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent !important;
      }

      /** Removes the text fill color for the subtree so it doesn't cascade downward. */
      #container .textClip > * {
        -webkit-text-fill-color: initial;
      }

    /** Removes default border from iframes */
    #container .embed {
      border: none;
    }

      /*
   * ----------------- Marquee styles -----------------
   * These are adapted from https://github.com/justin-chu/react-fast-marquee/blob/master/src/components/Marquee.tsx
   * Copyright (c) 2020 justin-chu
   * MIT License
   */
    #container .marquee-container {
      overflow-x: hidden;
      display: flex;
      flex-direction: row;
      position: relative;
      width: var(--width);
      transform: var(--transform);

      &:hover div {
        animation-play-state: var(--pause-on-hover);
      }

      &:active div {
        animation-play-state: var(--pause-on-click);
      }
    }

    #container .marquee {
      flex: 0 0 auto;
      min-width: var(--min-width);
      display: flex;
      flex-direction: row;
      align-items: center;
      animation: scroll var(--duration) linear var(--delay) var(--iteration-count);
      animation-delay: var(--delay);
      animation-direction: var(--direction);
      animation-timing-function: var(--timing-function);
    }

    #container .marquee.reduced-motion {
      @media (prefers-reduced-motion: reduce) {
        animation: none;
      }
    }

    @keyframes scroll {
      0% {
        transform: translateX(0%);
      }
      100% {
        transform: translateX(-100%);
      }
    }

    #container .marquee-initial-child-container {
      flex: 0 0 auto;
      display: flex;
      min-width: auto;
      flex-direction: row;
      align-items: center;
    }

    #container .marquee-child {
      transform: var(--transform);
    }

    /**
     * Styles for direct children of the code behavior wrapper.
     * These elements are defined in the code behavior, so we can't access them directly.
     */
    .code-behavior-wrapper > * {
      width: 100%;
      height: 100%;
    }

    .bypass-link {
      position: fixed;
      top: 16px;
      left: 0;
      right: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      opacity: 0;
      pointer-events: none;
    }

    .bypass-link:focus-within {
      opacity: 1;
      z-index: ${1e4};
    }

    .bypass-link > a {
        background-color: #000;
        color: #fff;
        border: 1px solid #fff;
        padding: 12px 16px;
        font-size: 16px;
        border-radius: 12px;
        pointer-events: auto;
    }
}

  @layer figutils {
    /*
      List discs are not native, so we get more rounded circles and closer positioning to designs
    */
    /* .css-ul-before is used in design-to-react */
    :is(.textContents ul, ul.textContents) > li:before {
      content: '\\2022';
      margin-left: -1.5em;
      display: inline-block;
      text-align: center;
      width: 1.5em;
      -webkit-background-clip: var(--list-marker-background-clip);
      -webkit-text-fill-color: var(--list-marker-text-fill-color);
      background-clip: var(--list-marker-background-clip);
      background-image: var(--list-marker-background-image);
      color: var(--list-marker-color);
      font-size: var(--list-marker-font-size);
      line-height: var(--list-marker-line-height);
      mix-blend-mode: var(--list-marker-mix-blend-mode);
      vertical-align: var(--list-marker-vertical-align);
    }

    /* .css-ol-marker is used in design-to-react */
    :is(.textContents ol, ol.textContents) > li::marker {
      color: var(--list-marker-color);
      font-size: var(--list-marker-font-size);
      line-height: var(--list-marker-line-height);
      vertical-align: var(--list-marker-vertical-align);
    }

    :is(.textContents, .textContents *).adjustLetterSpacing:after {
      content: '';
      margin-left: calc(var(--letter-spacing) * -1);
    }
  }
`; function Ts(e) {
  let { family: t, style: r, url: n, unicodeRange: o } = e; return `
@font-face {
  font-family: "${t}";
  font-style: ${r};
  src: url("${n}");
  font-display: block;
  ${o && o !== "*" ? `unicode-range: ${o};` : ""}
}
`} var BT = "My Site", VT = "Created with Figma"; var FT = /^(https?:)?\/\/(www\.)?lottie\.host\//; var Ot = I(W()), Gg = I(P()); var FL = I(W()); var Wr; (function (e) { e.EXPLICIT = "EXPLICIT", e.IMPLICIT = "IMPLICIT" })(Wr || (Wr = {})); var ni; (function (e) { e.LEFT = "LEFT", e.CENTER = "CENTER", e.RIGHT = "RIGHT" })(ni || (ni = {})); var oi; (function (e) { e.TOP = "TOP", e.CENTER = "CENTER", e.BOTTOM = "BOTTOM" })(oi || (oi = {})); var Wd; (function (e) { e.MODAL = "MODAL", e.BANNER = "BANNER" })(Wd || (Wd = {})); function ba() { return { color: "rgba(0, 0, 0, 0.9)", fontWeight: 450, fontSize: "var(--consent-font-size-medium)", lineHeight: "var(--consent-line-height-medium)" } } function Q3() { return { color: "rgba(0, 0, 0, 0.9)", fontWeight: 450, fontSize: "var(--consent-font-size-large)", lineHeight: "var(--consent-line-height-large)" } } function Z3() { return { fontWeight: 550 } } function zT() { return { ...ba(), cursor: "pointer", backgroundColor: "transparent" } } function _L() { return { ...Z3(), ...Q3() } } function Hg() { return { ...ba(), color: "rgba(0, 0, 0, 0.5)" } } function DL() { return { ...ba(), backgroundColor: "black", color: "white", border: "1px solid black", height: "1.5rem", borderRadius: ".3125rem", display: "flex", alignItems: "center", justifyContent: "center", padding: "0 .5rem", flexShrink: 0, flexGrow: 1, cursor: "pointer" } } function ML({ wide: e }) { return { display: "flex", gap: "0.5rem", flexShrink: 0, alignItems: "center", width: e ? "100%" : "auto" } } function Wg({ checked: e, disabled: t }) { return { input: { position: "absolute", opacity: 0, width: 32, height: 16, margin: 0, cursor: t ? "unset" : "pointer" }, label: { display: "block", width: 32, height: 16, borderRadius: 13, backgroundColor: e && !t ? "#1E1E1E" : "#E6E6E6", position: "relative", cursor: t ? "unset" : "pointer", transition: "background-color 0.4s", pointerEvents: "none" }, indicator: { position: "absolute", height: 14, width: 14, left: e ? 17 : 1, top: 1, backgroundColor: "white", borderRadius: "50%", transition: "left 0.4s", boxShadow: "0 2px 4px rgba(0,0,0,0.2)", pointerEvents: "none" } } } function BL({ yAlignment: e }) { let t = {}; return e === oi.TOP ? (t.top = 0, t.borderBottom = "1px solid #E6E6E6") : e === oi.BOTTOM && (t.bottom = 0, t.borderTop = "1px solid #E6E6E6"), { position: "fixed", left: 0, right: 0, display: "flex", padding: "var(--consent-banner-padding)", justifyContent: "center", alignItems: "center", gap: "1rem", alignSelf: "stretch", backgroundColor: "white", color: "rgba(0, 0, 0, 0.5)", zIndex: 9999, ...t } } function VL({ xAlignment: e, yAlignment: t }) { let r = {}; return e === ni.LEFT ? r.left = "1rem" : e === ni.RIGHT && (r.right = "1rem"), t === oi.TOP ? r.top = "1rem" : t === oi.BOTTOM && (r.bottom = "1rem"), { ...HT(), position: "fixed", padding: "1rem", zIndex: 1e4, ...r } } function HT() { return { position: "relative", backgroundColor: "white", borderRadius: ".8125rem", padding: "1rem", width: 330, maxHeight: "90%", maxWidth: "100%", boxShadow: "0px 0px 0px 1px rgba(0, 0, 0, 0.04), 0px 0px 0.5px 0px rgba(0, 0, 0, 0.12), 0px 10px 16px 0px rgba(0, 0, 0, 0.08), 0px 2px 6px 0px rgba(0, 0, 0, 0.12)", display: "flex", flexDirection: "column", alignItems: "center", gap: "1rem", overflowY: "auto" } } function Vc({ children: e, className: t, onClick: r }) { return (0, FL.jsx)("button", { className: t, onClick: r, style: DL(), children: e }) } var jn = I(W()); function J3({ checked: e, disabled: t, onChange: r, label: n, id: o }) { return (0, jn.jsxs)("div", { style: { display: "inline-block", position: "relative" }, children: [(0, jn.jsx)("input", { "aria-disabled": t, disabled: t, type: "checkbox", id: o, checked: e, onChange: i => r?.(i.target.checked), "aria-label": n, style: Wg({ checked: e, disabled: t }).input }), (0, jn.jsx)("label", { htmlFor: o, style: Wg({ checked: e, disabled: t }).label, children: (0, jn.jsx)("span", { style: Wg({ checked: e, disabled: t }).indicator }) })] }) } function WT({ id: e, checked: t, description: r, label: n, onChange: o, disabled: i }) { return (0, jn.jsxs)("div", { onClick: i ? void 0 : () => o(!t), style: { display: "flex", flexDirection: "column", padding: "0.5rem 0" }, children: [(0, jn.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: "0.5rem" }, children: [(0, jn.jsx)(J3, { checked: t, disabled: i, onChange: i ? void 0 : o, label: n, id: e }), (0, jn.jsx)("label", { style: { ...ba(), color: i ? "rgba(0, 0, 0, 0.3)" : "rgba(0, 0, 0, 0.9)" }, children: n })] }), (0, jn.jsx)("span", { style: { marginLeft: "2.5rem", ...Hg() }, children: r })] }) } var wa = I(W()), jT = I(P()), zL = I(il()); var jg = I(P()); function Ug(e) { let [t, r] = (0, jg.useState)(null); return (0, jg.useLayoutEffect)(() => { if (typeof document > "u") return; let n = e ? document.getElementById(e) : null; r(n || null) }, [e]), t } var eW = { position: "fixed", inset: 0, padding: "1rem", display: "flex", justifyContent: "center", alignItems: "center", zIndex: 1e4 }, tW = { display: "flex", justifyContent: "flex-end", position: "absolute", top: 16, right: 16, lineHeight: 1, cursor: "pointer" }, rW = { display: "flex", flexDirection: "column", gap: "0.5rem", width: "100%", height: "100%" }; function UT({ containerId: e, children: t, onClose: r, scrimBackground: n }) { let o = Ug(e); return (0, jT.useEffect)(() => { let i = s => { s.key === "Escape" && r() }; return document.addEventListener("keydown", i), () => { document.removeEventListener("keydown", i) } }, [r]), (0, jT.useEffect)(() => { let i = document.body.style.overflow; return o ? o.style.overflow = "hidden" : document.body.style.overflow = "hidden", () => { o ? o.style.overflow = i : document.body.style.overflow = i } }, [o]), (0, zL.createPortal)((0, wa.jsx)("div", { style: { ...eW, ...n ? { backgroundColor: "rgba(0, 0, 0, 0.1)" } : {} }, children: (0, wa.jsxs)("div", { style: HT(), children: [(0, wa.jsx)("div", { style: tW, children: (0, wa.jsx)("button", { "aria-label": "Close modal", style: { fontSize: "16px", color: "black", backgroundColor: "transparent", border: "none", cursor: "pointer" }, onClick: r, children: "\xD7" }) }), (0, wa.jsx)("div", { style: rW, children: t })] }) }), o || document.body) } var jd = I(W()); function GT({ policyLink: e, policyUrl: t, disclaimerText: r, guidToUrl: n, setLocation: o, reportError: i, isPreview: s }) { let a = c => { if (t) return (0, jd.jsx)("a", { rel: "noopener noreferrer", target: "_blank", href: t, style: zT(), children: c }, "policy-url"); if (e) { let u = s ? "/" : n?.get(e); return u ? (0, jd.jsx)("button", { onClick: () => { o({ url: u }) }, style: zT(), children: c }, "policy-link") : (i(new Error("Sites cookie banner has an invalid policy link or is missing guidToUrl")), null) } return s || i(new Error("Sites cookie banner is enabled but no policy internal link or external URL is set")), null }, l = r.split(/(<link>.*?<\/link>)/); return !l.length || !l.some(c => c.match(/<link>(.*?)<\/link>/)) ? (i(new Error(`Formatting error in cookie banner disclaimer text: ${r}`)), null) : (0, jd.jsx)("div", { style: { lineHeight: "var(--consent-font-size-medium)" }, children: l.map((c, u) => { let d = c.match(/<link>(.*?)<\/link>/); return d && d[1] ? a(d[1]) : (0, jd.jsx)("p", { style: { display: "inline", ...Hg() }, children: c }, u) }) }) } var HL = I(W()), Uge = I(P()), WL = I(il()); function $T({ containerId: e, xAlignment: t = ni.CENTER, yAlignment: r = oi.CENTER, children: n }) { let o = Ug(e); return (0, WL.createPortal)((0, HL.jsx)("div", { style: VL({ xAlignment: t, yAlignment: r }), children: n }), o || document.body) } var jL = I(W()); function nW({ xAlignment: e }) { let t = { bottom: 0 }; return e === ni.RIGHT ? t.right = "1.5rem" : t.left = "1.5rem", { ...ba(), position: "fixed", backgroundColor: "white", padding: ".5rem 1rem", cursor: "pointer", borderRadius: "0.3125rem 0.3125rem 0 0", boxShadow: "0px 0px 0.5px 0px rgba(0, 0, 0, 0.18), 0px 3px 8px 0px rgba(0, 0, 0, 0.10), 0px 1px 3px 0px rgba(0, 0, 0, 0.10)", ...t } } function KT({ children: e, onClick: t, xAlignment: r }) { return (0, jL.jsx)("button", { onClick: t, style: nW({ xAlignment: r }), children: e }) } var XT = { "en-US": { noticeHeader: "This site uses cookies", noticeDisclaimerImplicit: "Cookies on this site help improve your experience and deliver personalized content. By continuing to browse, you consent to the use of these cookies. <link>Read more</link>", acceptText: "Accept all", manageText: "Manage", noticeDisclaimerExplicit: "Cookies on this site help improve your experience and deliver personalized content. Click \u201CAccept all\u201D to consent to the use of these cookies. <link>Read more</link>", rejectText: "Reject all", manageHeader: "Manage cookie preferences", manageDisclaimer: "Cookies on this site help improve your experience and deliver personalized content. You can\u2019t opt out of cookies that are essential for basic functionality, but you can decide not to allow other categories according to your preferences. <link>Read more</link>", necessaryText: "Essential cookies", necessaryDescription: "Required to enable core site functionality and preferences.", marketingText: "Marketing cookies", marketingDescription: "Allow tracking to enable ads personalization and tracking.", preferencesText: "Personalization cookies", preferencesDescription: "Allow tracking to tailor your site experience to your interests.", analyticsText: "Analytics cookies", analyticsDescription: "Allow tracking of site traffic to help improve site performance.", saveLabel: "Save preferences", triggerLabel: "Cookie preferences" }, "en-GB": { noticeHeader: "This site uses cookies", noticeDisclaimerImplicit: "Cookies on this site help to improve your experience and deliver personalised content. By continuing to browse, you consent to the use of these cookies. <link>Read more</link>", acceptText: "Accept all", manageText: "Manage", noticeDisclaimerExplicit: "Cookies on this site help to improve your experience and deliver personalised content. Click \u2018Accept all\u2019 to consent to the use of these cookies. <link>Read more</link>", rejectText: "Reject all", manageHeader: "Manage cookie preferences", manageDisclaimer: "Cookies on this site help to improve your experience and deliver personalised content. You cannot opt out of cookies that are essential for basic functionality, but you can choose not to allow other categories according to your preferences. <link>Read more</link>", necessaryText: "Essential cookies", necessaryDescription: "Required to enable core site functionality and store your preferences.", marketingText: "Marketing cookies", marketingDescription: "Allow tracking to enable advertising personalisation and performance measurement.", preferencesText: "Personalisation cookies", preferencesDescription: "Allow tracking to tailor your site experience based on your interests.", analyticsText: "Analytics cookies", analyticsDescription: "Allow tracking of site usage to help improve performance.", saveLabel: "Save preferences", triggerLabel: "Cookie preferences" }, "fr-FR": { noticeHeader: "Ce site utilise des cookies", noticeDisclaimerImplicit: "Les cookies pr\xE9sents sur ce site am\xE9liorent votre exp\xE9rience et fournissent un contenu personnalis\xE9. En continuant \xE0 naviguer, vous consentez \xE0 l'utilisation de ces cookies. <link>En savoir plus</link>", acceptText: "Tout accepter", manageText: "G\xE9rer", noticeDisclaimerExplicit: "Les cookies pr\xE9sents sur ce site am\xE9liorent votre exp\xE9rience et fournissent un contenu personnalis\xE9. Cliquez sur \u201CTout accepter\u201D pour consentir \xE0 l'utilisation de ces cookies. <link>En savoir plus</link>", rejectText: "Tout refuser", manageHeader: "G\xE9rer les pr\xE9f\xE9rences de cookies", manageDisclaimer: "Les cookies pr\xE9sents sur ce site am\xE9liorent votre exp\xE9rience et fournissent un contenu personnalis\xE9. Vous ne pouvez pas d\xE9sactiver les cookies essentiels au bon fonctionnement du site, mais vous pouvez choisir de ne pas autoriser certaines autres cat\xE9gories selon vos pr\xE9f\xE9rences. <link>En savoir plus</link>", necessaryText: "Cookies essentiels", necessaryDescription: "N\xE9cessaires pour activer les fonctionnalit\xE9s principales du site et m\xE9moriser vos pr\xE9f\xE9rences.", marketingText: "Cookies marketing", marketingDescription: "Autoriser le suivi pour personnaliser les publicit\xE9s et le marketing.", preferencesText: "Cookies de personnalisation", preferencesDescription: "Autoriser le suivi pour adapter l\u2019exp\xE9rience du site \xE0 vos centres d\u2019int\xE9r\xEAt.", analyticsText: "Cookies d\u2019analyse", analyticsDescription: "Autoriser le suivi du trafic du site pour am\xE9liorer ses performances.", saveLabel: "Enregistrer les pr\xE9f\xE9rences", triggerLabel: "Pr\xE9f\xE9rences de cookies" }, "de-DE": { noticeHeader: "Diese Website verwendet Cookies", noticeDisclaimerImplicit: "Cookies auf dieser Website helfen dabei, Ihr Nutzungserlebnis zu verbessern und personalisierte Inhalte bereitzustellen. Wenn Sie weiter surfen, stimmen Sie der Verwendung dieser Cookies zu. <link>Mehr erfahren</link>", acceptText: "Alle akzeptieren", manageText: "Verwalten", noticeDisclaimerExplicit: "Cookies auf dieser Website helfen dabei, Ihr Nutzungserlebnis zu verbessern und personalisierte Inhalte bereitzustellen. Klicken Sie auf \u201EAlle akzeptieren\u201C, um der Verwendung dieser Cookies zuzustimmen. <link>Mehr erfahren</link>", rejectText: "Alle ablehnen", manageHeader: "Cookie-Einstellungen verwalten", manageDisclaimer: "Cookies auf dieser Website helfen dabei, Ihr Nutzungserlebnis zu verbessern und personalisierte Inhalte bereitzustellen. Sie k\xF6nnen essenzielle Cookies, die f\xFCr die grundlegende Funktionalit\xE4t erforderlich sind, nicht deaktivieren, aber Sie k\xF6nnen andere Kategorien nach Ihren Pr\xE4ferenzen ablehnen. <link>Mehr erfahren</link>", necessaryText: "Essenzielle Cookies", necessaryDescription: "Erforderlich zur Aktivierung der grundlegenden Website-Funktionen und zur Speicherung Ihrer Einstellungen.", marketingText: "Marketing-Cookies", marketingDescription: "Erlauben das Tracking zur Personalisierung von Werbung und zur Erfolgsmessung.", preferencesText: "Personalisierungs-Cookies", preferencesDescription: "Erlauben das Tracking, um Inhalte und Erlebnisse an Ihre Interessen anzupassen.", analyticsText: "Analyse-Cookies", analyticsDescription: "Erlauben das Tracking der Website-Nutzung zur Verbesserung der Leistung.", saveLabel: "Einstellungen speichern", triggerLabel: "Cookie-Einstellungen" }, "es-ES": { noticeHeader: "Este sitio web utiliza cookies", noticeDisclaimerImplicit: "Las cookies en este sitio web ayudan a mejorar su experiencia y a ofrecer contenido personalizado. Al continuar navegando, acepta el uso de estas cookies. <link>Leer m\xE1s</link>", acceptText: "Aceptar todas", manageText: "Gestionar", noticeDisclaimerExplicit: "Las cookies en este sitio web ayudan a mejorar su experiencia y a ofrecer contenido personalizado. Haga clic en \u201CAceptar todas\u201D para consentir el uso de estas cookies. <link>Leer m\xE1s</link>", rejectText: "Rechazar todas", manageHeader: "Gestionar preferencias de cookies", manageDisclaimer: "Las cookies en este sitio web ayudan a mejorar su experiencia y a ofrecer contenido personalizado. No puede rechazar las cookies esenciales para el funcionamiento b\xE1sico, pero puede decidir no permitir otras categor\xEDas seg\xFAn sus preferencias. <link>Leer m\xE1s</link>", necessaryText: "Cookies esenciales", necessaryDescription: "Necesarias para activar las funciones b\xE1sicas del sitio y guardar sus preferencias.", marketingText: "Cookies de marketing", marketingDescription: "Permiten el seguimiento para personalizar la publicidad y medir su rendimiento.", preferencesText: "Cookies de personalizaci\xF3n", preferencesDescription: "Permiten el seguimiento para adaptar el sitio a sus intereses.", analyticsText: "Cookies de an\xE1lisis", analyticsDescription: "Permiten el seguimiento del uso del sitio para mejorar su rendimiento.", saveLabel: "Guardar preferencias", triggerLabel: "Preferencias de cookies" }, "es-LA": { noticeHeader: "Este sitio utiliza cookies", noticeDisclaimerImplicit: "Las cookies en este sitio ayudan a mejorar su experiencia y a ofrecer contenido personalizado. Al seguir navegando, usted acepta el uso de estas cookies. <link>Leer m\xE1s</link>", acceptText: "Aceptar todas", manageText: "Administrar", noticeDisclaimerExplicit: "Las cookies en este sitio ayudan a mejorar su experiencia y a ofrecer contenido personalizado. Haga clic en \u201CAceptar todas\u201D para aceptar el uso de estas cookies. <link>Leer m\xE1s</link>", rejectText: "Rechazar todas", manageHeader: "Administrar preferencias de cookies", manageDisclaimer: "Las cookies en este sitio ayudan a mejorar su experiencia y a ofrecer contenido personalizado. No puede rechazar las cookies esenciales para el funcionamiento b\xE1sico, pero puede elegir no permitir otras categor\xEDas seg\xFAn sus preferencias. <link>Leer m\xE1s</link>", necessaryText: "Cookies esenciales", necessaryDescription: "Necesarias para habilitar funciones b\xE1sicas del sitio y guardar sus preferencias.", marketingText: "Cookies de marketing", marketingDescription: "Permiten el rastreo para personalizar anuncios y medir su rendimiento.", preferencesText: "Cookies de personalizaci\xF3n", preferencesDescription: "Permiten el rastreo para adaptar su experiencia seg\xFAn sus intereses.", analyticsText: "Cookies de an\xE1lisis", analyticsDescription: "Permiten el rastreo del uso del sitio para mejorar el rendimiento.", saveLabel: "Guardar preferencias", triggerLabel: "Preferencias de cookies" }, "pt-BR": { noticeHeader: "Este site utiliza cookies", noticeDisclaimerImplicit: "Os cookies neste site ajudam a melhorar sua experi\xEAncia e a oferecer conte\xFAdo personalizado. Ao continuar navegando, voc\xEA concorda com o uso desses cookies. <link>Saiba mais</link>", acceptText: "Aceitar todos", manageText: "Gerenciar", noticeDisclaimerExplicit: "Os cookies neste site ajudam a melhorar sua experi\xEAncia e a oferecer conte\xFAdo personalizado. Clique em \u201CAceitar todos\u201D para consentir com o uso desses cookies. <link>Saiba mais</link>", rejectText: "Rejeitar todos", manageHeader: "Gerenciar prefer\xEAncias de cookies", manageDisclaimer: "Os cookies neste site ajudam a melhorar sua experi\xEAncia e a oferecer conte\xFAdo personalizado. N\xE3o \xE9 poss\xEDvel desativar os cookies essenciais para o funcionamento b\xE1sico, mas voc\xEA pode optar por n\xE3o permitir outras categorias de acordo com suas prefer\xEAncias. <link>Saiba mais</link>", necessaryText: "Cookies essenciais", necessaryDescription: "Necess\xE1rios para ativar funcionalidades principais do site e salvar suas prefer\xEAncias.", marketingText: "Cookies de marketing", marketingDescription: "Permitem o rastreamento para personalizar an\xFAncios e medir seu desempenho.", preferencesText: "Cookies de personaliza\xE7\xE3o", preferencesDescription: "Permitem o rastreamento para adaptar a experi\xEAncia do site aos seus interesses.", analyticsText: "Cookies de an\xE1lise", analyticsDescription: "Permitem o rastreamento do uso do site para melhorar seu desempenho.", saveLabel: "Salvar prefer\xEAncias", triggerLabel: "Prefer\xEAncias de cookies" }, "ko-KR": { noticeHeader: "\uC774 \uC0AC\uC774\uD2B8\uB294 \uCFE0\uD0A4\uB97C \uC0AC\uC6A9\uD569\uB2C8\uB2E4", noticeDisclaimerImplicit: "\uC774 \uC0AC\uC774\uD2B8\uC758 \uCFE0\uD0A4\uB294 \uC0AC\uC6A9\uC790 \uACBD\uD5D8\uC744 \uAC1C\uC120\uD558\uACE0 \uAC1C\uC778\uD654\uB41C \uCF58\uD150\uCE20\uB97C \uC81C\uACF5\uD569\uB2C8\uB2E4. \uACC4\uC18D \uD0D0\uC0C9\uD558\uBA74 \uC774\uB7EC\uD55C \uCFE0\uD0A4 \uC0AC\uC6A9\uC5D0 \uB3D9\uC758\uD558\uB294 \uAC83\uC73C\uB85C \uAC04\uC8FC\uB429\uB2C8\uB2E4. <link>\uC790\uC138\uD788 \uC54C\uC544\uBCF4\uAE30</link>", acceptText: "\uBAA8\uB450 \uD5C8\uC6A9", manageText: "\uAD00\uB9AC", noticeDisclaimerExplicit: "\uC774 \uC0AC\uC774\uD2B8\uC758 \uCFE0\uD0A4\uB294 \uC0AC\uC6A9\uC790 \uACBD\uD5D8\uC744 \uAC1C\uC120\uD558\uACE0 \uAC1C\uC778\uD654\uB41C \uCF58\uD150\uCE20\uB97C \uC81C\uACF5\uD569\uB2C8\uB2E4. \u201C\uBAA8\uB450 \uD5C8\uC6A9\u201D\uC744 \uD074\uB9AD\uD558\uBA74 \uCFE0\uD0A4 \uC0AC\uC6A9\uC5D0 \uB3D9\uC758\uD558\uAC8C \uB429\uB2C8\uB2E4. <link>\uC790\uC138\uD788 \uC54C\uC544\uBCF4\uAE30</link>", rejectText: "\uBAA8\uB450 \uAC70\uBD80", manageHeader: "\uCFE0\uD0A4 \uD658\uACBD\uC124\uC815 \uAD00\uB9AC", manageDisclaimer: "\uC774 \uC0AC\uC774\uD2B8\uC758 \uCFE0\uD0A4\uB294 \uC0AC\uC6A9\uC790 \uACBD\uD5D8\uC744 \uAC1C\uC120\uD558\uACE0 \uAC1C\uC778\uD654\uB41C \uCF58\uD150\uCE20\uB97C \uC81C\uACF5\uD569\uB2C8\uB2E4. \uAE30\uBCF8 \uAE30\uB2A5\uC5D0 \uD544\uC218\uC801\uC778 \uCFE0\uD0A4\uB294 \uC120\uD0DD \uD574\uC81C\uD560 \uC218 \uC5C6\uC9C0\uB9CC, \uAE30\uD0C0 \uCE74\uD14C\uACE0\uB9AC\uB294 \uC124\uC815\uC5D0 \uB530\uB77C \uD5C8\uC6A9\uD558\uC9C0 \uC54A\uC744 \uC218 \uC788\uC2B5\uB2C8\uB2E4. <link>\uC790\uC138\uD788 \uC54C\uC544\uBCF4\uAE30</link>", necessaryText: "\uD544\uC218 \uCFE0\uD0A4", necessaryDescription: "\uD575\uC2EC \uC0AC\uC774\uD2B8 \uAE30\uB2A5 \uBC0F \uD658\uACBD\uC124\uC815 \uC720\uC9C0\uB97C \uC704\uD574 \uD544\uC694\uD569\uB2C8\uB2E4.", marketingText: "\uB9C8\uCF00\uD305 \uCFE0\uD0A4", marketingDescription: "\uAD11\uACE0 \uAC1C\uC778\uD654 \uBC0F \uCD94\uC801\uC744 \uC704\uD574 \uC0AC\uC6A9\uB429\uB2C8\uB2E4.", preferencesText: "\uAC1C\uC778\uD654 \uCFE0\uD0A4", preferencesDescription: "\uAD00\uC2EC\uC0AC\uC5D0 \uB9DE\uB294 \uCF58\uD150\uCE20 \uC81C\uACF5\uC744 \uC704\uD574 \uC0AC\uC6A9\uB429\uB2C8\uB2E4.", analyticsText: "\uBD84\uC11D \uCFE0\uD0A4", analyticsDescription: "\uC0AC\uC774\uD2B8 \uD2B8\uB798\uD53D \uBD84\uC11D \uBC0F \uC131\uB2A5 \uAC1C\uC120\uC744 \uC704\uD574 \uC0AC\uC6A9\uB429\uB2C8\uB2E4.", saveLabel: "\uD658\uACBD\uC124\uC815 \uC800\uC7A5", triggerLabel: "\uCFE0\uD0A4 \uD658\uACBD\uC124\uC815" }, "ja-JP": { noticeHeader: "\u3053\u306E\u30B5\u30A4\u30C8\u306F\u30AF\u30C3\u30AD\u30FC\u3092\u4F7F\u7528\u3057\u3066\u3044\u307E\u3059", noticeDisclaimerImplicit: "\u3053\u306E\u30B5\u30A4\u30C8\u3067\u306F\u3001\u30AF\u30C3\u30AD\u30FC\u3092\u4F7F\u7528\u3057\u3066\u30E6\u30FC\u30B6\u30FC\u4F53\u9A13\u3092\u5411\u4E0A\u3055\u305B\u3001\u30D1\u30FC\u30BD\u30CA\u30E9\u30A4\u30BA\u3055\u308C\u305F\u30B3\u30F3\u30C6\u30F3\u30C4\u3092\u63D0\u4F9B\u3057\u3066\u3044\u307E\u3059\u3002\u5F15\u304D\u7D9A\u304D\u95B2\u89A7\u3092\u7D9A\u3051\u308B\u3053\u3068\u3067\u3001\u30AF\u30C3\u30AD\u30FC\u306E\u4F7F\u7528\u306B\u540C\u610F\u3057\u305F\u3082\u306E\u3068\u307F\u306A\u3055\u308C\u307E\u3059\u3002<link>\u8A73\u7D30\u3092\u898B\u308B</link>", acceptText: "\u3059\u3079\u3066\u8A31\u53EF", manageText: "\u7BA1\u7406", noticeDisclaimerExplicit: "\u3053\u306E\u30B5\u30A4\u30C8\u3067\u306F\u3001\u30AF\u30C3\u30AD\u30FC\u3092\u4F7F\u7528\u3057\u3066\u30E6\u30FC\u30B6\u30FC\u4F53\u9A13\u3092\u5411\u4E0A\u3055\u305B\u3001\u30D1\u30FC\u30BD\u30CA\u30E9\u30A4\u30BA\u3055\u308C\u305F\u30B3\u30F3\u30C6\u30F3\u30C4\u3092\u63D0\u4F9B\u3057\u3066\u3044\u307E\u3059\u3002\u300C\u3059\u3079\u3066\u8A31\u53EF\u300D\u3092\u30AF\u30EA\u30C3\u30AF\u3059\u308B\u3068\u3001\u30AF\u30C3\u30AD\u30FC\u306E\u4F7F\u7528\u306B\u540C\u610F\u3057\u305F\u3053\u3068\u306B\u306A\u308A\u307E\u3059\u3002<link>\u8A73\u7D30\u3092\u898B\u308B</link>", rejectText: "\u3059\u3079\u3066\u62D2\u5426", manageHeader: "\u30AF\u30C3\u30AD\u30FC\u8A2D\u5B9A\u3092\u7BA1\u7406", manageDisclaimer: "\u3053\u306E\u30B5\u30A4\u30C8\u3067\u306F\u3001\u30AF\u30C3\u30AD\u30FC\u3092\u4F7F\u7528\u3057\u3066\u30E6\u30FC\u30B6\u30FC\u4F53\u9A13\u3092\u5411\u4E0A\u3055\u305B\u3001\u30D1\u30FC\u30BD\u30CA\u30E9\u30A4\u30BA\u3055\u308C\u305F\u30B3\u30F3\u30C6\u30F3\u30C4\u3092\u63D0\u4F9B\u3057\u3066\u3044\u307E\u3059\u3002\u57FA\u672C\u7684\u306A\u6A5F\u80FD\u306B\u5FC5\u8981\u306A\u30AF\u30C3\u30AD\u30FC\u306F\u7121\u52B9\u306B\u3067\u304D\u307E\u305B\u3093\u304C\u3001\u305D\u308C\u4EE5\u5916\u306E\u30AB\u30C6\u30B4\u30EA\u306B\u3064\u3044\u3066\u306F\u8A2D\u5B9A\u306B\u5FDC\u3058\u3066\u7121\u52B9\u306B\u3067\u304D\u307E\u3059\u3002<link>\u8A73\u7D30\u3092\u898B\u308B</link>", necessaryText: "\u5FC5\u9808\u30AF\u30C3\u30AD\u30FC", necessaryDescription: "\u30B5\u30A4\u30C8\u306E\u57FA\u672C\u6A5F\u80FD\u3068\u8A2D\u5B9A\u306E\u4FDD\u6301\u306B\u5FC5\u8981\u3067\u3059\u3002", marketingText: "\u30DE\u30FC\u30B1\u30C6\u30A3\u30F3\u30B0\u30AF\u30C3\u30AD\u30FC", marketingDescription: "\u5E83\u544A\u306E\u30D1\u30FC\u30BD\u30CA\u30E9\u30A4\u30BA\u3068\u8FFD\u8DE1\u3092\u8A31\u53EF\u3057\u307E\u3059\u3002", preferencesText: "\u30D1\u30FC\u30BD\u30CA\u30E9\u30A4\u30BA\u30AF\u30C3\u30AD\u30FC", preferencesDescription: "\u8208\u5473\u306B\u57FA\u3065\u3044\u305F\u4F53\u9A13\u3092\u63D0\u4F9B\u3059\u308B\u305F\u3081\u306B\u4F7F\u7528\u3055\u308C\u307E\u3059\u3002", analyticsText: "\u5206\u6790\u30AF\u30C3\u30AD\u30FC", analyticsDescription: "\u30B5\u30A4\u30C8\u306E\u5229\u7528\u72B6\u6CC1\u3092\u8FFD\u8DE1\u3057\u3066\u30D1\u30D5\u30A9\u30FC\u30DE\u30F3\u30B9\u3092\u5411\u4E0A\u3055\u305B\u307E\u3059\u3002", saveLabel: "\u8A2D\u5B9A\u3092\u4FDD\u5B58", triggerLabel: "\u30AF\u30C3\u30AD\u30FC\u8A2D\u5B9A" }, "pl-PL": { noticeHeader: "Ta strona korzysta z plik\xF3w cookie", noticeDisclaimerImplicit: "Pliki cookie na tej stronie pomagaj\u0105 ulepszy\u0107 Twoje do\u015Bwiadczenia i dostarcza\u0107 spersonalizowane tre\u015Bci. Kontynuuj\u0105c przegl\u0105danie, wyra\u017Casz zgod\u0119 na ich u\u017Cycie. <link>Dowiedz si\u0119 wi\u0119cej</link>", acceptText: "Zaakceptuj wszystkie", manageText: "Zarz\u0105dzaj", noticeDisclaimerExplicit: "Pliki cookie na tej stronie pomagaj\u0105 ulepszy\u0107 Twoje do\u015Bwiadczenia i dostarcza\u0107 spersonalizowane tre\u015Bci. Kliknij \u201EZaakceptuj wszystkie\u201D, aby wyrazi\u0107 zgod\u0119 na ich u\u017Cycie. <link>Dowiedz si\u0119 wi\u0119cej</link>", rejectText: "Odrzu\u0107 wszystkie", manageHeader: "Zarz\u0105dzaj preferencjami plik\xF3w cookie", manageDisclaimer: "Pliki cookie na tej stronie pomagaj\u0105 ulepszy\u0107 Twoje do\u015Bwiadczenia i dostarcza\u0107 spersonalizowane tre\u015Bci. Nie mo\u017Cesz zrezygnowa\u0107 z plik\xF3w cookie niezb\u0119dnych do podstawowego dzia\u0142ania witryny, ale mo\u017Cesz odrzuci\u0107 inne kategorie wed\u0142ug w\u0142asnych preferencji. <link>Dowiedz si\u0119 wi\u0119cej</link>", necessaryText: "Niezb\u0119dne pliki cookie", necessaryDescription: "Wymagane do dzia\u0142ania podstawowych funkcji witryny i zapami\u0119tywania ustawie\u0144.", marketingText: "Pliki cookie marketingowe", marketingDescription: "Pozwalaj\u0105 na \u015Bledzenie w celu personalizacji reklam i pomiaru skuteczno\u015Bci.", preferencesText: "Pliki cookie personalizuj\u0105ce", preferencesDescription: "Pozwalaj\u0105 na dostosowanie tre\u015Bci do Twoich zainteresowa\u0144.", analyticsText: "Pliki cookie analityczne", analyticsDescription: "Pozwalaj\u0105 na analiz\u0119 ruchu i popraw\u0119 wydajno\u015Bci witryny.", saveLabel: "Zapisz preferencje", triggerLabel: "Preferencje plik\xF3w cookie" }, "nl-NL": { noticeHeader: "Deze website maakt gebruik van cookies", noticeDisclaimerImplicit: "Cookies op deze website helpen uw ervaring te verbeteren en gepersonaliseerde inhoud aan te bieden. Door verder te gaan, stemt u in met het gebruik van deze cookies. <link>Meer informatie</link>", acceptText: "Alles accepteren", manageText: "Beheren", noticeDisclaimerExplicit: "Cookies op deze website helpen uw ervaring te verbeteren en gepersonaliseerde inhoud aan te bieden. Klik op \u201CAlles accepteren\u201D om in te stemmen met het gebruik van deze cookies. <link>Meer informatie</link>", rejectText: "Alles weigeren", manageHeader: "Cookievoorkeuren beheren", manageDisclaimer: "Cookies op deze website helpen uw ervaring te verbeteren en gepersonaliseerde inhoud aan te bieden. U kunt essenti\xEBle cookies, die nodig zijn voor de basisfunctionaliteit, niet uitschakelen, maar u kunt andere categorie\xEBn weigeren op basis van uw voorkeuren. <link>Meer informatie</link>", necessaryText: "Essenti\xEBle cookies", necessaryDescription: "Noodzakelijk voor de kernfunctionaliteit van de site en het opslaan van uw voorkeuren.", marketingText: "Marketingcookies", marketingDescription: "Sta tracking toe voor gepersonaliseerde advertenties en het meten van prestaties.", preferencesText: "Personalisatiecookies", preferencesDescription: "Sta tracking toe om de site-ervaring aan te passen aan uw interesses.", analyticsText: "Analysecookies", analyticsDescription: "Sta tracking toe om sitegebruik te analyseren en prestaties te verbeteren.", saveLabel: "Voorkeuren opslaan", triggerLabel: "Cookievoorkeuren" }, "it-IT": { noticeHeader: "Questo sito utilizza i cookie", noticeDisclaimerImplicit: "I cookie su questo sito aiutano a migliorare la tua esperienza e a fornire contenuti personalizzati. Continuando a navigare, acconsenti all\u2019uso dei cookie. <link>Scopri di pi\xF9</link>", acceptText: "Accetta tutti", manageText: "Gestisci", noticeDisclaimerExplicit: "I cookie su questo sito aiutano a migliorare la tua esperienza e a fornire contenuti personalizzati. Clicca su \u201CAccetta tutti\u201D per acconsentire all\u2019uso dei cookie. <link>Scopri di pi\xF9</link>", rejectText: "Rifiuta tutti", manageHeader: "Gestisci preferenze cookie", manageDisclaimer: "I cookie su questo sito aiutano a migliorare la tua esperienza e a fornire contenuti personalizzati. Non puoi disattivare i cookie essenziali per il funzionamento di base, ma puoi scegliere di non consentire altre categorie secondo le tue preferenze. <link>Scopri di pi\xF9</link>", necessaryText: "Cookie essenziali", necessaryDescription: "Necessari per il funzionamento base del sito e il salvataggio delle preferenze.", marketingText: "Cookie di marketing", marketingDescription: "Consentono il tracciamento per la personalizzazione degli annunci e la misurazione delle prestazioni.", preferencesText: "Cookie di personalizzazione", preferencesDescription: "Consentono il tracciamento per personalizzare l\u2019esperienza in base ai tuoi interessi.", analyticsText: "Cookie di analisi", analyticsDescription: "Consentono il tracciamento dell\u2019uso del sito per migliorarne le prestazioni.", saveLabel: "Salva preferenze", triggerLabel: "Preferenze cookie" }, "pt-PT": { noticeHeader: "Este site utiliza cookies", noticeDisclaimerImplicit: "Os cookies neste site ajudam a melhorar a sua experi\xEAncia e a fornecer conte\xFAdo personalizado. Ao continuar a navegar, est\xE1 a consentir a utiliza\xE7\xE3o destes cookies. <link>Saiba mais</link>", acceptText: "Aceitar todos", manageText: "Gerir", noticeDisclaimerExplicit: "Os cookies neste site ajudam a melhorar a sua experi\xEAncia e a fornecer conte\xFAdo personalizado. Clique em \u201CAceitar todos\u201D para consentir a utiliza\xE7\xE3o destes cookies. <link>Saiba mais</link>", rejectText: "Rejeitar todos", manageHeader: "Gerir prefer\xEAncias de cookies", manageDisclaimer: "Os cookies neste site ajudam a melhorar a sua experi\xEAncia e a fornecer conte\xFAdo personalizado. N\xE3o pode desativar os cookies essenciais ao funcionamento b\xE1sico, mas pode recusar outras categorias de acordo com as suas prefer\xEAncias. <link>Saiba mais</link>", necessaryText: "Cookies essenciais", necessaryDescription: "Necess\xE1rios para ativar funcionalidades b\xE1sicas do site e guardar as suas prefer\xEAncias.", marketingText: "Cookies de marketing", marketingDescription: "Permitem a monitoriza\xE7\xE3o para personalizar an\xFAncios e medir o desempenho.", preferencesText: "Cookies de personaliza\xE7\xE3o", preferencesDescription: "Permitem a monitoriza\xE7\xE3o para adaptar a experi\xEAncia do site aos seus interesses.", analyticsText: "Cookies de an\xE1lise", analyticsDescription: "Permitem a monitoriza\xE7\xE3o da utiliza\xE7\xE3o do site para melhorar o desempenho.", saveLabel: "Guardar prefer\xEAncias", triggerLabel: "Prefer\xEAncias de cookies" }, "sv-SE": { noticeHeader: "Den h\xE4r webbplatsen anv\xE4nder cookies", noticeDisclaimerImplicit: "Cookies p\xE5 den h\xE4r webbplatsen hj\xE4lper till att f\xF6rb\xE4ttra din upplevelse och visa personligt inneh\xE5ll. Genom att forts\xE4tta surfa samtycker du till anv\xE4ndningen av cookies. <link>L\xE4s mer</link>", acceptText: "Acceptera alla", manageText: "Hantera", noticeDisclaimerExplicit: "Cookies p\xE5 den h\xE4r webbplatsen hj\xE4lper till att f\xF6rb\xE4ttra din upplevelse och visa personligt inneh\xE5ll. Klicka p\xE5 \u201DAcceptera alla\u201D f\xF6r att godk\xE4nna anv\xE4ndningen av cookies. <link>L\xE4s mer</link>", rejectText: "Avvisa alla", manageHeader: "Hantera cookieinst\xE4llningar", manageDisclaimer: "Cookies p\xE5 den h\xE4r webbplatsen hj\xE4lper till att f\xF6rb\xE4ttra din upplevelse och visa personligt inneh\xE5ll. Du kan inte v\xE4lja bort cookies som \xE4r n\xF6dv\xE4ndiga f\xF6r grundl\xE4ggande funktioner, men du kan v\xE4lja bort andra kategorier enligt dina preferenser. <link>L\xE4s mer</link>", necessaryText: "N\xF6dv\xE4ndiga cookies", necessaryDescription: "Kr\xE4vs f\xF6r grundl\xE4ggande funktionalitet och f\xF6r att spara inst\xE4llningar.", marketingText: "Marknadsf\xF6ringscookies", marketingDescription: "Till\xE5ter sp\xE5rning f\xF6r att anpassa annonser och m\xE4ta resultat.", preferencesText: "Personaliseringcookies", preferencesDescription: "Till\xE5ter sp\xE5rning f\xF6r att anpassa upplevelsen efter dina intressen.", analyticsText: "Analyscookies", analyticsDescription: "Till\xE5ter sp\xE5rning av anv\xE4ndning f\xF6r att f\xF6rb\xE4ttra prestanda.", saveLabel: "Spara inst\xE4llningar", triggerLabel: "Cookieinst\xE4llningar" }, "da-DK": { noticeHeader: "Dette websted bruger cookies", noticeDisclaimerImplicit: "Cookies p\xE5 dette websted hj\xE6lper med at forbedre din oplevelse og levere tilpasset indhold. Ved at forts\xE6tte med at bruge siden accepterer du brugen af cookies. <link>L\xE6s mere</link>", acceptText: "Accept\xE9r alle", manageText: "Administrer", noticeDisclaimerExplicit: 'Cookies p\xE5 dette websted hj\xE6lper med at forbedre din oplevelse og levere tilpasset indhold. Klik p\xE5 "Accept\xE9r alle" for at acceptere brugen af cookies. <link>L\xE6s mere</link>', rejectText: "Afvis alle", manageHeader: "Administrer cookieindstillinger", manageDisclaimer: "Cookies p\xE5 dette websted hj\xE6lper med at forbedre din oplevelse og levere tilpasset indhold. Du kan ikke frav\xE6lge cookies, der er n\xF8dvendige for grundl\xE6ggende funktioner, men du kan v\xE6lge at afvise andre kategorier efter dine pr\xE6ferencer. <link>L\xE6s mere</link>", necessaryText: "N\xF8dvendige cookies", necessaryDescription: "N\xF8dvendige for grundl\xE6ggende funktionalitet og for at gemme dine indstillinger.", marketingText: "Marketingcookies", marketingDescription: "Tillad sporing for at aktivere tilpasning af annoncer og sporing.", preferencesText: "Tilpasningscookies", preferencesDescription: "Tillad sporing for at tilpasse webstedet efter dine interesser.", analyticsText: "Analysecookies", analyticsDescription: "Tillad sporing af webstedstrafik for at forbedre webstedets effektivitet.", saveLabel: "Gem indstillinger", triggerLabel: "Cookieindstillinger" }, "fi-FI": { noticeHeader: "T\xE4m\xE4 sivusto k\xE4ytt\xE4\xE4 ev\xE4steit\xE4", noticeDisclaimerImplicit: "T\xE4m\xE4n sivuston ev\xE4steet parantavat k\xE4ytt\xF6kokemustasi ja tarjoavat personoitua sis\xE4lt\xF6\xE4. Jatkamalla selaamista hyv\xE4ksyt n\xE4iden ev\xE4steiden k\xE4yt\xF6n. <link>Lue lis\xE4\xE4</link>", acceptText: "Hyv\xE4ksy kaikki", manageText: "Hallitse", noticeDisclaimerExplicit: "T\xE4m\xE4n sivuston ev\xE4steet parantavat k\xE4ytt\xF6kokemustasi ja tarjoavat personoitua sis\xE4lt\xF6\xE4. Napsauta \u201DHyv\xE4ksy kaikki\u201D ev\xE4steiden k\xE4yt\xF6n hyv\xE4ksymiseksi. <link>Lue lis\xE4\xE4</link>", rejectText: "Hylk\xE4\xE4 kaikki", manageHeader: "Hallitse ev\xE4steasetuksia", manageDisclaimer: "T\xE4m\xE4n sivuston ev\xE4steet parantavat k\xE4ytt\xF6kokemustasi ja tarjoavat personoitua sis\xE4lt\xF6\xE4. V\xE4ltt\xE4m\xE4tt\xF6mi\xE4 ev\xE4steit\xE4 ei voi poistaa k\xE4yt\xF6st\xE4, mutta voit est\xE4\xE4 muita ev\xE4stetyyppej\xE4 omien mieltymystesi mukaan. <link>Lue lis\xE4\xE4</link>", necessaryText: "V\xE4ltt\xE4m\xE4tt\xF6m\xE4t ev\xE4steet", necessaryDescription: "Tarvitaan sivuston perustoimintojen mahdollistamiseen ja asetusten tallentamiseen.", marketingText: "Markkinointiev\xE4steet", marketingDescription: "Sallivat seurannan mainonnan personointia ja mittaamista varten.", preferencesText: "Personointiev\xE4steet", preferencesDescription: "Sallivat seurannan sivuston k\xE4ytt\xF6kokemuksen r\xE4\xE4t\xE4l\xF6intiin omien kiinnostuksen kohteidesi mukaan.", analyticsText: "Analytiikkaev\xE4steet", analyticsDescription: "Sallivat sivuston verkkoliikenteen seurannan sivuston suorituskyvyn parantamiseksi.", saveLabel: "Tallenna asetukset", triggerLabel: "Ev\xE4steasetukset" }, "cs-CZ": { noticeHeader: "Tato str\xE1nka pou\u017E\xEDv\xE1 soubory cookie", noticeDisclaimerImplicit: "Soubory cookie na t\xE9to str\xE1nce pom\xE1haj\xED zlep\u0161it va\u0161e zku\u0161enosti a poskytovat personalizovan\xFD obsah. Pokra\u010Dov\xE1n\xEDm v prohl\xED\u017Een\xED vyjad\u0159ujete souhlas s pou\u017E\xEDv\xE1n\xEDm t\u011Bchto soubor\u016F cookie. <link>V\xEDce informac\xED</link>", acceptText: "P\u0159ijmout v\u0161e", manageText: "Spravovat", noticeDisclaimerExplicit: "Soubory cookie na t\xE9to str\xE1nce pom\xE1haj\xED zlep\u0161it va\u0161e zku\u0161enosti a poskytovat personalizovan\xFD obsah. Kliknut\xEDm na \u201EP\u0159ijmout v\u0161e\u201C vyjad\u0159ujete souhlas s pou\u017E\xEDv\xE1n\xEDm t\u011Bchto soubor\u016F cookie. <link>V\xEDce informac\xED</link>", rejectText: "Odm\xEDtnout v\u0161e", manageHeader: "Spravovat p\u0159edvolby soubor\u016F cookie", manageDisclaimer: "Soubory cookie na t\xE9to str\xE1nce pom\xE1haj\xED zlep\u0161it va\u0161e zku\u0161enosti a poskytovat personalizovan\xFD obsah. Nelze odm\xEDtnout soubory cookie, kter\xE9 jsou nezbytn\xE9 pro z\xE1kladn\xED funk\u010Dnost, ale m\u016F\u017Eete se rozhodnout nepovolit ostatn\xED kategorie podle sv\xFDch p\u0159edvoleb. <link>V\xEDce informac\xED</link>", necessaryText: "Nezbytn\xE9 soubory cookie", necessaryDescription: "Vy\u017Eadov\xE1ny k umo\u017En\u011Bn\xED z\xE1kladn\xED funk\u010Dnosti a p\u0159edvoleb str\xE1nky.", marketingText: "Marketingov\xE9 soubory cookie", marketingDescription: "Umo\u017E\u0148uj\xED sledov\xE1n\xED za \xFA\u010Delem personalizace reklam a m\u011B\u0159en\xED jejich \xFA\u010Dinnosti.", preferencesText: "Personaliza\u010Dn\xED soubory cookie", preferencesDescription: "Umo\u017E\u0148uj\xED sledov\xE1n\xED za \xFA\u010Delem p\u0159izp\u016Fsoben\xED prost\u0159ed\xED webu va\u0161im z\xE1jm\u016Fm.", analyticsText: "Analytick\xE9 soubory cookie", analyticsDescription: "Umo\u017E\u0148uj\xED sledov\xE1n\xED n\xE1v\u0161t\u011Bvnosti webu pro zlep\u0161en\xED jeho v\xFDkonu.", saveLabel: "Ulo\u017Eit p\u0159edvolby", triggerLabel: "P\u0159edvolby soubor\u016F cookie" }, "hu-HU": { noticeHeader: "Ez a webhely cookie-kat haszn\xE1l", noticeDisclaimerImplicit: "Ez a webhely cookie-kat haszn\xE1l az \xE9lm\xE9ny jav\xEDt\xE1sa \xE9s a szem\xE9lyre szabott tartalom megjelen\xEDt\xE9se \xE9rdek\xE9ben. A b\xF6ng\xE9sz\xE9s folytat\xE1s\xE1val \xD6n elfogadja a cookie-k haszn\xE1lat\xE1t. <link>Tov\xE1bbi inform\xE1ci\xF3</link>", acceptText: "\xD6sszes elfogad\xE1sa", manageText: "Kezel\xE9s", noticeDisclaimerExplicit: "Ez a webhely cookie-kat haszn\xE1l az \xE9lm\xE9ny jav\xEDt\xE1sa \xE9s a szem\xE9lyre szabott tartalom megjelen\xEDt\xE9se \xE9rdek\xE9ben. Kattintson az \u201E\xD6sszes elfogad\xE1sa\u201D gombra a cookie-k haszn\xE1lat\xE1nak enged\xE9lyez\xE9s\xE9hez. <link>Tov\xE1bbi inform\xE1ci\xF3</link>", rejectText: "\xD6sszes elutas\xEDt\xE1sa", manageHeader: "Cookie-be\xE1ll\xEDt\xE1sok kezel\xE9se", manageDisclaimer: "Ez a webhely cookie-kat haszn\xE1l az \xE9lm\xE9ny jav\xEDt\xE1sa \xE9s a szem\xE9lyre szabott tartalom megjelen\xEDt\xE9se \xE9rdek\xE9ben. Az alapvet\u0151 funkci\xF3khoz sz\xFCks\xE9ges cookie-kat nem lehet letiltani, de a t\xF6bbi kateg\xF3ria enged\xE9lyez\xE9s\xE9t be\xE1ll\xEDthatja a saj\xE1t preferenci\xE1i szerint. <link>Tov\xE1bbi inform\xE1ci\xF3</link>", necessaryText: "Alapvet\u0151 cookie-k", necessaryDescription: "A webhely alapvet\u0151 funkci\xF3inak m\u0171k\xF6d\xE9s\xE9hez \xE9s a be\xE1ll\xEDt\xE1sok ment\xE9s\xE9hez sz\xFCks\xE9gesek.", marketingText: "Marketing cookie-k", marketingDescription: "Lehet\u0151v\xE9 teszik a nyomon k\xF6vet\xE9st a hirdet\xE9sek szem\xE9lyre szab\xE1s\xE1hoz \xE9s teljes\xEDtm\xE9ny\xFCk m\xE9r\xE9s\xE9hez.", preferencesText: "Szem\xE9lyre szab\xE1si cookie-k", preferencesDescription: "Lehet\u0151v\xE9 teszik a felhaszn\xE1l\xF3i \xE9lm\xE9ny \xE9rdekl\u0151d\xE9si k\xF6r\xF6k\xF6n alapul\xF3 szem\xE9lyre szab\xE1s\xE1t.", analyticsText: "Analitikai cookie-k", analyticsDescription: "A webhelyhaszn\xE1lat nyomon k\xF6vet\xE9s\xE9re \xE9s a teljes\xEDtm\xE9ny jav\xEDt\xE1s\xE1ra szolg\xE1lnak.", saveLabel: "Be\xE1ll\xEDt\xE1sok ment\xE9se", triggerLabel: "Cookie-be\xE1ll\xEDt\xE1sok" }, "el-GR": { noticeHeader: "\u0391\u03C5\u03C4\u03CC\u03C2 \u03BF \u03B9\u03C3\u03C4\u03CC\u03C4\u03BF\u03C0\u03BF\u03C2 \u03C7\u03C1\u03B7\u03C3\u03B9\u03BC\u03BF\u03C0\u03BF\u03B9\u03B5\u03AF cookies", noticeDisclaimerImplicit: "\u03A4\u03B1 cookies \u03C3\u03B5 \u03B1\u03C5\u03C4\u03CC\u03BD \u03C4\u03BF\u03BD \u03B9\u03C3\u03C4\u03CC\u03C4\u03BF\u03C0\u03BF \u03B2\u03BF\u03B7\u03B8\u03BF\u03CD\u03BD \u03C3\u03C4\u03B7 \u03B2\u03B5\u03BB\u03C4\u03AF\u03C9\u03C3\u03B7 \u03C4\u03B7\u03C2 \u03B5\u03BC\u03C0\u03B5\u03B9\u03C1\u03AF\u03B1\u03C2 \u03C3\u03B1\u03C2 \u03BA\u03B1\u03B9 \u03C3\u03C4\u03B7\u03BD \u03C0\u03B1\u03C1\u03BF\u03C7\u03AE \u03B5\u03BE\u03B1\u03C4\u03BF\u03BC\u03B9\u03BA\u03B5\u03C5\u03BC\u03AD\u03BD\u03BF\u03C5 \u03C0\u03B5\u03C1\u03B9\u03B5\u03C7\u03BF\u03BC\u03AD\u03BD\u03BF\u03C5. \u03A3\u03C5\u03BD\u03B5\u03C7\u03AF\u03B6\u03BF\u03BD\u03C4\u03B1\u03C2 \u03C4\u03B7\u03BD \u03C0\u03B5\u03C1\u03B9\u03AE\u03B3\u03B7\u03C3\u03B7, \u03B1\u03C0\u03BF\u03B4\u03AD\u03C7\u03B5\u03C3\u03C4\u03B5 \u03C4\u03B7 \u03C7\u03C1\u03AE\u03C3\u03B7 \u03C4\u03C9\u03BD cookies. <link>\u039C\u03AC\u03B8\u03B5\u03C4\u03B5 \u03C0\u03B5\u03C1\u03B9\u03C3\u03C3\u03CC\u03C4\u03B5\u03C1\u03B1</link>", acceptText: "\u0391\u03C0\u03BF\u03B4\u03BF\u03C7\u03AE \u03CC\u03BB\u03C9\u03BD", manageText: "\u0394\u03B9\u03B1\u03C7\u03B5\u03AF\u03C1\u03B9\u03C3\u03B7", noticeDisclaimerExplicit: "\u03A4\u03B1 cookies \u03C3\u03B5 \u03B1\u03C5\u03C4\u03CC\u03BD \u03C4\u03BF\u03BD \u03B9\u03C3\u03C4\u03CC\u03C4\u03BF\u03C0\u03BF \u03B2\u03BF\u03B7\u03B8\u03BF\u03CD\u03BD \u03C3\u03C4\u03B7 \u03B2\u03B5\u03BB\u03C4\u03AF\u03C9\u03C3\u03B7 \u03C4\u03B7\u03C2 \u03B5\u03BC\u03C0\u03B5\u03B9\u03C1\u03AF\u03B1\u03C2 \u03C3\u03B1\u03C2 \u03BA\u03B1\u03B9 \u03C3\u03C4\u03B7\u03BD \u03C0\u03B1\u03C1\u03BF\u03C7\u03AE \u03B5\u03BE\u03B1\u03C4\u03BF\u03BC\u03B9\u03BA\u03B5\u03C5\u03BC\u03AD\u03BD\u03BF\u03C5 \u03C0\u03B5\u03C1\u03B9\u03B5\u03C7\u03BF\u03BC\u03AD\u03BD\u03BF\u03C5. \u039A\u03AC\u03BD\u03C4\u03B5 \u03BA\u03BB\u03B9\u03BA \u03C3\u03C4\u03B7\u03BD \u03B5\u03C0\u03B9\u03BB\u03BF\u03B3\u03AE \u201C\u0391\u03C0\u03BF\u03B4\u03BF\u03C7\u03AE \u03CC\u03BB\u03C9\u03BD\u201D \u03B3\u03B9\u03B1 \u03BD\u03B1 \u03B4\u03CE\u03C3\u03B5\u03C4\u03B5 \u03C4\u03B7 \u03C3\u03C5\u03B3\u03BA\u03B1\u03C4\u03AC\u03B8\u03B5\u03C3\u03AE \u03C3\u03B1\u03C2 \u03C3\u03C4\u03B7 \u03C7\u03C1\u03AE\u03C3\u03B7 \u03C4\u03C9\u03BD cookies. <link>\u039C\u03AC\u03B8\u03B5\u03C4\u03B5 \u03C0\u03B5\u03C1\u03B9\u03C3\u03C3\u03CC\u03C4\u03B5\u03C1\u03B1</link>", rejectText: "\u0391\u03C0\u03CC\u03C1\u03C1\u03B9\u03C8\u03B7 \u03CC\u03BB\u03C9\u03BD", manageHeader: "\u0394\u03B9\u03B1\u03C7\u03B5\u03AF\u03C1\u03B9\u03C3\u03B7 \u03C0\u03C1\u03BF\u03C4\u03B9\u03BC\u03AE\u03C3\u03B5\u03C9\u03BD cookies", manageDisclaimer: "\u03A4\u03B1 cookies \u03C3\u03B5 \u03B1\u03C5\u03C4\u03CC\u03BD \u03C4\u03BF\u03BD \u03B9\u03C3\u03C4\u03CC\u03C4\u03BF\u03C0\u03BF \u03B2\u03BF\u03B7\u03B8\u03BF\u03CD\u03BD \u03C3\u03C4\u03B7 \u03B2\u03B5\u03BB\u03C4\u03AF\u03C9\u03C3\u03B7 \u03C4\u03B7\u03C2 \u03B5\u03BC\u03C0\u03B5\u03B9\u03C1\u03AF\u03B1\u03C2 \u03C3\u03B1\u03C2 \u03BA\u03B1\u03B9 \u03C3\u03C4\u03B7\u03BD \u03C0\u03B1\u03C1\u03BF\u03C7\u03AE \u03B5\u03BE\u03B1\u03C4\u03BF\u03BC\u03B9\u03BA\u03B5\u03C5\u03BC\u03AD\u03BD\u03BF\u03C5 \u03C0\u03B5\u03C1\u03B9\u03B5\u03C7\u03BF\u03BC\u03AD\u03BD\u03BF\u03C5. \u0394\u03B5\u03BD \u03BC\u03C0\u03BF\u03C1\u03B5\u03AF\u03C4\u03B5 \u03BD\u03B1 \u03B1\u03C0\u03BF\u03C1\u03C1\u03AF\u03C8\u03B5\u03C4\u03B5 \u03C4\u03B1 \u03B1\u03C0\u03BF\u03BB\u03CD\u03C4\u03C9\u03C2 \u03B1\u03C0\u03B1\u03C1\u03B1\u03AF\u03C4\u03B7\u03C4\u03B1 cookies, \u03B1\u03BB\u03BB\u03AC \u03BC\u03C0\u03BF\u03C1\u03B5\u03AF\u03C4\u03B5 \u03BD\u03B1 \u03B1\u03C0\u03B5\u03BD\u03B5\u03C1\u03B3\u03BF\u03C0\u03BF\u03B9\u03AE\u03C3\u03B5\u03C4\u03B5 \u03AC\u03BB\u03BB\u03B5\u03C2 \u03BA\u03B1\u03C4\u03B7\u03B3\u03BF\u03C1\u03AF\u03B5\u03C2 \u03C3\u03CD\u03BC\u03C6\u03C9\u03BD\u03B1 \u03BC\u03B5 \u03C4\u03B9\u03C2 \u03C0\u03C1\u03BF\u03C4\u03B9\u03BC\u03AE\u03C3\u03B5\u03B9\u03C2 \u03C3\u03B1\u03C2. <link>\u039C\u03AC\u03B8\u03B5\u03C4\u03B5 \u03C0\u03B5\u03C1\u03B9\u03C3\u03C3\u03CC\u03C4\u03B5\u03C1\u03B1</link>", necessaryText: "\u0391\u03C0\u03B1\u03C1\u03B1\u03AF\u03C4\u03B7\u03C4\u03B1 cookies", necessaryDescription: "\u0391\u03C0\u03B1\u03B9\u03C4\u03BF\u03CD\u03BD\u03C4\u03B1\u03B9 \u03B3\u03B9\u03B1 \u03B2\u03B1\u03C3\u03B9\u03BA\u03AD\u03C2 \u03BB\u03B5\u03B9\u03C4\u03BF\u03C5\u03C1\u03B3\u03AF\u03B5\u03C2 \u03C4\u03BF\u03C5 \u03B9\u03C3\u03C4\u03CC\u03C4\u03BF\u03C0\u03BF\u03C5 \u03BA\u03B1\u03B9 \u03B1\u03C0\u03BF\u03B8\u03AE\u03BA\u03B5\u03C5\u03C3\u03B7 \u03C0\u03C1\u03BF\u03C4\u03B9\u03BC\u03AE\u03C3\u03B5\u03C9\u03BD.", marketingText: "Cookies \u03BC\u03AC\u03C1\u03BA\u03B5\u03C4\u03B9\u03BD\u03B3\u03BA", marketingDescription: "\u0395\u03C0\u03B9\u03C4\u03C1\u03AD\u03C0\u03BF\u03C5\u03BD \u03C4\u03B7\u03BD \u03C0\u03B1\u03C1\u03B1\u03BA\u03BF\u03BB\u03BF\u03CD\u03B8\u03B7\u03C3\u03B7 \u03B3\u03B9\u03B1 \u03B5\u03BE\u03B1\u03C4\u03BF\u03BC\u03AF\u03BA\u03B5\u03C5\u03C3\u03B7 \u03B4\u03B9\u03B1\u03C6\u03B7\u03BC\u03AF\u03C3\u03B5\u03C9\u03BD \u03BA\u03B1\u03B9 \u03BC\u03AD\u03C4\u03C1\u03B7\u03C3\u03B7 \u03B1\u03C0\u03CC\u03B4\u03BF\u03C3\u03B7\u03C2.", preferencesText: "Cookies \u03B5\u03BE\u03B1\u03C4\u03BF\u03BC\u03AF\u03BA\u03B5\u03C5\u03C3\u03B7\u03C2", preferencesDescription: "\u0395\u03C0\u03B9\u03C4\u03C1\u03AD\u03C0\u03BF\u03C5\u03BD \u03C4\u03B7\u03BD \u03C0\u03B1\u03C1\u03B1\u03BA\u03BF\u03BB\u03BF\u03CD\u03B8\u03B7\u03C3\u03B7 \u03B3\u03B9\u03B1 \u03C0\u03C1\u03BF\u03C3\u03B1\u03C1\u03BC\u03BF\u03B3\u03AE \u03C4\u03B7\u03C2 \u03B5\u03BC\u03C0\u03B5\u03B9\u03C1\u03AF\u03B1\u03C2 \u03C3\u03CD\u03BC\u03C6\u03C9\u03BD\u03B1 \u03BC\u03B5 \u03C4\u03B1 \u03B5\u03BD\u03B4\u03B9\u03B1\u03C6\u03AD\u03C1\u03BF\u03BD\u03C4\u03AC \u03C3\u03B1\u03C2.", analyticsText: "Cookies \u03B1\u03BD\u03AC\u03BB\u03C5\u03C3\u03B7\u03C2", analyticsDescription: "\u0395\u03C0\u03B9\u03C4\u03C1\u03AD\u03C0\u03BF\u03C5\u03BD \u03C4\u03B7\u03BD \u03C0\u03B1\u03C1\u03B1\u03BA\u03BF\u03BB\u03BF\u03CD\u03B8\u03B7\u03C3\u03B7 \u03C4\u03B7\u03C2 \u03C7\u03C1\u03AE\u03C3\u03B7\u03C2 \u03C4\u03BF\u03C5 \u03B9\u03C3\u03C4\u03CC\u03C4\u03BF\u03C0\u03BF\u03C5 \u03B3\u03B9\u03B1 \u03C4\u03B7 \u03B2\u03B5\u03BB\u03C4\u03AF\u03C9\u03C3\u03B7 \u03C4\u03C9\u03BD \u03B5\u03C0\u03B9\u03B4\u03CC\u03C3\u03B5\u03C9\u03BD.", saveLabel: "\u0391\u03C0\u03BF\u03B8\u03AE\u03BA\u03B5\u03C5\u03C3\u03B7 \u03C0\u03C1\u03BF\u03C4\u03B9\u03BC\u03AE\u03C3\u03B5\u03C9\u03BD", triggerLabel: "\u03A0\u03C1\u03BF\u03C4\u03B9\u03BC\u03AE\u03C3\u03B5\u03B9\u03C2 cookies" }, "ro-RO": { noticeHeader: "Acest site folose\u0219te cookie-uri", noticeDisclaimerImplicit: "Cookie-urile de pe acest site ajut\u0103 la \xEEmbun\u0103t\u0103\u021Birea experien\u021Bei \u0219i la furnizarea de con\u021Binut personalizat. Continu\xE2nd navigarea, sunte\u021Bi de acord cu utilizarea cookie-urilor. <link>Citi\u021Bi mai multe</link>", acceptText: "Accepta\u021Bi toate", manageText: "Gestionare", noticeDisclaimerExplicit: "Cookie-urile de pe acest site ajut\u0103 la \xEEmbun\u0103t\u0103\u021Birea experien\u021Bei \u0219i la furnizarea de con\u021Binut personalizat. Face\u021Bi clic pe \u201EAccepta\u021Bi toate\u201D pentru a v\u0103 da consim\u021B\u0103m\xE2ntul pentru utilizarea cookie-urilor. <link>Citi\u021Bi mai multe</link>", rejectText: "Respinge\u021Bi toate", manageHeader: "Gestiona\u021Bi preferin\u021Bele legate de cookie", manageDisclaimer: "Cookie-urile de pe acest site ajut\u0103 la \xEEmbun\u0103t\u0103\u021Birea experien\u021Bei \u0219i la furnizarea de con\u021Binut personalizat. Nu pute\u021Bi refuza cookie-urile esen\u021Biale pentru func\u021Bionalitatea de baz\u0103, dar pute\u021Bi refuza alte categorii conform preferin\u021Belor dvs. <link>Citi\u021Bi mai multe</link>", necessaryText: "Cookie-uri esen\u021Biale", necessaryDescription: "Necesare pentru func\u021Biile de baz\u0103 ale site-ului \u0219i salvarea preferin\u021Belor.", marketingText: "Cookie-uri de marketing", marketingDescription: "Permit urm\u0103rirea pentru personalizarea \u0219i urm\u0103rirea reclamelor.", preferencesText: "Cookie-uri de personalizare", preferencesDescription: "Permit urm\u0103rirea pentru adaptarea experien\u021Bei de utilizare a site-ului la interesele dvs.", analyticsText: "Cookie-uri de analiz\u0103", analyticsDescription: "Permit urm\u0103rirea traficului de pe site pentru \xEEmbun\u0103t\u0103\u021Birea performan\u021Bei.", saveLabel: "Salva\u021Bi preferin\u021Bele", triggerLabel: "Preferin\u021Be legate de cookie" }, "sk-SK": { noticeHeader: "T\xE1to lokalita pou\u017E\xEDva s\xFAbory cookie", noticeDisclaimerImplicit: "S\xFAbory cookie na tejto lokalite pom\xE1haj\xFA zlep\u0161i\u0165 v\xE1\u0161 z\xE1\u017Eitok a poskytova\u0165 personalizovan\xFD obsah. Pokra\u010Dovan\xEDm v prehliadan\xED s\xFAhlas\xEDte s ich pou\u017E\xEDvan\xEDm. <link>Viac inform\xE1ci\xED</link>", acceptText: "Prija\u0165 v\u0161etky", manageText: "Spravova\u0165", noticeDisclaimerExplicit: "S\xFAbory cookie na tejto lokalite pom\xE1haj\xFA zlep\u0161i\u0165 v\xE1\u0161 z\xE1\u017Eitok a poskytova\u0165 personalizovan\xFD obsah. Kliknut\xEDm na tla\u010Didlo Prija\u0165 v\u0161etky s\xFAhlas\xEDte s ich pou\u017E\xEDvan\xEDm. <link>Viac inform\xE1ci\xED</link>", rejectText: "Odmietnu\u0165 v\u0161etky", manageHeader: "Spr\xE1va predvolieb s\xFAborov cookie", manageDisclaimer: "S\xFAbory cookie na tejto lokalite pom\xE1haj\xFA zlep\u0161i\u0165 v\xE1\u0161 z\xE1\u017Eitok a poskytova\u0165 personalizovan\xFD obsah. Nevyhnutn\xE9 s\xFAbory cookie, ktor\xE9 zabezpe\u010Duj\xFA z\xE1kladn\xE9 funkcie, nie je mo\u017En\xE9 zak\xE1za\u0165, ale in\xE9 kateg\xF3rie m\xF4\u017Eete zak\xE1za\u0165 pod\u013Ea svojich preferenci\xED. <link>Viac inform\xE1ci\xED</link>", necessaryText: "Nevyhnutn\xE9 s\xFAbory cookie", necessaryDescription: "Potrebn\xE9 na povolenie z\xE1kladn\xFDch funkci\xED lokality a predvolieb.", marketingText: "Marketingov\xE9 s\xFAbory cookie", marketingDescription: "Umo\u017E\u0148uj\xFA sledovanie na prisp\xF4sobenie a meranie v\xFDkonu rekl\xE1m.", preferencesText: "Personaliza\u010Dn\xE9 s\xFAbory cookie", preferencesDescription: "Umo\u017E\u0148uj\xFA sledovanie na prisp\xF4sobenie lokality pod\u013Ea va\u0161ich z\xE1ujmov.", analyticsText: "Analytick\xE9 s\xFAbory cookie", analyticsDescription: "Umo\u017E\u0148uj\xFA sledovanie pou\u017E\xEDvania lokality na zlep\u0161enie jej v\xFDkonnosti.", saveLabel: "Ulo\u017Ei\u0165 predvo\u013Eby", triggerLabel: "Predvo\u013Eby s\xFAborov cookie" }, "bg-BG": { noticeHeader: "\u0422\u043E\u0437\u0438 \u0441\u0430\u0439\u0442 \u0438\u0437\u043F\u043E\u043B\u0437\u0432\u0430 \u0431\u0438\u0441\u043A\u0432\u0438\u0442\u043A\u0438", noticeDisclaimerImplicit: "\u0411\u0438\u0441\u043A\u0432\u0438\u0442\u043A\u0438\u0442\u0435 \u043D\u0430 \u0442\u043E\u0437\u0438 \u0441\u0430\u0439\u0442 \u043F\u043E\u043C\u0430\u0433\u0430\u0442 \u0437\u0430 \u043F\u043E\u0434\u043E\u0431\u0440\u044F\u0432\u0430\u043D\u0435 \u043D\u0430 \u0432\u0430\u0448\u0435\u0442\u043E \u0438\u0437\u0436\u0438\u0432\u044F\u0432\u0430\u043D\u0435 \u0438 \u043F\u0440\u0435\u0434\u043E\u0441\u0442\u0430\u0432\u044F\u043D\u0435 \u043D\u0430 \u043F\u0435\u0440\u0441\u043E\u043D\u0430\u043B\u0438\u0437\u0438\u0440\u0430\u043D\u043E \u0441\u044A\u0434\u044A\u0440\u0436\u0430\u043D\u0438\u0435. \u041F\u0440\u043E\u0434\u044A\u043B\u0436\u0430\u0432\u0430\u0439\u043A\u0438 \u0434\u0430 \u0440\u0430\u0437\u0433\u043B\u0435\u0436\u0434\u0430\u0442\u0435, \u0432\u0438\u0435 \u0441\u0435 \u0441\u044A\u0433\u043B\u0430\u0441\u044F\u0432\u0430\u0442\u0435 \u0441 \u0438\u0437\u043F\u043E\u043B\u0437\u0432\u0430\u043D\u0435\u0442\u043E \u043D\u0430 \u0431\u0438\u0441\u043A\u0432\u0438\u0442\u043A\u0438. <link>\u041D\u0430\u0443\u0447\u0435\u0442\u0435 \u043F\u043E\u0432\u0435\u0447\u0435</link>", acceptText: "\u041F\u0440\u0438\u0435\u043C\u0430\u043C \u0432\u0441\u0438\u0447\u043A\u0438", manageText: "\u0423\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u0438\u0435", noticeDisclaimerExplicit: "\u0411\u0438\u0441\u043A\u0432\u0438\u0442\u043A\u0438\u0442\u0435 \u043D\u0430 \u0442\u043E\u0437\u0438 \u0441\u0430\u0439\u0442 \u043F\u043E\u043C\u0430\u0433\u0430\u0442 \u0437\u0430 \u043F\u043E\u0434\u043E\u0431\u0440\u044F\u0432\u0430\u043D\u0435 \u043D\u0430 \u0432\u0430\u0448\u0435\u0442\u043E \u0438\u0437\u0436\u0438\u0432\u044F\u0432\u0430\u043D\u0435 \u0438 \u043F\u0440\u0435\u0434\u043E\u0441\u0442\u0430\u0432\u044F\u043D\u0435 \u043D\u0430 \u043F\u0435\u0440\u0441\u043E\u043D\u0430\u043B\u0438\u0437\u0438\u0440\u0430\u043D\u043E \u0441\u044A\u0434\u044A\u0440\u0436\u0430\u043D\u0438\u0435. \u041D\u0430\u0442\u0438\u0441\u043D\u0435\u0442\u0435 \u201E\u041F\u0440\u0438\u0435\u043C\u0430\u043C \u0432\u0441\u0438\u0447\u043A\u0438\u201C, \u0437\u0430 \u0434\u0430 \u0441\u0435 \u0441\u044A\u0433\u043B\u0430\u0441\u0438\u0442\u0435 \u0441 \u0438\u0437\u043F\u043E\u043B\u0437\u0432\u0430\u043D\u0435\u0442\u043E \u043D\u0430 \u0431\u0438\u0441\u043A\u0432\u0438\u0442\u043A\u0438. <link>\u041D\u0430\u0443\u0447\u0435\u0442\u0435 \u043F\u043E\u0432\u0435\u0447\u0435</link>", rejectText: "\u041E\u0442\u043A\u0430\u0437\u0432\u0430\u043C \u0432\u0441\u0438\u0447\u043A\u0438", manageHeader: "\u0423\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u0438\u0435 \u043D\u0430 \u043F\u0440\u0435\u0434\u043F\u043E\u0447\u0438\u0442\u0430\u043D\u0438\u044F\u0442\u0430 \u0437\u0430 \u0431\u0438\u0441\u043A\u0432\u0438\u0442\u043A\u0438", manageDisclaimer: "\u0411\u0438\u0441\u043A\u0432\u0438\u0442\u043A\u0438\u0442\u0435 \u043D\u0430 \u0442\u043E\u0437\u0438 \u0441\u0430\u0439\u0442 \u043F\u043E\u043C\u0430\u0433\u0430\u0442 \u0437\u0430 \u043F\u043E\u0434\u043E\u0431\u0440\u044F\u0432\u0430\u043D\u0435 \u043D\u0430 \u0432\u0430\u0448\u0435\u0442\u043E \u0438\u0437\u0436\u0438\u0432\u044F\u0432\u0430\u043D\u0435 \u0438 \u043F\u0440\u0435\u0434\u043E\u0441\u0442\u0430\u0432\u044F\u043D\u0435 \u043D\u0430 \u043F\u0435\u0440\u0441\u043E\u043D\u0430\u043B\u0438\u0437\u0438\u0440\u0430\u043D\u043E \u0441\u044A\u0434\u044A\u0440\u0436\u0430\u043D\u0438\u0435. \u041D\u0435 \u043C\u043E\u0436\u0435\u0442\u0435 \u0434\u0430 \u0441\u0435 \u043E\u0442\u043A\u0430\u0436\u0435\u0442\u0435 \u043E\u0442 \u043E\u0441\u043D\u043E\u0432\u043D\u0438\u0442\u0435 \u0431\u0438\u0441\u043A\u0432\u0438\u0442\u043A\u0438, \u043D\u0435\u043E\u0431\u0445\u043E\u0434\u0438\u043C\u0438 \u0437\u0430 \u0440\u0430\u0431\u043E\u0442\u0430\u0442\u0430 \u043D\u0430 \u0441\u0430\u0439\u0442\u0430, \u043D\u043E \u043C\u043E\u0436\u0435\u0442\u0435 \u0434\u0430 \u0438\u0437\u043A\u043B\u044E\u0447\u0438\u0442\u0435 \u0434\u0440\u0443\u0433\u0438 \u043A\u0430\u0442\u0435\u0433\u043E\u0440\u0438\u0438 \u0441\u043F\u043E\u0440\u0435\u0434 \u0432\u0430\u0448\u0438\u0442\u0435 \u043F\u0440\u0435\u0434\u043F\u043E\u0447\u0438\u0442\u0430\u043D\u0438\u044F. <link>\u041D\u0430\u0443\u0447\u0435\u0442\u0435 \u043F\u043E\u0432\u0435\u0447\u0435</link>", necessaryText: "\u0417\u0430\u0434\u044A\u043B\u0436\u0438\u0442\u0435\u043B\u043D\u0438 \u0431\u0438\u0441\u043A\u0432\u0438\u0442\u043A\u0438", necessaryDescription: "\u041D\u0435\u043E\u0431\u0445\u043E\u0434\u0438\u043C\u0438 \u0437\u0430 \u043E\u0441\u043D\u043E\u0432\u043D\u0438\u0442\u0435 \u0444\u0443\u043D\u043A\u0446\u0438\u0438 \u043D\u0430 \u0441\u0430\u0439\u0442\u0430 \u0438 \u0437\u0430\u043F\u0430\u0437\u0432\u0430\u043D\u0435 \u043D\u0430 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438\u0442\u0435.", marketingText: "\u041C\u0430\u0440\u043A\u0435\u0442\u0438\u043D\u0433\u043E\u0432\u0438 \u0431\u0438\u0441\u043A\u0432\u0438\u0442\u043A\u0438", marketingDescription: "\u041F\u043E\u0437\u0432\u043E\u043B\u044F\u0432\u0430\u0442 \u043F\u0440\u043E\u0441\u043B\u0435\u0434\u044F\u0432\u0430\u043D\u0435 \u0437\u0430 \u043F\u0435\u0440\u0441\u043E\u043D\u0430\u043B\u0438\u0437\u0438\u0440\u0430\u043D\u0430 \u0440\u0435\u043A\u043B\u0430\u043C\u0430 \u0438 \u0438\u0437\u043C\u0435\u0440\u0432\u0430\u043D\u0435 \u043D\u0430 \u0435\u0444\u0435\u043A\u0442\u0438\u0432\u043D\u043E\u0441\u0442\u0442\u0430.", preferencesText: "\u0411\u0438\u0441\u043A\u0432\u0438\u0442\u043A\u0438 \u0437\u0430 \u043F\u0435\u0440\u0441\u043E\u043D\u0430\u043B\u0438\u0437\u0430\u0446\u0438\u044F", preferencesDescription: "\u041F\u043E\u0437\u0432\u043E\u043B\u044F\u0432\u0430\u0442 \u043F\u0440\u043E\u0441\u043B\u0435\u0434\u044F\u0432\u0430\u043D\u0435 \u0437\u0430 \u043F\u0435\u0440\u0441\u043E\u043D\u0430\u043B\u0438\u0437\u0438\u0440\u0430\u043D\u0435 \u043D\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430\u043D\u0438\u0435\u0442\u043E \u0441\u043F\u043E\u0440\u0435\u0434 \u0432\u0430\u0448\u0438\u0442\u0435 \u0438\u043D\u0442\u0435\u0440\u0435\u0441\u0438.", analyticsText: "\u0410\u043D\u0430\u043B\u0438\u0442\u0438\u0447\u043D\u0438 \u0431\u0438\u0441\u043A\u0432\u0438\u0442\u043A\u0438", analyticsDescription: "\u041F\u043E\u0437\u0432\u043E\u043B\u044F\u0432\u0430\u0442 \u043F\u0440\u043E\u0441\u043B\u0435\u0434\u044F\u0432\u0430\u043D\u0435 \u043D\u0430 \u0443\u043F\u043E\u0442\u0440\u0435\u0431\u0430\u0442\u0430 \u043D\u0430 \u0441\u0430\u0439\u0442\u0430 \u0437\u0430 \u043F\u043E\u0434\u043E\u0431\u0440\u044F\u0432\u0430\u043D\u0435 \u043D\u0430 \u043F\u0440\u043E\u0438\u0437\u0432\u043E\u0434\u0438\u0442\u0435\u043B\u043D\u043E\u0441\u0442\u0442\u0430.", saveLabel: "\u0417\u0430\u043F\u0430\u0437\u0438 \u043F\u0440\u0435\u0434\u043F\u043E\u0447\u0438\u0442\u0430\u043D\u0438\u044F\u0442\u0430", triggerLabel: "\u041F\u0440\u0435\u0434\u043F\u043E\u0447\u0438\u0442\u0430\u043D\u0438\u044F \u0437\u0430 \u0431\u0438\u0441\u043A\u0432\u0438\u0442\u043A\u0438" } }, UL = XT["en-US"]; var Un = I(P()); var oW = ["US", "AU", "HK", "ID", "KE", "MX", "NZ", "NG", "PH", "ZA", "TH"], iW = ["AD", "AR", "AT", "BE", "BR", "BG", "CL", "HR", "CY", "CZ", "DK", "EE", "FI", "FR", "DE", "GR", "HU", "IS", "IN", "IE", "IT", "JP", "KR", "LV", "LI", "LT", "LU", "MY", "MT", "MA", "NL", "NO", "PL", "PT", "QA", "RO", "RU", "SG", "SK", "SI", "ES", "SE", "CH", "GB"]; function sW(e, t) { return e.analytics !== t.analytics || e.preferences !== t.preferences || e.marketing !== t.marketing || e.necessary !== t.necessary } var GL = "cookie-consent-mode", YT = "cookie-consent-banner-seen", qT = "cookie-consent-banner-interacted"; function aW() { let e = typeof window < "u" ? window.__cf_country : null; return !e || iW.includes(e) ? Wr.EXPLICIT : oW.includes(e) ? Wr.IMPLICIT : null } var Ia = class { consentType = null; constructor(t) { this.consentType = t } start() { localStorage.setItem(YT, "true") } shouldShowNotice() { return this.consentType === Wr.EXPLICIT && localStorage.getItem(qT) !== "true" || this.consentType === Wr.IMPLICIT && localStorage.getItem(YT) !== "true" } shouldShowTag() { return this.consentType === Wr.EXPLICIT && localStorage.getItem(qT) === "true" || this.consentType === Wr.IMPLICIT && localStorage.getItem(YT) === "true" } getDefaultConsentStatus() { return this.consentType === Wr.IMPLICIT ? { necessary: !0, analytics: !0, preferences: !0, marketing: !0 } : { necessary: !0, analytics: !1, preferences: !1, marketing: !1 } } static getConsentStatus() { let t = localStorage.getItem(GL); if (!t || t === "null") return null; let r = JSON.parse(t); return { necessary: r.functionality_storage === "granted", analytics: r.analytics_storage === "granted", preferences: r.personalization_storage === "granted", marketing: r.ad_storage === "granted" } } setUserInteracted() { localStorage.setItem(qT, "true") } persist(t) { let r = { functionality_storage: t.necessary ? "granted" : "denied", ad_storage: t.marketing ? "granted" : "denied", analytics_storage: t.analytics ? "granted" : "denied", personalization_storage: t.preferences ? "granted" : "denied" }; localStorage.setItem(GL, JSON.stringify(r)) } }; function QT({ forceConsentType: e }) { let t = aW(), r = e || t, n = (0, Un.useMemo)(() => new Ia(r), [r]), [o, i] = (0, Un.useState)(!1), [s, a] = (0, Un.useState)(!1), l = (g, S) => ({ ...g, ...S }), [c, u] = (0, Un.useReducer)(l, n.getDefaultConsentStatus()), d = (0, Un.useRef)(!1); (0, Un.useEffect)(() => { if (d.current === e) return; a(n.shouldShowTag()), i(n.shouldShowNotice()), n.start(); let g = Ia.getConsentStatus(); e ? u(n.getDefaultConsentStatus()) : g ? u(g) : n.persist(n.getDefaultConsentStatus()), d.current = e }, [c, n, e]); let f = () => { let g = { necessary: !0, analytics: !1, preferences: !1, marketing: !1 }; u(g), y(g) }, p = () => { let g = { necessary: !0, analytics: !0, preferences: !0, marketing: !0 }; u(g), y(g) }; function y(g, S) { n.setUserInteracted(); let h = g || c, m = Ia.getConsentStatus(); !m || sW(h, m) ? (n.persist(h), window.location.reload()) : (i(!1), a(!0), S?.()) } return { consent: c, shouldShowNotice: o, shouldShowTag: s, consentType: r, acceptOnlyNecessary: f, acceptAll: p, saveConsent: y, updateConsent: u } } var lW = ["necessary", "marketing", "preferences", "analytics"]; function cW({ containerId: e, forceConsentType: t, forceStage: r, guidToUrl: n, setLocation: o, reportError: i, isManaging: s, setIsManaging: a, ...l }) { let c = XT[l.locale] || UL, { consent: u, shouldShowNotice: d, shouldShowTag: f, consentType: p, acceptOnlyNecessary: y, acceptAll: g, saveConsent: S, updateConsent: h } = QT({ forceConsentType: t }), m = null; s || r === "manage" ? m = "manage" : d || r === "notice" ? m = "notice" : f && (m = "tag"); let v = !!r; if (m === "tag") return (0, Ot.jsx)(KT, { onClick: () => { a?.(!0) }, xAlignment: l.triggerXAlignment, children: c.triggerLabel }); let x = (0, Ot.jsx)(GT, { disclaimerText: m === "manage" ? c.manageDisclaimer : p === Wr.EXPLICIT ? c.noticeDisclaimerExplicit : c.noticeDisclaimerImplicit, policyLink: l.policyLink, policyUrl: l.policyUrl, reportError: i, guidToUrl: n, setLocation: o, isPreview: v }), C = (0, Ot.jsxs)("div", { className: "cookie-consent-button-group", style: ML({ wide: l.componentType === Wd.MODAL }), children: [p === Wr.EXPLICIT && (0, Ot.jsx)(Vc, { onClick: y, children: c.rejectText }), (0, Ot.jsx)(Vc, { onClick: () => a?.(!0), children: c.manageText }), (0, Ot.jsx)(Vc, { onClick: g, children: c.acceptText })] }), T = (0, Ot.jsxs)("div", { style: { display: "flex", flexDirection: "column", gap: "0.25rem" }, children: [(0, Ot.jsx)("h1", { style: _L(), children: m === "notice" ? c.noticeHeader : c.manageHeader }), x] }); return m === "manage" ? (0, Ot.jsxs)(UT, { containerId: e, onClose: () => a?.(!1), scrimBackground: !v, children: [T, (0, Ot.jsx)("div", { style: { display: "flex", flexDirection: "column" }, children: lW.map(E => (0, Ot.jsx)(WT, { id: E, checked: u[E], description: c[`${E}Description`], disabled: E === "necessary", label: c[`${E}Text`], onChange: () => h({ [E]: !u[E] }) }, E)) }), (0, Ot.jsx)(Vc, { className: "button-wide", onClick: () => { S(void 0, () => a?.(!1)) }, children: c.saveLabel })] }) : m === "notice" ? l.componentType === Wd.MODAL ? (0, Ot.jsxs)($T, { containerId: e, xAlignment: l.xAlignment, yAlignment: l.yAlignment, children: [T, C] }) : (0, Ot.jsxs)("div", { className: "cookie-consent-banner", style: BL({ yAlignment: l.yAlignment }), children: [x, C] }) : null } function ZT(e) {
  return (0, Gg.useEffect)(() => {
    let t = "cookie-consent-styles", r = document.getElementById(t); r && r.remove(); let n = document.createElement("style"); return n.id = t, n.textContent = `
      :root {
        --consent-font-size-medium: 11px;
        --consent-line-height-medium: 16px;
        --consent-font-size-large: 13px;
        --consent-line-height-large: 22px;
        --consent-banner-padding: 1rem;

        @media (max-width: 480px) {
          --consent-font-size-medium: 13px;
          --consent-line-height-medium: 22px;
          --consent-font-size-large: 15px;
          --consent-line-height-large: 25px;
          --consent-banner-padding: 1.5rem;
        }
      }

      .button-wide {
        width: 100%;
      }

      @media (max-width: 480px) {
        .cookie-consent-banner {
          flex-direction: column;
        }

        .cookie-consent-button-group {
          flex-direction: row;
          width: 100%;
        }
      }
    `, document.head.appendChild(n), () => { let o = document.getElementById(t); o && o.remove() }
  }, []), (0, Ot.jsx)(cW, { ...e })
} var Fc = (0, Gg.createContext)({ enabled: !1, openSettings: () => { } }); function $L(e) { if (typeof window > "u") return !1; let t = Ia.getConsentStatus(); return e.includes("youtube-nocookie.com") || e.includes("youtube.com") || e.includes("maps.google.com") || e.includes("docs.google.com") || e.includes("form.typeform.com") || e.includes("vimeo.com") ? t ? t.analytics && t.preferences && t.marketing : !1 : !0 } var uW = [{ pattern: /^(https?:\/\/(www\.)?(youtube\.com|youtu\.be|youtube-nocookie\.com)\/.*)/, transform: dW, embedType: "IFRAME" }, { pattern: /^(?:https?:)?\/\/(www\.)?google\.com\/maps\/.*|^(?:https?:)?\/\/maps\.google\.com\/.*|^(?:https?:)?\/\/maps\.goo\.gl\/.*/, transform: fW, embedType: "IFRAME" }, { pattern: /^(?:https?:)?\/\/(www\.)?typeform\.com\/.*|^(?:https?:)?\/\/form\.typeform\.com\/.*/, transform: YL, embedType: "HTML", htmlTransform: pW }, { pattern: FT, transform: mW, embedType: "HTML", htmlTransform: hW }, { pattern: /^(?:https?:)?\/\/(www\.)?docs\.google\.com\/forms\/.*|^(?:https?:)?\/\/forms\.gle\/.*/, transform: gW, embedType: "IFRAME" }, { pattern: /^(?:https?:)?\/\/(www\.)?vimeo\.com\/.*$/, transform: yW, embedType: "IFRAME" }]; function dW(e) { let t = null; try { let r = new URL(e); t = r.searchParams.get("v") || null; let o = /(?:https?:\/\/)?(?:www\.)?(youtube\.com|youtu\.be|youtube-nocookie\.com)\/(?:watch\?v=|embed\/)?([^&?]+)/, i = e.match(o); if (!t) { let a = i?.[2] || null; a && (t = a) } let s = new URL((i?.[1] || "") === "youtube-nocookie.com" ? `https://www.youtube-nocookie.com/embed/${t}` : `https://www.youtube.com/embed/${t}`); return r.searchParams.forEach((a, l) => { l !== "v" && s.searchParams.set(l, a) }), s.toString() } catch { return e } } function fW(e) { let t = new URL("https://maps.google.com/maps"); return t.searchParams.set("output", "embed"), new URL(e).searchParams.forEach((n, o) => { t.searchParams.set(o, n) }), t.toString() } function YL(e) { try { let t = /\/to\/([a-zA-Z0-9]+)/, r = e.match(t); return r && r[1] ? r[1] : e } catch { return e } } function pW(e) { return `<div data-tf-widget="${YL(e)}" style="width:100%;height:100%;"></div><script src="//embed.typeform.com/next/embed.js"></script>` } function mW(e) { return e } function hW(e) { return `<script src="https://unpkg.com/@lottiefiles/dotlottie-wc@0.6.2/dist/dotlottie-wc.js" type="module"></script><dotlottie-wc src="${e}" style="width: 100%; height: 100%;" speed="1" autoplay loop></dotlottie-wc>` } function gW(e) { try { let t = new URL(e); return t.hostname.includes("forms.gle") || t.hostname.includes("docs.google.com") ? (t.searchParams.set("embedded", "true"), t.toString()) : e } catch { return e } } function yW(e) { try { let t = /\/(\d+)/, r = e.match(t); if (console.log(r), r && r[1]) return `https://player.vimeo.com/video/${r[1]}` } catch { return e } return e } function vW(e) { return ir.default.useMemo(() => { for (let t of uW) if (e.match(t.pattern)) return { transformedUrl: t.transform(e), embedType: t.embedType, htmlTransform: t.htmlTransform }; return { transformedUrl: e, embedType: "IFRAME" } }, [e]) } function qL({ node: e }) { ps("GenericEmbed"); let t = rm(), { embedURL: r, embedIframeHtml: n, embedCodeType: o, embedAllowFullscreen: i } = e.syncedState, { transformedUrl: s, embedType: a, htmlTransform: l } = vW(r), c = M({ overflow: "clip", width: "100%", height: "100%" }), { enabled: u } = (0, ir.useContext)(Fc), d = (0, ir.useMemo)(() => { if (o === "html") { let f = new DOMParser().parseFromString(n, "text/html"), p = f.querySelector("iframe"); if (p) return p.style.width = "100%", p.style.height = "100%", { type: "iframe", html: p.outerHTML }; if (II(ee.state?.labs)) return { type: "html", html: f.head.innerHTML.concat(f.body.innerHTML) } } else return }, [o, n]); if (o === "html") return !d || !d.html.trim() ? (0, Ct.jsx)(XL, {}) : (0, Ct.jsx)(KL, { className: c, type: d.type, html: d.html }); { if (u && !$L(r)) return (0, Ct.jsx)(xW, {}); if (!s.trim()) return (0, Ct.jsx)(XL, {}); if (a === "HTML" && l) { let p = l(r); return (0, Ct.jsx)(KL, { className: c, type: "html", html: p }) } let f = !t && new URL(r).searchParams.get("autoplay") === "1"; return (0, Ct.jsx)("iframe", { src: s, className: `${c} embed`, allowFullScreen: i, title: e.accessibleLabel, allow: f ? "autoplay" : void 0 }) } } function KL({ className: e, type: t, html: r }) { let n = (0, ir.useRef)(null); return (0, ir.useEffect)(() => { if (n.current && t === "html") { let o = document.createRange(); o.selectNode(n.current); let i = o.createContextualFragment(r); n.current.innerHTML = "", n.current.append(i) } }, [r, t]), (0, Ct.jsx)("div", { className: `${e} embed`, ref: n, dangerouslySetInnerHTML: { __html: r } }) } function SW() { let [e, t] = (0, ir.useState)(200), r = (0, ir.useRef)(null); return (0, ir.useEffect)(() => { let o = r.current?.parentElement; if (!o) return; let i = new ResizeObserver(s => { t(s[0]?.contentRect.width ?? 200) }); return i.observe(o), t(o.getBoundingClientRect().width), () => { i.disconnect() } }, []), [r, e] } function xW() { let [e, t] = SW(), { openSettings: r } = (0, ir.useContext)(Fc), n = M({ width: "100%", height: "100%", backgroundColor: "#F5F5F5", display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center", overflow: "hidden", padding: "8px", fontSize: "11px", lineHeight: "16px", fontWeight: "450", color: "rgba(0, 0, 0, 0.9)", cursor: "pointer" }), o = M({ width: 24, height: 24, display: "flex", alignItems: "center", justifyContent: "center" }); return (0, Ct.jsxs)("button", { className: n, onClick: r, children: [(0, Ct.jsx)("div", { className: o, ref: e, children: (0, Ct.jsx)("svg", { width: "13", height: "13", viewBox: "0 0 13 13", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: (0, Ct.jsx)("path", { d: "M2.91138 6.50781C3.10662 6.31259 3.42317 6.31258 3.61841 6.50781C3.8133 6.70307 3.81351 7.01972 3.61841 7.21484L2.38599 8.44727C1.6052 9.22815 1.60549 10.4943 2.38599 11.2754C3.16704 12.0561 4.43317 12.0562 5.21411 11.2754L6.44653 10.043C6.64178 9.84775 6.95833 9.84773 7.15356 10.043C7.34845 10.2382 7.34867 10.5549 7.15356 10.75L5.92114 11.9824C4.74968 13.1538 2.85053 13.1536 1.67896 11.9824C0.507937 10.8108 0.50764 8.91164 1.67896 7.74023L2.91138 6.50781ZM0.946533 1.00684C1.14177 0.8117 1.45833 0.811703 1.65356 1.00684L12.6536 12.0068C12.8488 12.2021 12.8487 12.5186 12.6536 12.7139C12.4583 12.9091 12.1418 12.9091 11.9465 12.7139L0.946533 1.71387C0.75137 1.5186 0.751304 1.20207 0.946533 1.00684ZM7.67896 1.74023C8.85039 0.568818 10.7495 0.569074 11.9211 1.74023C13.0924 2.91183 13.0926 4.81096 11.9211 5.98242L10.6887 7.21484C10.4936 7.40997 10.177 7.40974 9.98169 7.21484C9.78645 7.0196 9.78645 6.70305 9.98169 6.50781L11.2141 5.27539C11.995 4.49445 11.9948 3.22833 11.2141 2.44727C10.433 1.66663 9.1669 1.66637 8.38599 2.44727L7.15356 3.67969C6.95844 3.87481 6.6418 3.87459 6.44653 3.67969C6.25129 3.48445 6.25129 3.1679 6.44653 2.97266L7.67896 1.74023Z", fill: "black", fillOpacity: "0.5" }) }) }), t >= 80 && (0, Ct.jsx)("span", { children: "Allow cookies to view this content" })] }) } function XL() { let e = M({ width: "100%", height: "100%", backgroundColor: "#D3D1FF", display: "flex", alignItems: "center", justifyContent: "center", overflow: "hidden" }), t = M({ width: "min(93px, 100%)", height: "min(93px, 100%)", display: "flex", alignItems: "center", justifyContent: "center" }), r = M({ width: "100%", height: "100%" }); return (0, Ct.jsx)("div", { className: e, children: (0, Ct.jsx)("div", { className: t, children: (0, Ct.jsx)("svg", { className: r, xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 93 93", fill: "none", children: (0, Ct.jsx)("path", { d: "M20.9465 32.2205C32.0947 21.0723 50.1694 21.0723 61.3176 32.2205L57.0744 36.4626L52.8322 40.7058C46.3704 34.2439 35.8937 34.244 29.4319 40.7058L18.1584 51.9792C11.6967 58.4411 11.6966 68.9178 18.1584 75.3796C24.6203 81.841 35.0971 81.8412 41.5588 75.3796C43.9019 73.0365 47.701 73.0365 50.0442 75.3796C52.3869 77.7228 52.3872 81.522 50.0442 83.865C38.8961 95.0129 20.8212 95.0127 9.67306 83.865C-1.47505 72.7169 -1.47496 54.6421 9.67306 43.4939L20.9465 32.2205ZM43.4924 9.67455C54.6405 -1.47358 72.7153 -1.47352 83.8635 9.67455C95.0116 20.8227 95.0116 38.8975 83.8635 50.0456L72.591 61.3191C61.617 72.2927 43.9309 72.4637 32.7473 61.8328L32.2199 61.3191L32.007 61.0945C29.8792 58.7393 29.9504 55.1037 32.2199 52.8337C34.4899 50.5639 38.1254 50.4929 40.4807 52.6208L40.7043 52.8337L41.011 53.1316C47.4933 59.2934 57.7448 59.1942 64.1057 52.8337L75.3781 41.5603L75.677 41.2546C81.8391 34.7722 81.739 24.5208 75.3781 18.1599C68.9163 11.6981 58.4396 11.6981 51.9778 18.1599L47.7356 13.9167L43.4924 9.67455ZM61.3176 32.2205C63.6603 34.5636 63.6606 38.3628 61.3176 40.7058C58.9746 43.0487 55.1754 43.0485 52.8322 40.7058L61.3176 32.2205ZM51.9778 18.1599C49.6346 20.5023 45.8353 20.5028 43.4924 18.1599C41.1496 15.817 41.15 12.0177 43.4924 9.67455L51.9778 18.1599Z", fill: "#3D32E2" }) }) }) }) } function QL({ node: e, parent: t, context: r, zIndex: n }) { let o = vr({ node: e, parent: t, context: r, zIndex: n, children: [], options: { isFlattened: !0 } }), i = an({ node: e, context: r }), s = Sr({ node: e, parent: t }), a = de(e), l = { ...o.inner, ...xr(Nt(r, e)), ...i, ...r?.style || {} }, c = cn(e), u = M(l), d = (0, JT.default)(u, r?.className); return (0, Es.jsx)(Gt, { outerStyles: o.outer, children: (0, Es.jsx)(hn, { node: e, parent: t, context: r, styles: { transform: o.transform, stickyWrapper: o.stickyWrapper }, children: (0, Es.jsx)(TW, { id: a, className: d, "data-name": c, wrapperSizeStyles: s, ...r?.dataAttributes || {}, children: (0, Es.jsx)(dn, { children: () => (0, Es.jsx)(EW, { node: e }) }) }) }) }) } function TW(e) { let { className: t, wrapperSizeStyles: r, ...n } = e, o = $t(), i = M(o ?? r), s = (0, JT.default)(t, i); return (0, Es.jsx)("div", { className: s, ...n }) } function EW({ node: e }) { switch (ps("HTMLWidgetLayerContent"), e.widgetType) { case "GENERIC": return (0, Es.jsx)(qL, { node: e }); default: return null } } var fe = I(W()), n_ = I(P()), o_ = I(P()), ii = I(P()); var Cs = I(un()); function ZL(e) { if (typeof Intl < "u" && Intl.Segmenter) try { let t = new Intl.Segmenter(void 0, { granularity: "grapheme" }); return Array.from(t.segment(e), r => r.segment) } catch { return Array.from(e) } return Array.from(e) } function $g(e) { if (typeof Intl < "u" && Intl.Segmenter) try { let t = new Intl.Segmenter(void 0, { granularity: "grapheme" }); return Array.from(t.segment(e)).length } catch { return Array.from(e).length } return Array.from(e).length } var JL = /(\s+)/; function e_(e, t) {
  let { characterStyleOverrides: r, characters: n, lineIndentations: o, lineStyleOverrides: i, lineTextDirections: s, listStartOffsets: a, lineTypes: l, styleOverrideTable: c, lineStartsWithPunctuation: u } = e; if (typeof n != "string") { let h = new Rt("TextNode.characters is not a string"); h.errorDetail = JSON.stringify({ type: typeof n, value: n, nodeId: e.id, nodeName: e.name }), ke.reportError(h), console.error("TextNode.characters is not a string:", { type: typeof n, value: n, nodeId: e.id, nodeName: e.name }) } let f = (typeof n == "string" ? n : "").replace(/\r/g, " ").split(`
`), p = 0, y = 0, g = e.style.fontSize; return f.map((h, m) => { let v = i[m] ? c[i[m]] || {} : {}, x = 0, C = 0, T = (e.renderTextWordHook ? h.split(JL) : e.renderTextCharacterHook ? ZL(h) : e.renderTextLineHook ? [h] : Array.from(h)).reduce((w, k) => { let R = p + x, A = Array.from(k); if (e.renderTextWordHook || e.renderTextLineHook) { let N = A.map((b, H) => r[R + H]), O = N.every(b => b === N[0]), D = {}; if (e.renderTextWordHook) { if (k.length === 0) return w; JL.test(k) || (D.wordIndex = C, C++), O || (D.originalWord = k) } O ? w.push({ characters: k, override: N[0], renderHookMetadata: D }) : A.forEach((b, H) => { w.push({ characters: b, override: N[H], renderHookMetadata: D }) }) } else if (e.renderTextCharacterHook) w.push({ characters: k, override: r[R], renderHookMetadata: { globalCharacterIndex: y } }); else { let N = r[R], O = w[w.length - 1]; O && O.override === N ? O.characters += k : w.push({ characters: k, override: N }) } return x += A.length, y++, w }, []).map(w => { let k = w.override ? c[w.override] ?? {} : {}; t.fontSize || (k.fontSize = k.fontSize ?? g); let R = e.style.responsiveTextStyleVariants; if (!k.responsiveTextStyleVariants) { let N = R?.filter(O => O.style.fontSize).map(O => ({ ...O, style: { fontSize: O.style.fontSize } })); N?.length && (k.responsiveTextStyleVariants = N) } let A = { characters: w.characters, style: k }; return w.renderHookMetadata && (A.renderHookMetadata = w.renderHookMetadata), A }); p += h.length; let E = r[p] && c[r[p]] || {}; return p += 1, T.length === 0 && T.push(CW(l[m] && l[m] !== Li.NONE ? g : E.fontSize ?? g)), { spans: T, style: v, direction: s?.[m], indentation: o[m] || 0, startOffset: a[m] ?? void 0, listOptions: { type: l[m] || Li.NONE }, startsWithPunctuation: !!u?.[m] } })
} function CW(e) { return { characters: "", style: { fontSize: e } } } function eE(e, t, r) { if (t && !r) return "a"; switch (e.accessibleHTMLTag) { case "H1": return "h1"; case "H2": return "h2"; case "H3": return "h3"; case "H4": return "h4"; case "H5": return "h5"; case "H6": return "h6"; case "DIV": return "div"; case "P": case "AUTO": default: return "p" } } function t_(e, t, r) { return e ? r ? "div" : "a" : t ? r ? "div" : "button" : "div" } var tE = Li.NONE, bW = { whiteSpace: "pre-wrap", lineHeight: 0 }, wW = { whiteSpace: "pre-wrap" }, IW = e => e === void 0 ? void 0 : `${e}px`; function i_(e) { if (e) return "children" in e || e.block.listOptions && e.block.listOptions.type !== "NONE" ? "list" : "paragraph" } function RW(e, t, r, n) { return t.map((i, s) => (0, fe.jsx)(s_, { blockKey: s, tree: i, node: e, context: r, nextBlockType: i_(t[s + 1]), props: n }, s)) } var kW = ii.forwardRef(function ({ node: t, parent: r, context: n, interactionHandlers: o, zIndex: i, transitionProps: s, codeBehaviorProps: a }, l) { let c = ue(), u = Zn(), { scalingMode: d } = zr(), f = s?.smartAnimateType ?? K.NONE, p = f === K.INSTANCE_SUBTREE, y = Bo(f, t.maybeAnimateRotation), g = wl(), S = Ee(), { shouldOutputVariables: h, codeSyntaxLanguage: m } = S, v = vr({ node: t, parent: r, context: n, zIndex: i, children: [], codeSyntaxLanguage: m, options: { canAnimate: y, previousRotation: g, shouldOutputVariables: h } }), x = an({ node: t, context: n }), { style: C, className: T } = ga(t, t.assets, u, d, { width: t.size.x, height: t.size.y }, S), E = t.interactions ?? [], w = Dc(t.name, a), k = go(E, w), R = Hn(E) || t.style.hyperlink != null, A = uo(t), N = Nt(n, t), O = ii.useMemo(() => ({ opacity: N, transform: Jr(v.outer.transform) }), [N, v.outer.transform]), D = nn(t, n), { motionProps: b, key: H, ref: B } = sn(t.id, t.behaviors, t.assets, O, D), z = ln(l, B), Q = Md(t), se = aa(t, r, n) || y, he = Sr({ node: t, parent: r }), xe = s?.transitionData, Oe = kt(xe), Y = ii.useMemo(() => ({ fontSize: Object.values(t.styleOverrideTable).find(Ie => Ie.fontSize) ? void 0 : L(t.style.fontSize) }), [t.styleOverrideTable, t.style.fontSize]), $ = { ...v.inner, ...xr(N, h, t.boundVariables?.opacity?.resolvedName, m && t.boundVariables?.opacity?.resolvedCodeSyntax?.[m]), ...zi(t, w), ...LO(t.effects, h, m), ...C, ...pL(t, t.style), ...x, ...n?.style || {}, "--letter-spacing": 0, fontSize: Y.fontSize ? C.fontSize : 0, lineHeight: 0 }; if ($.letterSpacing && ($["--letter-spacing"] = $.letterSpacing), t.style.textTruncation === "ENDING") { let Ie = t.style.maxLines; Ie === 1 ? $.whiteSpace = "nowrap" : Ie && ($.display = "-webkit-box", $.WebkitLineClamp = Ie, $.WebkitBoxOrient = "vertical", $.height && ($.maxHeight = $.height, $.height = void 0)), $.overflow = "hidden", $.textOverflow = "ellipsis" } let oe = n?.withinInteractiveElement || Object.keys(b).length > 0 || f === K.INSTANCE_SUBTREE || !!w?.onClick, ve = gn(E, o, oe, c, w), ie = { semanticTag: t_(R, k, oe) }, Se = c_(t.style.hyperlink, oe, c), Yt = de(t), li = (0, Cs.default)("textContents", T), yn = yr(t), Er = (0, o_.useRef)(null), { codeBehaviorWrapperRef: vo, updateStyles: vn } = xg(), sr = ii.useContext(zn), Cr = _c(), Sn = Ie => { let Ra = Ie; if (Ie.renderTextHook) { let En = Ie.renderTextHook.renderText({ characters: Ie.characters, length: $g(Ie.characters), TextComponent: Cn => (Cn.characters && (Ie = { ...Ie, characters: Cn.characters }), null) }); En?.props?.characters && (Ra = { ...Ie, characters: En.props.characters }) } let ci = AW(e_(Ra, Y), Y), ui = p || Cr || ci.length > 1 || R || k || t.textAlignVertical !== "TOP" || yn || t.style.hangingList || sr || Q || n?.parentIsList, br = y ? B : z, xn = { id: Yt, ...A, additionalClassName: li, styles: $, wrapperSizeStyles: he, ref: br, ...ve }, Tn = RW(Ie, ci, n, ui ? void 0 : xn), So = yn ? dg : Hr, bs = se ? Ig : Hr, di = ui ? ho : Hr; return (0, fe.jsx)(bs, { ref: y || p || Q ? l : null, context: n, node: t, parent: r, childWrapperStyles: { ...v.transform }, transitionData: xe, canAnimate: y, smartAnimateType: f, previousRotation: g, transformRef: Er, onOuterWrapperSizeChange: vn, children: (0, n_.createElement)(di, { semanticTagInfo: { interactiveSemanticTag: null, semanticTag: ie.semanticTag }, ...xn, key: H, ref: ui ? br : null, context: n, nodeName: t.name, needsMotionForCodeBehavior: Cr, codeBehaviorProps: a, transitionProps: { opacity: N, smartAnimateType: f, behaviorProps: b, transitionData: xe, onTransitionEnd: Oe }, ...Se, ...n?.dataAttributes, ...sr ? { [Zo]: t.name } : {} }, (0, fe.jsx)(So, { node: Ie, children: Tn })) }) }, Lt = Q ? (0, fe.jsx)(_d, { codeBehaviors: t.behaviors.code, ref: vo, children: (0, fe.jsx)(bg, { node: t, renderNode: Ie => Sn(Ie), codeBehaviorProps: { ...a, transformRef: Er } }) }) : Sn(t); return (0, fe.jsx)(Gt, { outerStyles: v.outer, children: (0, fe.jsx)(xd, { node: t, stickyWrapperStyles: v.stickyWrapper, children: Lt }) }) }); function AW(e, t) { let r = { children: [], type: tE, lineStyleType: void 0 }; t && (r.style = t); let n = [r]; for (let o of e) { let i = { block: o, style: t }, s = o.listOptions?.type || tE; if (s !== "NONE") { let a = o.indentation + 1; for (; n.length > a || n.length === a && n[n.length - 1].type !== "NONE" && n[n.length - 1].type !== s;)n.pop(); for (; n.length < a;) { let l = a - n.length === 1 ? o.startOffset : void 0, c = { children: [], lineStyleType: mL(s, n.length), type: s, start: l, style: { ...o.style, ...t } }; n[n.length - 1].children.push(c), n.push(c) } } else n = [r]; n[n.length - 1].children.push(i) } return r.children } function s_({ nextBlockType: e, tree: t, node: r, context: n, blockKey: o, props: i }) { if ("children" in t) return (0, fe.jsx)(PW, { listNode: t, node: r, props: i, nextBlockType: e, children: t.children.map((u, d) => (0, fe.jsx)(s_, { blockKey: d, tree: u, node: r, context: n, nextBlockType: i_(t.children[d + 1]) }, d)) }); let { block: s } = t, a; if (r.renderTextWordHook) { let u = NW(s.spans); a = []; for (let d of u) { if (d.length === 0) continue; let f = d[0]?.renderHookMetadata?.wordIndex; if (f == null) for (let p of d) a.push((0, fe.jsx)(rE, { span: p, block: s, node: r, context: n, blockKey: o }, a.length)); else a.push((0, fe.jsx)(r_, { spans: d, node: r, block: s, context: n, blockKey: o, wordIndex: f }, a.length)) } } else r.renderTextLineHook ? a = [(0, fe.jsx)(r_, { spans: s.spans, node: r, block: s, context: n, blockKey: o }, 0)] : a = s.spans.map((u, d) => (0, fe.jsx)(rE, { span: u, block: s, node: r, context: n, spanIndex: d, blockKey: o }, d)); if ((s.listOptions?.type || tE) !== "NONE") return (0, fe.jsx)(LW, { node: r, block: s, commonFontSize: t.style?.fontSize, nextBlockType: e, children: a }); let c = e === void 0; return a.length === 1 && !r.renderTextCharacterHook && !r.renderTextWordHook && !r.renderTextLineHook && !r.renderTextHook ? (0, fe.jsx)(OW, { node: r, context: n, block: s, isLastBlock: c, props: i }) : (0, fe.jsx)(_W, { node: r, block: s, props: i, isLastBlock: c, children: a }) } function NW(e) { let t = []; for (let r of e) { let n = t[t.length - 1]; if (!n) { t.push([r]); continue } n[0]?.renderHookMetadata?.wordIndex === r.renderHookMetadata?.wordIndex ? n.push(r) : t.push([r]) } return t } function OW({ node: e, context: t, block: r, isLastBlock: n, props: o }) { r.spans.length; let { style: i, className: s, props: a } = a_({ node: e, block: r, isLastBlock: n }), l = !!e.style.hyperlink, c = !!t?.withinInteractiveElement || l, { style: u, className: d, props: f, isHyperlink: p } = oE({ node: e, withinInteractiveElement: c, block: r, span: r.spans[0] }), { additionalClassName: y, styles: g, wrapperSizeStyles: S, ...h } = o ?? {}, m = $t() ?? S, v = ii.useMemo(() => ({ display: "block", ...m, ...g, ...i, ...u }), [m, g, i, u]), x = M(v), C = (0, Cs.default)(x, s, d, y), T = eE(e, p, c); return (0, fe.jsx)(T, { className: C, ...a, ...h, ...f, children: f.children }) } function PW({ listNode: e, node: t, children: r, nextBlockType: n, props: o }) { let i = e.children.find(w => "block" in w)?.block, s = i?.spans[0], a = Zn(), { scalingMode: l } = zr(), c = e.type === Li.ORDERED, u = Ee(), { disableTextMarkerVariables: d } = u, { style: f, className: p } = i && s ? PT(t, i, s, a, l, u) : { style: {}, className: void 0 }, y = d ? {} : { "--list-marker-background-clip": f.backgroundClip ?? "initial", "--list-marker-background-image": f.backgroundImage ?? "initial", "--list-marker-color": f.color ?? "initial", "--list-marker-font-size": f.fontSize ?? "initial", "--list-marker-line-height": f.lineHeight ?? "initial", "--list-marker-mix-blend-mode": f.mixBlendMode ?? "initial", "--list-marker-text-fill-color": f.WebkitTextFillColor ?? "initial", "--list-marker-vertical-align": f.verticalAlign ?? "initial" }, { additionalClassName: g, styles: S, wrapperSizeStyles: h, ...m } = o ?? {}, x = { ...$t() ?? h, ...S, ...y, listStyleType: c ? e.lineStyleType : void 0, marginLeft: t.style.hangingList ? "-1.5em" : void 0, marginBottom: nE(t, void 0, n, u) }, C = M(x), T = (0, Cs.default)(C, p, g), E = { ...m, className: T }; return c ? (0, fe.jsx)("ol", { ...E, start: e.start, children: r }) : (0, fe.jsx)("ul", { ...E, children: r }) } var nE = (e, t, r, { shouldOutputVariables: n, codeSyntaxLanguage: o }) => { if (r === "paragraph") { let i = t?.style.paragraphSpacing !== void 0 ? t.style.paragraphSpacing : e.style.paragraphSpacing; return n ? X(o && e.boundVariables?.paragraphSpacing?.[0]?.resolvedCodeSyntax?.[o], e.boundVariables?.paragraphSpacing?.[0]?.resolvedName, `${i}px`) ?? i : i } if (r === "list") return t?.style.listSpacing !== void 0 ? t.style.listSpacing : e.style.listSpacing }; function LW({ children: e, node: t, block: r, commonFontSize: n, nextBlockType: o }) { let i = Zn(), { scalingMode: s } = zr(), a = Ee(), l = t.style.textAlignHorizontal === "LEFT" || t.style.textAlignHorizontal === "JUSTIFIED", { style: c, className: u } = OT(t, r, i, s, a), d = { ...wW, ...c, listStylePosition: l ? void 0 : "inside", marginInlineStart: n ? IW(1.5 * r.indentation * n) : `calc(1.5 * ${r.indentation} * var(--list-marker-font-size, 0))`, marginBottom: nE(t, r, o, a), "--letter-spacing": 0 }, f = M(d); return (0, fe.jsx)("li", { className: (0, Cs.default)(f, u), children: e }) } function _W({ node: e, block: t, children: r, isLastBlock: n, props: o }) { let { additionalClassName: i, styles: s, wrapperSizeStyles: a, ...l } = o ?? {}, { style: c, className: u, props: d } = a_({ node: e, block: t, isLastBlock: n }), f = $t() ?? a, p = M({ ...f, ...s, ...c }), y = (0, Cs.default)(p, u, i), g = eE(e, !1, !1); return (0, fe.jsx)(g, { className: y, ...d, ...l, children: r }) } function a_({ node: e, block: t, isLastBlock: r }) { let n = Zn(), { scalingMode: o } = zr(), i = Ee(), { shouldOutputVariables: s, codeSyntaxLanguage: a } = i, { style: l, className: c } = OT(e, t, n, o, i), u = { ...bW, ...l, marginBottom: nE(e, t, r ? void 0 : "paragraph", i) }; e.paragraphIndent && (u.textIndent = e.paragraphIndent, s && u.textIndent && (u.textIndent = X(a && e.boundVariables?.paragraphIndent?.[0]?.resolvedCodeSyntax?.[a], e.boundVariables?.paragraphIndent?.[0]?.resolvedName, isNaN(Number(u.textIndent)) ? u.textIndent : `${u.textIndent}px`) ?? u.textIndent)); let d = l.fontSize ?? L(e.style.fontSize); return e.style.hangingPunctuation && t.startsWithPunctuation && (u.textIndent = `calc(${e.paragraphIndent ?? 0}px - 0.45 * ${d}px)`), e.style.textTruncation === "ENDING" && (e.style.maxLines === 1 && (u.whiteSpace = "nowrap", u.overflow = "hidden", u.textOverflow = "ellipsis"), u.fontSize = d), e.textAutoResize === "WIDTH_AND_HEIGHT" && (u.whiteSpace = "pre"), { style: u, className: c, props: { dir: t.direction } } } function rE({ node: e, context: t, block: r, span: n, spanIndex: o = 0, blockKey: i }) { let s = !!e.style.hyperlink, a = !!t?.withinInteractiveElement || s, { style: l, className: c, props: u, isHyperlink: d } = oE({ node: e, withinInteractiveElement: a, block: r, span: n }), f = M(l), p = (0, Cs.default)(f, c), y = n.renderHookMetadata?.globalCharacterIndex, g = ii.useMemo(() => e.renderTextCharacterHook ? e.renderTextCharacterHook.renderTextCharacter({ character: n.characters, index: o, globalIndex: y ?? 0, columnIndex: o, lineNumber: i, characters: e.characters, TextCharacterComponent: m => m.character && l_.test(m.character) ? (0, fe.jsx)("br", {}) : (0, fe.jsx)("span", { children: m.character ?? n.characters }) }) ?? n.characters : u.children, [e, u.children, n.characters, o, i, y]), S = (0, fe.jsx)("span", { ...u, className: p, children: g }); return d && !a ? (0, fe.jsx)("a", { className: p, ...u, children: S }) : S } function r_({ node: e, spans: t, block: r, context: n, blockKey: o, wordIndex: i = 0 }) { let s = !!e.style.hyperlink, a = !!n?.withinInteractiveElement || s, { style: l, className: c, props: u } = oE({ node: e, withinInteractiveElement: a, block: r, span: t[0] }), d = M(l), f = (0, Cs.default)(d, c), p = t.map((m, v) => (0, fe.jsx)(rE, { span: m, block: r, node: e, context: n, blockKey: o }, v)), y = null, g = e.renderTextWordHook; if (g != null) { let m = t[0]?.renderHookMetadata?.originalWord ?? t[0]?.characters ?? ""; y = g.renderTextWord({ word: m, index: i, characters: e.characters, length: $g(m), TextWordComponent: v => v.word == null || v.word === m ? (0, fe.jsx)(fe.Fragment, { children: p }) : (0, fe.jsx)("span", { children: v.word }) }) } let S = null, h = e.renderTextLineHook; if (h != null) { let m = t.map(v => v.characters).join(""); S = h.renderTextLine({ line: m, index: o, characters: e.characters, length: $g(m), TextLineComponent: v => v.line == null || v.line === m ? (0, fe.jsx)(fe.Fragment, { children: p }) : (0, fe.jsx)("span", { children: v.line }) }) } return (0, fe.jsx)("span", { ...u, className: f, children: y ?? S ?? p }) } function oE({ node: e, withinInteractiveElement: t, block: r, span: n }) { let o = ue(), i = Zn(), { scalingMode: s } = zr(), a = Ee(), { disableAdjustLetterSpacing: l } = a, { style: c, className: u } = PT(e, r, n, i, s, a), d = n === r.spans[r.spans.length - 1], f = d && DW(n, e.style); !l && d && f && e.layoutAlign !== "STRETCH" && e.layoutGrow !== 1 && (u = [u, "adjustLetterSpacing"].filter(Boolean).join(" ")); let p = n.characters.length ? MW(n.characters, d) : "\xA0", y = n.style.hyperlink ?? r.style.hyperlink; if (y) { let S = c_(y, t, o); return { isHyperlink: !0, style: c, className: u, props: { ...S, children: p } } } return { isHyperlink: !1, style: c, className: u, props: { children: p } } } function DW(e, t) { return Boolean(e?.style.letterSpacing || t.letterSpacing) } var l_ = /[\u2028\u2029]/, MW = (e, t) => e.split(l_).flatMap((r, n, o) => n < o.length - 1 || t && r === "" ? [r, (0, fe.jsx)("br", { "aria-hidden": !0 }, "br" + n)] : [r]); function c_(e, t, r) { if (!e || !e.type) return {}; if (e.type === "NODE" && e.nodeID) return Lg(s => { s.preventDefault(), s.stopPropagation(), NT(e.nodeID) }, e.type, e.nodeID, !1, t, r); let n = !!e.openInNewTab; return Lg(i => { i.preventDefault(), i.stopPropagation(), window.open(e.url, n ? "_blank" : "_self") }, e.type, e.url, n, t, r) } var u_ = Lc(kW); var si = I(W()), aE = I(P()); var d_ = I(P()); var iE = "body-background-color"; function f_({ breakpoints: e }) {
  let t = ue(), r = e.sort((s, a) => s.width - a.width), o = r.map((s, a) => ({ layerName: s.name, minWidth: a === 0 ? void 0 : s.width, maxWidth: a < r.length - 1 ? r[a + 1]?.width : void 0, background: s.background, nodeId: s.nodeId })).map(({ background: s, minWidth: a, maxWidth: l, nodeId: c }) => { let u = []; l !== void 0 && u.push(`(max-width: ${l - 1}px)`), a !== void 0 && u.push(`(min-width: ${a}px)`); let d = `body:has([data-breakpoint-id="${qo(c)}"]) { background-color: ${s} }`; return u.length > 0 ? `@media ${u.join(", ")} { ${d} }` : d }).join(`
`), i = Jn(); t === "server" && i({ type: "global-style", styleElId: iE, styleSheet: o }), (0, d_.useInsertionEffect)(() => { let s = document.getElementById(iE); if (s) { s.textContent = o; return } let a = document.createElement("style"); return a.textContent = o, a.id = iE, document.head.appendChild(a), () => { document.head.removeChild(a) } }, [e])
} function p_({ breakpoints: e }) {
  let t = ue(), r = Jn(); if (t !== "server" || e.length === 1) return; let n = e.sort((i, s) => s.width - i.width), o = n.reduce((i, s, a) => {
    let l = a === 0, c = a === n.length - 1, u = n[a - 1]?.width || void 0, d = []; return l ? d.push(`(width < ${s.width}px)`) : c ? u && d.push(`(width >= ${u}px)`) : (u && d.push(`(width >= ${u}px)`), d.push(`(width < ${s.width}px)`)), d.length > 0 && i.push(`@media ${d.join(" or ")} {
        [${qp}="${qo(s.nodeId)}"] {display: none !important}
      }`), i
  }, []); r({
    type: "global-style", styleElId: dx, styleSheet: Vi(o.join(`
`))
  })
} var h_ = I(P()); var sE = new Map; function m_(e, t) { let r = JSON.stringify(e); return Us({ str: r, hashPrefix: e.type + "-", isUniqueKey: o => { let i = sE.get(o), s = i ? JSON.stringify(i) : null; if (t === "server") return !s || s === r; if (s && s !== r) return !1; let a = document.getElementById(o); return a ? g_(a, e) : !0 } }) } function g_(e, t) { if (e.tagName === "LINK" && t.type === "link") { let r = e; return r.getAttribute("href") === t.href && r.rel === t.rel } else if (e.tagName === "META" && t.type === "meta") { let r = e, n = t.name || "", o = t.property || "", i = r.getAttribute("property") || ""; return r.content === t.content && r.name === n && i === o } else if (e.tagName === "TITLE" && t.type === "title") return e.textContent === t.title; return !1 } function y_(e) { let t = Jn(), r = ue(); r === "server" && e.forEach(n => { let o = m_(n, r); sE.has(o) || (t(n), sE.set(o, n)) }), (0, h_.useInsertionEffect)(() => { let n = []; return e.forEach(o => { if (o.type === "title") { document.title = o.title; return } let i = m_(o, r), s = document.getElementById(i); if (!(s && g_(s, o))) { if (o.type === "link") { let a = document.createElement("link"); a.href = o.href, a.rel = o.rel, a.id = i, document.head.appendChild(a), n.push(a) } else if (o.type === "meta") { let a = document.createElement("meta"); o.name && (a.name = o.name), o.property && a.setAttribute("property", o.property), a.content = o.content, a.id = i, document.head.appendChild(a), n.push(a) } } }), () => { n.forEach(o => { o.remove() }) } }, [e]) } function v_({ children: e }) { let t = Di(), { getAssetURL: r } = re(); e !== void 0 && e.length > 0; let n = (0, aE.useMemo)(() => fx(e.filter(i => i.visible !== !1).filter(i => is(i)).filter(i => i.type === "FRAME")), [e]); p_({ breakpoints: n.breakpoints }), f_({ breakpoints: n.breakpoints }); let o = (0, aE.useMemo)(() => { let i = [{ type: "title", title: t?.title ?? BT }, { type: "meta", name: "description", content: t?.description ?? VT }]; return t?.blockSearchIndexing && i.push({ type: "meta", name: "robots", content: t?.blockSearchIndexing ? "noindex" : "index" }), t?.faviconFilename && i.push({ type: "link", rel: "icon", href: r(t?.faviconFilename) }), t?.socialImageFilename && i.push({ type: "meta", property: "og:image", content: r(t?.socialImageFilename) }, { type: "meta", property: "twitter:image", content: r(t?.socialImageFilename) }), i }, [t?.title, t?.description, t?.blockSearchIndexing, t?.faviconFilename, t?.socialImageFilename, r]); return y_(o), (0, si.jsx)(si.Fragment, { children: (0, si.jsx)(eL, { children: e.map((i, s) => (0, si.jsx)(dT, { children: (0, si.jsx)(oT, { name: i.name, width: i.size.x, height: i.size.y, children: (0, si.jsx)(Ss, { name: "sites-layer", nodeId: i.id, children: (0, si.jsx)(Fn, { node: i, parent: null }, s) }, s) }) }, i.id)) }) }) } var Fn = (0, ai.forwardRef)(function ({ node: t, parent: r, context: n, zIndex: o, codeBehaviorProps: i }, s) { let a = Qp(t.materializedChildNodeProps ?? []), { interactionHandlers: l, transitionProps: c } = t; n = ll(n, we); let { renderHiddenRootNodes: u, renderComponentSetNodes: d } = Ee(), f = (0, ai.useMemo)(() => u && !r && !t.visible, [u, r, t.visible]), p = ge(kx); (0, ai.useEffect)(() => { if (t.visible && !(l === void 0 || l?.ON_KEY_DOWN === void 0)) return p.set(t.id, l.ON_KEY_DOWN), () => (p.delete(t.id), void 0) }, [l, p, t.id, t.visible]); let y = c?.transitionData; return (0, ai.useEffect)(() => { let g = [], S; return t.visible && (y && !y.layout ? g = lL(l, y.id) : g = cL(t.id, l).timeoutIds, g.length && y && (S = uL(() => { setTimeout(() => { y.onTransitionEnd?.(y.id) }, 500) }, 100), window.addEventListener("resize", S))), () => { S && setTimeout(() => { removeEventListener("resize", S) }), ys.markTimeoutsAsUnmounted(t.id), setTimeout(() => { let h = l?.AFTER_TIMEOUT?.map(m => m.interactionGuid); ys.cleanupUnmountedTimeouts(t.id, h) }, 100) } }, [t.id, l, t.visible]), (0, ai.useMemo)(() => { if (!t || t.visible === !1 && !f) return null; let g = (() => { switch (t.type) { case "WEBPAGE": return (0, Pt.jsx)(JP, { rootMaterializedNode: t, materializedChildren: a, children: (0, Pt.jsx)(v_, { node: t, children: a, parent: r, context: n, interactionHandlers: l }) }); case "FRAME": case "SLOT": return (0, Pt.jsx)(ST, { layerRef: s, node: t, children: a, parent: r, context: n, zIndex: o, interactionHandlers: l, transitionProps: c, codeBehaviorProps: i }); case "COMPONENT_SET": return me(d, "COMPONENT_SET nodes are not supported in sites"), (0, Pt.jsx)(PL, { node: t, children: a, parent: r, context: n, zIndex: o, interactionHandlers: l, transitionProps: c, codeBehaviorProps: i }); case "RECTANGLE": return (0, Pt.jsx)(ST, { layerRef: s, node: t, children: a, parent: r, context: n, zIndex: o, interactionHandlers: l, transitionProps: c, codeBehaviorProps: i }); case "GROUP": return (0, Pt.jsx)(LL, { node: t, children: a, parent: r, context: n, zIndex: o, interactionHandlers: l, transitionProps: c }); case "IMAGE": case "SVG": return (0, Pt.jsx)(fL, { layerRef: s, node: t, parent: r, zIndex: o, context: n, interactionHandlers: l, transitionProps: c, codeBehaviorProps: i }); case "TEXT": return (0, Pt.jsx)(u_, { layerRef: s, node: t, parent: r, context: n, zIndex: o, interactionHandlers: l, transitionProps: c, codeBehaviorProps: i }); case "WIDGET": return (0, Pt.jsx)(QL, { node: t, parent: r, context: n, zIndex: o, interactionHandlers: l }); case "CODE_INSTANCE": case "CODE_LAYER": return (0, Pt.jsx)(NL, { node: t, parent: r, context: n, zIndex: o, interactionHandlers: l }); case "REPEATER": return (0, Pt.jsx)(vT, { ref: s, node: t, children: a, parent: r, context: n, zIndex: o, interactionHandlers: l, transitionProps: c }); case "CMS_RICH_TEXT": return (0, Pt.jsx)(xL, { node: t, parent: r, context: n, zIndex: o, interactionHandlers: l }); default: ye(t) } })(); return f ? (0, Pt.jsx)("div", { style: { display: "none" }, children: g }) : (0, Pt.jsx)(NO, { isNodeListItem: n?.parentIsList ?? !1, children: g }) }, [t, a, r, n, l, s, o, c, i, f, d]) }), lg = (0, ai.forwardRef)(function ({ node: t, parent: r, context: n, zIndex: o, name: i, nodeId: s, childKey: a, codeBehaviorProps: l }, c) { return (0, Pt.jsx)(Ss, { name: i, nodeId: s, children: (0, Pt.jsx)(Fn, { ref: c, node: t, parent: r, context: n, zIndex: o, codeBehaviorProps: l }, a) }) }); var We = I(W()), jr = I(P()); var S_ = new Map; function lE() { let e = Vi(rI() ?? ""), t = ue(), r = Us({ str: e ?? "", hashPrefix: ox, isUniqueKey: n => { if (t === "server") { let i = S_.get(n); return !i || i === e } let o = document.getElementById(n); return !o || o.textContent === e } }); return e && S_.set(r, e), kl({ cssString: e ?? "", styleElId: r, deleteElsWithPrefix: ox, skipValidation: !0 }), null } function cE({ withBaseStyles: e, prepend: t = !1 }) { return kl({ cssString: MT(e), styleElId: zg, prepend: t }), null } function x_() { let e = eI(), r = !!ge(e), n = Zn(), { getFontURL: o } = re(); GI(zW(n, o, r)) } function BW(e, t, r) {
  let n = new Map; if (t.subsets) {
    let o = t.subsets.baseUrl; if (n.set(e, t.subsets.subsetMappings.sort((i, s) => i.unicodeRange === "*" ? -1 : 0).map(i => Ts({ family: e, style: t.italic ? "italic" : "normal", url: o + i.file, unicodeRange: i.unicodeRange })).join(`
`)), r) {
      let i = e.split(":"), s = i[0], a = i.length > 1 ? i[1] : "normal"; n.set(s, t.subsets.subsetMappings.sort((l, c) => l.unicodeRange === "*" ? -1 : 0).map(l => Ts({ family: s, style: a, url: o + l.file, unicodeRange: l.unicodeRange })).join(`
`))
    }
  } else if (n.set(e, Ts({ family: e, style: t.italic ? "italic" : "normal", url: t.url })), r) { let o = e.split(":"), i = o[0], s = o.length > 1 ? o[1] : "normal"; n.set(i, Ts({ family: i, style: s, url: t.url })) } return n
} function VW(e, t, r, n) { let o = new Map, i = t.url ? r(t.url, "CUSTOM") : void 0; if (o.set(e, Ts({ family: e, style: t.italic ? "italic" : "normal", url: i })), n) { let s = e.split(":"), a = s[0], l = s.length > 1 ? s[1] : "normal"; o.set(a, Ts({ family: a, style: l, url: i })) } return o } function FW(e, t, r, n) { return t ? t.source === 1 ? BW(e, t, n) : VW(e, t, r, n) : new Map } function zW(e, t, r) {
  let n = Array.from(e.map).reduce((o, [i, s]) => new Map([...o, ...FW(i, s, t, r)]), new Map); return Vi([...n.values()].join(`
`))
} function T_({ rootMaterializedNodePropsArrayAtom: e, history: t, websiteData: r, cmsBundleDataAtom: n, getAssetURL: o, getFontURL: i, getVideoURL: s, getCodeComponentURL: a, env: l, transitionAtom: c, currentLocationAtom: u, setLocation: d, preloadLocation: f, onPageRendered: p, onReactError: y, renderOptionsAtom: g, addHeadTag: S, addBodyScript: h, loadComponentsOverNetwork: m, wasServerRendered: v = !1, withBaseStyles: x = !0, isFigmake: C }) { let T = ge(g), E = ge(n); (0, jr.useEffect)(() => { kI(T.testFlags ?? {}) }, [T.testFlags]); let k = ge(r.siteSettings)?.cookieBanner, [R, A] = (0, jr.useState)(!1); KW(v); let O = l === "published" && C && window.self === window.top ? IL : Hr; return (0, We.jsx)(wI, { reportError: y, children: (0, We.jsx)(vs, { name: "root-error-boundary", nodeId: "root", children: (0, We.jsx)(DS, { websiteData: r, cmsBundleData: E, history: t, getAssetURL: o, getFontURL: i, getVideoURL: s, getCodeComponentURL: a, env: l, transitionAtom: c, setLocation: d, preloadLocation: f, renderOptions: T, withBaseStyles: x, addHeadTag: S, addBodyScript: h, loadComponentsOverNetwork: m, isFigmake: C, children: (0, We.jsx)(Fc.Provider, { value: { enabled: k?.enabled, openSettings: () => A(!0) }, children: (0, We.jsxs)(O, { children: [(0, We.jsx)(UW, { rootMaterializedNodePropsArrayAtom: e }), k?.enabled && (0, We.jsx)(ZT, { ...k, guidToUrl: r.guidToUrl, setLocation: d, reportError: y, isManaging: R, setIsManaging: A }), (0, We.jsx)(HW, { currentLocationAtom: u, onPageRendered: p })] }) }) }) }) }) } function HW({ currentLocationAtom: e, onPageRendered: t }) { let r = ge(e), n = ge(fl); return (0, jr.useEffect)(() => { window.scrollTo(0, r?.scrollY ?? 0) }, [r?.scrollY, r?.url]), (0, jr.useEffect)(() => { t && r?.url && t(r.url, n) }, [r?.url, t, n]), zR(), null } function Kg(e) { let t = document.createRange().createContextualFragment(e); return Array.from(t.children).forEach(n => n.setAttribute("data-user-element", "true")), t } function WW(e) { let t = re()?.websiteData.siteSettings ?? q(), r = ge(t), n = r?.customCodeHeadStart, o = r?.customCodeHeadEnd, i = r?.customCodeBodyStart, s = r?.customCodeBodyEnd; (0, jr.useInsertionEffect)(() => { if (e === "preview") return n && document.head.prepend(Kg(n)), o && document.head.append(Kg(o)), i && document.body.prepend(Kg(i)), s && document.body.append(Kg(s)), () => { document.querySelectorAll("[data-user-element]").forEach(l => l.remove()) } }, [e, n, o, i, s]) } function jW() { let t = Di()?.addBypassLinks, r = (0, jr.useCallback)(i => { i.stopPropagation(), i.preventDefault(); let s = document.querySelector("main"); s && s.focus() }, []), n = (0, jr.useCallback)(i => { i.key === "Enter" && r(i) }, [r]), o = (0, jr.useCallback)(i => { r(i) }, [r]); return t ? (0, We.jsx)("div", { className: "bypass-link", children: (0, We.jsx)("a", { role: "link", onKeyDown: n, onClick: o, tabIndex: 0, children: "Skip to main content" }) }) : null } function UW({ rootMaterializedNodePropsArrayAtom: e }) { let t = ue(), r = re()?.withBaseStyles ?? !0, n = ge(e), o = Hw(s => n.map(a => $s(s, a, t)), [n, t]), i = Zu(); return oL(), x_(), WW(t), o.length > 0 ? (0, We.jsxs)(_x, { reducedMotion: i ? "never" : "user", children: [(0, We.jsx)(cE, { withBaseStyles: r }), (0, We.jsx)(lE, {}), (0, We.jsx)($I, {}), (0, We.jsx)(jW, {}, `bypass-${o[0]?.id}`), o.map(s => (0, We.jsx)(Fn, { node: s, parent: null }, `${s.id}`))] }) : null } var GW = () => { }; function uE({ websiteData: e, cmsBundleData: t, history: r, getAssetURL: n, getFontURL: o, getVideoURL: i, getCodeComponentURL: s, env: a, transitionAtom: l, setLocation: c, withBaseStyles: u = !0, addHeadTag: d, addBodyScript: f, loadComponentsOverNetwork: p = !1, isFigmake: y = !1, renderOptions: g, children: S }) { return (0, We.jsx)(DS, { websiteData: e, cmsBundleData: t, history: r, getAssetURL: n, getFontURL: o, getVideoURL: i, getCodeComponentURL: s, env: a, transitionAtom: l, setLocation: c, preloadLocation: GW, renderOptions: g, withBaseStyles: u, addHeadTag: d, addBodyScript: f, loadComponentsOverNetwork: p, isFigmake: y, children: (0, We.jsxs)(We.Fragment, { children: [(0, We.jsx)(cE, { withBaseStyles: u, prepend: !0 }), (0, We.jsx)(lE, {}), S] }) }) } var $W = "[Hydrated]"; function KW(e) { (0, jr.useEffect)(() => { e && console.log($W) }, [e]) } function dE(e = {}) { let { preset: t = "default" } = e, r = t === "code_layer" || t === "mcp", n = t === "mcp"; return { disableElementIds: r, disableDataAttributes: r, disableBehaviors: r, preferCssGradients: r, disableBackgroundDivs: r, useFigmaClipContentsForOverflow: r, disableTextMarkerVariables: r, disableHighSpecificityContainer: r, disableConstraintsBasedSizing: r, renderHiddenRootNodes: r, renderComponentSetNodes: r, disableImageOptimization: r, disableVariableErrors: r, optimizeForTailwindConversion: r, disableInlineSvgGeneration: r, disableAdjustLetterSpacing: r, ignoreEmptyAbsoluteElements: r, rootNodeStyle: e?.rootNodeStyle ?? (r ? "independent" : void 0), minimizeAutoLayoutWrappers: n, dontUseChildDivForBorderStyles: n, shouldOutputVariables: n, codeSyntaxLanguage: e.codeSyntaxLanguage ?? void 0, previewingCodeBehavior: e.previewingCodeBehavior ?? !1, testFlags: e.testFlags } } var Xg = class { capacity; leakRate; currentVolume; lastTimestamp; constructor(t, r) { this.capacity = t, this.leakRate = r, this.currentVolume = 0, this.lastTimestamp = Date.now() } leak() { let t = Date.now(), n = (t - this.lastTimestamp) * this.leakRate; this.currentVolume = Math.max(0, this.currentVolume - n), this.lastTimestamp = t } tryAdd(t = 1) { return this.leak(), this.currentVolume + t <= this.capacity ? (this.currentVolume += t, !0) : !1 } }; function XW(e, t, r) { let n = YW(e, t); return E_(n, r) } function YW(e, t) { let r = kp(); ju(r, al(e)); let n = Ip(J().get, r, t)[0]; if (!n) throw new Rt(`Not found: ${t}`); let o = n.id; return { key: "root", nodeById: r.nodeById, assets: r.assets, nodeId: o, preexpandedNodeId: o, parentStates: null, modeContext: {}, parentState: fn.createRoot(r, null, { disableVariableErrors: !1 }), animateRootIds: new Set, stablePathToAssetHash: r.stablePathToAssetHash, assetIdToGuid: r.assetIdToGuid, guidToUrl: r.guidToUrl } } function E_(e, t) { try { let r = $s(J().get, e, t), n = r.visible ? r.materializedChildNodeProps?.map(i => E_(i, t)) : void 0, o = 1; if (n) for (let i of n) o += i.nodesInSubtree; return delete r.interactionHandlers, delete r.materializedChildNodeProps, delete r.transitionProps, delete r.variableState, delete r.modeContext, structuredClone(r), { node: r, children: n, nodesInSubtree: o } } catch (r) { return console.log("Materialization error", r), { node: { type: "ERROR", name: r.message }, nodesInSubtree: 1 } } } var qW = "[Hydration Error]", QW = ["hydrat", "Minified React error #418", "Minified React error #423", "Minified React error #424", "Minified React error #425"], C_ = class { root; container; websiteData; cmsBundleDataAtom; env; pendingLocationAtom; currentLocationAtom; transitionAtom; getPage; getAssetURL; getVideoURL; getFontURL; history; onWindowResize = null; rootMaterializedNodePropsArrayAtom; materializedRenderOptionsAtom; codeComponentsVersion; assetsVersion; fontsVersion; videoVersion; bundleId; loadComponentsOverNetwork; wasServerRendered; classNamesToStyles; globalStyleSheets; linkTags; metaTags; bodyScripts = []; title; withBaseStyles; isFigmake; onPageRendered; onReactError; onLocationChange; needsHydration = !1; _resolveRootsRuntimeAtomForTests = void 0; _rootsRuntimeAtomForTestsPromise = void 0; getPagePreloadCache = new Map; materializedRenderOptions; constructor({ container: t, env: r, loadComponentsOverNetwork: n = !1, history: o, getAssetURL: i = void 0, getFontURL: s = void 0, getVideoURL: a = void 0, getPage: l = void 0, onPageRendered: c, onReactError: u = zu, onLocationChange: d, sendMessage: f = Ww, codeComponentsVersion: p, assetsVersion: y, fontsVersion: g, videoVersion: S, bundleId: h, renderOptions: m = {}, wasServerRendered: v = !1, withBaseStyles: x = !0, reportingDomain: C, userId: T, analyticsHeaders: E, bundleCreationDate: w, isFigmake: k }) { if (this.container = t, this.bundleId = h, this.env = r, this.withBaseStyles = x, this.pendingLocationAtom = q(null), this.currentLocationAtom = q(null), this.transitionAtom = q(void 0), this.getPage = l ?? this.defaultGetPage, this.getAssetURL = i || this.defaultGetAssetURL, this.getFontURL = s || this.defaultGetFontURL, this.getVideoURL = a || this.defaultGetVideoURL, CI(f), o || (o = new ZW(R => this.setLocation(R, !0))), this.websiteData = kp(), this.cmsBundleDataAtom = q(null), this.history = o, this.loadComponentsOverNetwork = n, this.wasServerRendered = v, this.needsHydration = v, this.classNamesToStyles = {}, this.globalStyleSheets = {}, this.linkTags = [], this.metaTags = [], this.isFigmake = !!k, this.onPageRendered = c, this.onReactError = u, this.onLocationChange = d, ke.init({ env: r, reportingDomain: C || "", rateLimiter: new Xg(100, 1 / 1e3), analyticsHeaders: E, userId: T, bundleId: h, bundleCreationDate: w }), this.materializedRenderOptions = dE(m), this.materializedRenderOptionsAtom = q(this.materializedRenderOptions), this.rootMaterializedNodePropsArrayAtom = q(R => { let A = R(this.currentLocationAtom); if (!A) return []; let N = Ip(R, this.websiteData, A.url); if (!N || N.length === 0) throw new Rt(`Not found: ${A.url}`); return this._resolveRootsRuntimeAtomForTests?.(), N.map(O => { let D = O.id; return { key: D, nodeById: this.websiteData.nodeById, assets: this.websiteData.assets, assetIdToGuid: this.websiteData.assetIdToGuid, guidToUrl: this.websiteData.guidToUrl, animateRootIds: this.websiteData.animateRootIds, stablePathToAssetHash: this.websiteData.stablePathToAssetHash, nodeId: D, preexpandedNodeId: D, modeContext: {}, parentStates: null, parentState: fn.createRoot(this.websiteData, R(this.cmsBundleDataAtom), this.materializedRenderOptions) } }) }), this.codeComponentsVersion = p, this.assetsVersion = y, this.fontsVersion = g, this.videoVersion = S, this.isPreview() || this.isPublished() || this.isSnapshot()) { this.onWindowResize = () => { J().set(fl, { width: window.innerWidth, height: window.innerHeight }) }, this.onWindowResize(), window.addEventListener("resize", this.onWindowResize); let R = (A, N, O, D, b) => { b && ke.reportError(b) }; window.addEventListener("error", R) } if (this.isPreview() || this.isPublished() && !this.wasServerRendered) { if (!t) throw new te("Container is required in order to render the site."); this.root = (0, qg.createRoot)(t), this.root.render(this.createWebsiteElement()) } } isServer() { return this.env === "server" } isPreview() { return this.env === "preview" } isPublished() { return this.env === "published" } isSnapshot() { return this.env === "snapshot" } createWebsiteElement() { return (0, Yg.createElement)(T_, { websiteData: this.websiteData, cmsBundleDataAtom: this.cmsBundleDataAtom, env: this.env, rootMaterializedNodePropsArrayAtom: this.rootMaterializedNodePropsArrayAtom, history: this.history, getAssetURL: this.getAssetURL, getFontURL: this.getFontURL, getVideoURL: this.getVideoURL, getCodeComponentURL: this.getCodeComponentURL, transitionAtom: this.transitionAtom, withBaseStyles: this.withBaseStyles, currentLocationAtom: this.currentLocationAtom, setLocation: t => this.setLocation(t, !1), preloadLocation: t => { this.preloadLocation(t) }, onPageRendered: this.onPageRendered, onReactError: this.handleReactError, renderOptionsAtom: this.materializedRenderOptionsAtom, addHeadTag: t => { t.type === "class-style" ? this.classNamesToStyles[t.className] = { cssProperties: t.cssProperties, classNameSourceStr: t.classNameSourceStr } : t.type === "global-style" ? this.globalStyleSheets[t.styleElId] = t.styleSheet : t.type === "link" ? this.linkTags.push(t) : t.type === "meta" ? this.metaTags.push(t) : t.type === "title" && (this.title = t.title) }, addBodyScript: t => { this.bodyScripts.push(t) }, loadComponentsOverNetwork: this.loadComponentsOverNetwork, wasServerRendered: this.wasServerRendered, isFigmake: this.isFigmake }) } defaultGetAssetURL = (t, { width: r, height: n } = {}) => { if (this.assetsVersion) { let o = new URLSearchParams; r && o.set("w", r.toString()), n && o.set("h", n.toString()); let i = o.size > 0 ? `?${o.toString()}` : ""; return `/_assets/${this.assetsVersion}/${t}${i}` } return t }; defaultGetFontURL = (t, r) => r === "CUSTOM" ? `/_user_fonts/${this.fontsVersion || "v1"}/${t}` : t; defaultGetVideoURL = (t, r) => this.isPreview() ? t : `/_videos/${this.videoVersion || "v1"}/${r}`; defaultGetPage = async t => { let r = t === "/" ? "/_index" : t, n = `/_json/${this.bundleId}${r}.json`, o = await fetch(n, { method: "GET", credentials: "include", mode: "no-cors" }); o.status === 401 && o.headers.get("x-figma-needs-reauth") && (console.log("Re-authentication required; reloading the page"), window.location.reload()); let i = await o.json(), s = !1; if (i.nodeById) for (let l in i.nodeById) { let c = i.nodeById[l]; if (c && (c.cmsCollectionBindingProperties || c.cmsItemFieldBindingProperties)) { s = !0; break } } let a = null; if (s) try { let l = `/_json/${this.bundleId}/_cms${r}.json`, c = await fetch(l, { method: "GET", credentials: "include", mode: "no-cors" }); c.ok && (a = await c.json()) } catch (l) { ke.reportError(new Rt("Error loading CMS resource", l)), console.error(l) } return { resource: i, cmsResource: a } }; preloadLocation(t) { let r = this.getPagePreloadCache.get(t); return r || (r = this.getPage(t), this.getPagePreloadCache.set(t, r)), r } setLocation(t, r) { if (t.url === "") return; let n = J(); n.set(this.pendingLocationAtom, t), this.preloadLocation(t.url).then(({ resource: o, cmsResource: i }) => { if (ju(this.websiteData, al(o)), i) { let s = Dw(i), a = n.get(this.cmsBundleDataAtom); a || (a = Xw()), Yw(a, s), n.set(this.cmsBundleDataAtom, a) } r || this.history.push(t), n.set(this.currentLocationAtom, t), we(t.transition, n.get(this.transitionAtom)) || n.set(this.transitionAtom, t.transition), this.onLocationChange?.(this), this.needsHydration && (this.needsHydration = !1, this.hydrate()) }).catch(o => { let i = o instanceof Error; if (i) { let s = o.message; if (s === AS || s === NS) return } throw i ? o : new Error("Error setting location " + String(o)) }).finally(() => { this.getPagePreloadCache.delete(t.url) }) } getCodeComponentURL = () => { let t = J(); if (this.codeComponentsVersion) { let o = t.get(this.websiteData.sourceCodeHash); return o ? `/_components/${this.codeComponentsVersion}/${o}.js` : (console.warn("Source code hash not found"), "") } let r = "data:text/javascript;charset=utf-8,", n = this.websiteData.compiledCode; return n == null ? (console.warn("Compiled code not found"), r) : r + encodeURIComponent(t.get(n) ?? "") }; createSnapshotWrapper(t) { let r = J(); return (0, Yg.createElement)(uE, { websiteData: this.websiteData, cmsBundleData: r.get(this.cmsBundleDataAtom), history: this.history, getAssetURL: this.getAssetURL, getFontURL: this.getFontURL, getVideoURL: this.getVideoURL, getCodeComponentURL: this.getCodeComponentURL, env: this.env, transitionAtom: this.transitionAtom, setLocation: () => { }, addHeadTag: () => { }, addBodyScript: () => { }, loadComponentsOverNetwork: this.loadComponentsOverNetwork, withBaseStyles: this.withBaseStyles, isFigmake: this.isFigmake, renderOptions: this.materializedRenderOptions }, t) } resetGlobalVariableStateForSnapshot() { if (this.isSnapshot()) { let t = J(); fn.createRoot(this.websiteData, t.get(this.cmsBundleDataAtom), this.materializedRenderOptions, !0) } } createLayerElement({ guid: t, renderedByCode: r }) { let n = J(); n.set(this.currentLocationAtom, { url: "/" }); let o = this.websiteData.nodeById.get(t), i = n.get(o), s = J().get(this.rootMaterializedNodePropsArrayAtom), a; s && (a = s[0]); let l = J().get(dl); if (!a || !i) return null; a.nodeId = t, a.preexpandedNodeId = t, a.breakpointWidth = l; let c = $s(J().get, a, this.env); return function (d) { let f = d ? Object.fromEntries(Object.entries(d).filter(([y]) => y.startsWith("data-"))) : {}, p = { renderedByCode: r, style: d?.style, className: d?.className, dataAttributes: f }; return (0, Yg.createElement)(Fn, { node: c, parent: null, context: p }) } } refresh() { window.location.reload() } pushPageData(t) { ju(this.websiteData, al(t)) } pushAssetData(t) { _S(this.websiteData, _w(t)) } unmount() { this.isServer() || (this.onWindowResize && window.removeEventListener("resize", this.onWindowResize), setTimeout(() => { this.root?.unmount() })) } hydrate() { this.wasServerRendered, me(!!this.container, "Container must be provided in order to hydrate the site."), this.isFigmake || oR(), (0, qg.hydrateRoot)(this.container, this.createWebsiteElement(), { onRecoverableError: (t, r) => { let n = t.message.toLocaleLowerCase(), o = !1; for (let i of QW) if (n.includes(i.toLocaleLowerCase())) { o = !0; break } o ? console.error(qW, t, t.cause ?? "", r.componentStack) : console.error(t, r.componentStack) } }) } toggleDebugTools() { let t = J(); t.set(Hu, !t.get(Hu)) } _convertMaterializedNodePropsDataForTest(t) { let r = $s(J().get, t, this.env), n = r.materializedChildNodeProps; return delete r.interactionHandlers, delete r.materializedChildNodeProps, delete r.transitionProps, "variableState" in r && delete r.variableState, "modeContext" in r && delete r.modeContext, { materializedNode: r, materializedChildNodeProps: n } } async _getSerializedMaterializedNodePropsArrayDataForTests() { J().get(this.rootMaterializedNodePropsArrayAtom) || (this._rootsRuntimeAtomForTestsPromise = new Promise(i => { this._resolveRootsRuntimeAtomForTests = i })), await this._rootsRuntimeAtomForTestsPromise; let t = J().get(this.rootMaterializedNodePropsArrayAtom); me(!!t && t.length > 0, "Root nodes not found"); let r = {}, n = i => { let s = this._convertMaterializedNodePropsDataForTest(i); r[s.materializedNode.id] = s.materializedNode, s.materializedChildNodeProps?.forEach(a => n(a)) }; return { rootIds: t.map(i => (n(i), this._convertMaterializedNodePropsDataForTest(i).materializedNode.id)), nodeByGuidMap: r } } listenForTestEvent(t) { return new Promise(r => { let n = o => { let i = o.detail.name; t === i && (window.removeEventListener("FigmaTestEvent", n), r(t)) }; window.addEventListener("FigmaTestEvent", n) }) } setRenderOptions(t) { this.materializedRenderOptions = dE(t), J().set(this.materializedRenderOptionsAtom, this.materializedRenderOptions) } handleReactError = (t, r = {}) => { try { this.onReactError(t, r) } catch { } ke.reportError(t) } }, ZW = class { onPopState; constructor(t) { this.onPopState = t, window.addEventListener("popstate", r => { let n = r.state; this.onPopState({ ...this.current, scrollY: n?.scrollY }) }), history.replaceState({}, "", this.href), t(this.current) } get current() { return { url: window.location.pathname, search: window.location.search } } get href() { let { url: t, search: r } = this.current; return b_(t, r) } push(t) { history.replaceState({ scrollY: window.scrollY }, "", this.href), history.pushState({}, "", b_(t.url || "/", t.search || "")) } forward() { history.forward() } back() { history.back() } }, b_ = (e, t) => e + t; export { Nc as ActiveBreakpointContext, oT as ActiveBreakpointProvider, $5 as AppearBehaviorPresetTransition, Wd as BannerComponentType, fo as BehaviorPresetEasingFunctions, G5 as BehaviorPresetScrollParallaxSpeed, U5 as BehaviorPresetStates, rP as BehaviorPresetTransition, Ye as BehaviorType, ze as BlendMode, Cw as CmsRichTextNodeDefaults, Ow as CodeComponentNodeDefaults, Pw as CodeFileNodeDefaults, Aw as CodeInstanceNodeDefaults, Nw as CodeLayerNodeDefaults, hw as ComponentNodeDefaults, gw as ComponentSetNodeDefaults, Wr as ConsentType, ZT as CookieConsentBanner, Fc as CookieConsentContext, y4 as CornerRadiusShapeTraitsDefaults, RS as CornerTraitDefaults, X3 as DEFAULT_HISTORY_STATE, VT as DEFAULT_SITE_DESCRIPTION, BT as DEFAULT_SITE_TITLE, Bu as DefaultShapeTraitsDefaults, St as EasingType, Re as ExpressionFunction, uw as FontVariantPosition, Sw as FrameNodeDefaults, Qr as FrameTraitsDefaults, Tw as GroupNodeDefaults, Lw as HTMLWidgetType, Mu as HasBlendModeAndOpacityTraitDefaults, EB as HasEffectsTraitDefaults, CB as HasFramePropertiesTraitDefaults, xp as HasGeometryTraitDefaults, Sp as HasLayoutTraitDefaults, fw as HasMaskTraitDefaults, vw as ImageNodeDefaults, bw as InstanceNodeDefaults, g4 as InteractionTraitDefaults, bB as IsInAnimateTreeTraitDefaults, sl as IsLayerTraitDefaults, FT as LOTTIEFILES_REGEX, Pn as LayoutConstraintHorizontal, Ln as LayoutConstraintVertical, Li as LineTypes, K5 as MARQUEE_PRESET_DEFAULT_SPEED, fa as NewRenderHooksContext, zg as RESET_STYLES_ID, ww as RectangleNodeDefaults, pw as RectangularShapeTraitsDefaults, da as RenderHooksContext, Ew as RepeaterNodeDefaults, dw as ResponsiveTraitDefaults, NS as SITES_PREVIEW_GET_PAGE_ERROR_SANDBOX, AS as SITES_PREVIEW_GET_PAGE_ERROR_SNAPSHOT, C_ as SitesRuntime, xw as SlotNodeDefaults, K as SmartAnimateType, Ld as SnapshotContext, uE as SnapshotWebsiteProvider, Vu as SourceCodeTraitsDefaults, yw as SvgNodeDefaults, vp as TextDecoration, Iw as TextNodeDefaults, mw as TypePropertiesTraitDefaults, kw as WebpageNodeDefaults, Pc as WebsiteSettingsContext, dT as WebsiteSettingsProvider, Rw as WidgetNodeDefaults, ni as XAlignment, oi as YAlignment, Tp as applyDefaultsToPrototype, Ts as buildFontFace, gH as createPropertySetters, Pd as getChildNode, Od as getChildNodes, yg as getImageProp, XW as getMaterializedTreeForWebsite, lT as getPropertySetterNameMap, qo as guidToDOMId, Ep as isPaintGradient, U0 as makeFramerMotionDefinition, al as parseBundle, kS as parseNode, w4 as parseSchemaData, MT as resetCSS, Kp as solidColor, Nd as useAnimateNode };
/*!
  Copyright (c) 2018 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/*!
 * Bowser - a browser detector
 * https://github.com/ded/bowser
 * MIT License | (c) Dustin Diaz 2015
 */
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * react-jsx-dev-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license Tailwind
 * https://github.com/tailwindlabs/tailwindcss/blob/v3.4.17/src/css/preflight.css
 *
 * Copyright (c) Tailwind Labs, Inc.
 *
 * Some of the source code in this file comes from the TailwindCSS project, which is licnesed under the MIT license
 * https://github.com/tailwindlabs/tailwindcss/blob/main/LICENSE
 */
/**
 * @license react-fast-marquee
 *
 * Adapted from https://github.com/justin-chu/react-fast-marquee/blob/master/src/components/Marquee.tsx
 * Copyright (c) 2020 justin-chu
 * MIT License
 */

// #version: 5c483e5230fea387f8db469f9ac65c2e1dc73f58
